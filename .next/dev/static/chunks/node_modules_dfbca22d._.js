(globalThis.TURBOPACK || (globalThis.TURBOPACK = [])).push([typeof document === "object" ? document.currentScript : undefined,
"[project]/node_modules/lucide-react/dist/esm/icons/search.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * @license lucide-react v0.454.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ __turbopack_context__.s([
    "default",
    ()=>Search
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lucide-react/dist/esm/createLucideIcon.js [app-client] (ecmascript)");
;
const Search = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])("Search", [
    [
        "circle",
        {
            cx: "11",
            cy: "11",
            r: "8",
            key: "4ej97u"
        }
    ],
    [
        "path",
        {
            d: "m21 21-4.3-4.3",
            key: "1qie3q"
        }
    ]
]);
;
 //# sourceMappingURL=search.js.map
}),
"[project]/node_modules/lucide-react/dist/esm/icons/search.js [app-client] (ecmascript) <export default as Search>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Search",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$search$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$search$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lucide-react/dist/esm/icons/search.js [app-client] (ecmascript)");
}),
"[project]/node_modules/lucide-react/dist/esm/icons/x.js [app-client] (ecmascript) <export default as X>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "X",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$x$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$x$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lucide-react/dist/esm/icons/x.js [app-client] (ecmascript)");
}),
"[project]/node_modules/@radix-ui/react-alert-dialog/dist/index.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Action",
    ()=>Action,
    "AlertDialog",
    ()=>AlertDialog,
    "AlertDialogAction",
    ()=>AlertDialogAction,
    "AlertDialogCancel",
    ()=>AlertDialogCancel,
    "AlertDialogContent",
    ()=>AlertDialogContent,
    "AlertDialogDescription",
    ()=>AlertDialogDescription,
    "AlertDialogOverlay",
    ()=>AlertDialogOverlay,
    "AlertDialogPortal",
    ()=>AlertDialogPortal,
    "AlertDialogTitle",
    ()=>AlertDialogTitle,
    "AlertDialogTrigger",
    ()=>AlertDialogTrigger,
    "Cancel",
    ()=>Cancel,
    "Content",
    ()=>Content2,
    "Description",
    ()=>Description2,
    "Overlay",
    ()=>Overlay2,
    "Portal",
    ()=>Portal2,
    "Root",
    ()=>Root2,
    "Title",
    ()=>Title2,
    "Trigger",
    ()=>Trigger2,
    "createAlertDialogScope",
    ()=>createAlertDialogScope
]);
// packages/react/alert-dialog/src/AlertDialog.tsx
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$react$2d$context$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@radix-ui/react-context/dist/index.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$react$2d$compose$2d$refs$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@radix-ui/react-compose-refs/dist/index.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$react$2d$dialog$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@radix-ui/react-dialog/dist/index.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$primitive$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@radix-ui/primitive/dist/index.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$react$2d$slot$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@radix-ui/react-slot/dist/index.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react/jsx-runtime.js [app-client] (ecmascript)");
"use client";
;
;
;
;
;
;
;
;
var ROOT_NAME = "AlertDialog";
var [createAlertDialogContext, createAlertDialogScope] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$react$2d$context$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createContextScope"])(ROOT_NAME, [
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$react$2d$dialog$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createDialogScope"]
]);
var useDialogScope = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$react$2d$dialog$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createDialogScope"])();
var AlertDialog = (props)=>{
    const { __scopeAlertDialog, ...alertDialogProps } = props;
    const dialogScope = useDialogScope(__scopeAlertDialog);
    return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$react$2d$dialog$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Root"], {
        ...dialogScope,
        ...alertDialogProps,
        modal: true
    });
};
AlertDialog.displayName = ROOT_NAME;
var TRIGGER_NAME = "AlertDialogTrigger";
var AlertDialogTrigger = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["forwardRef"]((props, forwardedRef)=>{
    const { __scopeAlertDialog, ...triggerProps } = props;
    const dialogScope = useDialogScope(__scopeAlertDialog);
    return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$react$2d$dialog$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Trigger"], {
        ...dialogScope,
        ...triggerProps,
        ref: forwardedRef
    });
});
AlertDialogTrigger.displayName = TRIGGER_NAME;
var PORTAL_NAME = "AlertDialogPortal";
var AlertDialogPortal = (props)=>{
    const { __scopeAlertDialog, ...portalProps } = props;
    const dialogScope = useDialogScope(__scopeAlertDialog);
    return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$react$2d$dialog$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Portal"], {
        ...dialogScope,
        ...portalProps
    });
};
AlertDialogPortal.displayName = PORTAL_NAME;
var OVERLAY_NAME = "AlertDialogOverlay";
var AlertDialogOverlay = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["forwardRef"]((props, forwardedRef)=>{
    const { __scopeAlertDialog, ...overlayProps } = props;
    const dialogScope = useDialogScope(__scopeAlertDialog);
    return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$react$2d$dialog$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Overlay"], {
        ...dialogScope,
        ...overlayProps,
        ref: forwardedRef
    });
});
AlertDialogOverlay.displayName = OVERLAY_NAME;
var CONTENT_NAME = "AlertDialogContent";
var [AlertDialogContentProvider, useAlertDialogContentContext] = createAlertDialogContext(CONTENT_NAME);
var AlertDialogContent = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["forwardRef"]((props, forwardedRef)=>{
    const { __scopeAlertDialog, children, ...contentProps } = props;
    const dialogScope = useDialogScope(__scopeAlertDialog);
    const contentRef = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"](null);
    const composedRefs = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$react$2d$compose$2d$refs$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useComposedRefs"])(forwardedRef, contentRef);
    const cancelRef = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"](null);
    return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$react$2d$dialog$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WarningProvider"], {
        contentName: CONTENT_NAME,
        titleName: TITLE_NAME,
        docsSlug: "alert-dialog",
        children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(AlertDialogContentProvider, {
            scope: __scopeAlertDialog,
            cancelRef,
            children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsxs"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$react$2d$dialog$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Content"], {
                role: "alertdialog",
                ...dialogScope,
                ...contentProps,
                ref: composedRefs,
                onOpenAutoFocus: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$primitive$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["composeEventHandlers"])(contentProps.onOpenAutoFocus, (event)=>{
                    event.preventDefault();
                    cancelRef.current?.focus({
                        preventScroll: true
                    });
                }),
                onPointerDownOutside: (event)=>event.preventDefault(),
                onInteractOutside: (event)=>event.preventDefault(),
                children: [
                    /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$react$2d$slot$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Slottable"], {
                        children
                    }),
                    /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(DescriptionWarning, {
                        contentRef
                    })
                ]
            })
        })
    });
});
AlertDialogContent.displayName = CONTENT_NAME;
var TITLE_NAME = "AlertDialogTitle";
var AlertDialogTitle = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["forwardRef"]((props, forwardedRef)=>{
    const { __scopeAlertDialog, ...titleProps } = props;
    const dialogScope = useDialogScope(__scopeAlertDialog);
    return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$react$2d$dialog$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Title"], {
        ...dialogScope,
        ...titleProps,
        ref: forwardedRef
    });
});
AlertDialogTitle.displayName = TITLE_NAME;
var DESCRIPTION_NAME = "AlertDialogDescription";
var AlertDialogDescription = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["forwardRef"]((props, forwardedRef)=>{
    const { __scopeAlertDialog, ...descriptionProps } = props;
    const dialogScope = useDialogScope(__scopeAlertDialog);
    return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$react$2d$dialog$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Description"], {
        ...dialogScope,
        ...descriptionProps,
        ref: forwardedRef
    });
});
AlertDialogDescription.displayName = DESCRIPTION_NAME;
var ACTION_NAME = "AlertDialogAction";
var AlertDialogAction = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["forwardRef"]((props, forwardedRef)=>{
    const { __scopeAlertDialog, ...actionProps } = props;
    const dialogScope = useDialogScope(__scopeAlertDialog);
    return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$react$2d$dialog$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Close"], {
        ...dialogScope,
        ...actionProps,
        ref: forwardedRef
    });
});
AlertDialogAction.displayName = ACTION_NAME;
var CANCEL_NAME = "AlertDialogCancel";
var AlertDialogCancel = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["forwardRef"]((props, forwardedRef)=>{
    const { __scopeAlertDialog, ...cancelProps } = props;
    const { cancelRef } = useAlertDialogContentContext(CANCEL_NAME, __scopeAlertDialog);
    const dialogScope = useDialogScope(__scopeAlertDialog);
    const ref = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$react$2d$compose$2d$refs$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useComposedRefs"])(forwardedRef, cancelRef);
    return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$react$2d$dialog$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Close"], {
        ...dialogScope,
        ...cancelProps,
        ref
    });
});
AlertDialogCancel.displayName = CANCEL_NAME;
var DescriptionWarning = ({ contentRef })=>{
    const MESSAGE = `\`${CONTENT_NAME}\` requires a description for the component to be accessible for screen reader users.

You can add a description to the \`${CONTENT_NAME}\` by passing a \`${DESCRIPTION_NAME}\` component as a child, which also benefits sighted users by adding visible context to the dialog.

Alternatively, you can use your own component as a description by assigning it an \`id\` and passing the same value to the \`aria-describedby\` prop in \`${CONTENT_NAME}\`. If the description is confusing or duplicative for sighted users, you can use the \`@radix-ui/react-visually-hidden\` primitive as a wrapper around your description component.

For more information, see https://radix-ui.com/primitives/docs/components/alert-dialog`;
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"]({
        "DescriptionWarning.useEffect": ()=>{
            const hasDescription = document.getElementById(contentRef.current?.getAttribute("aria-describedby"));
            if (!hasDescription) console.warn(MESSAGE);
        }
    }["DescriptionWarning.useEffect"], [
        MESSAGE,
        contentRef
    ]);
    return null;
};
var Root2 = AlertDialog;
var Trigger2 = AlertDialogTrigger;
var Portal2 = AlertDialogPortal;
var Overlay2 = AlertDialogOverlay;
var Content2 = AlertDialogContent;
var Action = AlertDialogAction;
var Cancel = AlertDialogCancel;
var Title2 = AlertDialogTitle;
var Description2 = AlertDialogDescription;
;
 //# sourceMappingURL=index.mjs.map
}),
"[project]/node_modules/lucide-react/dist/esm/icons/ellipsis.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * @license lucide-react v0.454.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ __turbopack_context__.s([
    "default",
    ()=>Ellipsis
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lucide-react/dist/esm/createLucideIcon.js [app-client] (ecmascript)");
;
const Ellipsis = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])("Ellipsis", [
    [
        "circle",
        {
            cx: "12",
            cy: "12",
            r: "1",
            key: "41hilf"
        }
    ],
    [
        "circle",
        {
            cx: "19",
            cy: "12",
            r: "1",
            key: "1wjl8i"
        }
    ],
    [
        "circle",
        {
            cx: "5",
            cy: "12",
            r: "1",
            key: "1pcz8c"
        }
    ]
]);
;
 //# sourceMappingURL=ellipsis.js.map
}),
"[project]/node_modules/lucide-react/dist/esm/icons/ellipsis.js [app-client] (ecmascript) <export default as MoreHorizontal>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "MoreHorizontal",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$ellipsis$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$ellipsis$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lucide-react/dist/esm/icons/ellipsis.js [app-client] (ecmascript)");
}),
"[project]/node_modules/sharp/lib/is.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

/*!
  Copyright 2013 Lovell Fuller and others.
  SPDX-License-Identifier: Apache-2.0
*/ /**
 * Is this value defined and not null?
 * @private
 */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/compiled/buffer/index.js [app-client] (ecmascript)");
const defined = (val)=>typeof val !== 'undefined' && val !== null;
/**
 * Is this value an object?
 * @private
 */ const object = (val)=>typeof val === 'object';
/**
 * Is this value a plain object?
 * @private
 */ const plainObject = (val)=>Object.prototype.toString.call(val) === '[object Object]';
/**
 * Is this value a function?
 * @private
 */ const fn = (val)=>typeof val === 'function';
/**
 * Is this value a boolean?
 * @private
 */ const bool = (val)=>typeof val === 'boolean';
/**
 * Is this value a Buffer object?
 * @private
 */ const buffer = (val)=>val instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"];
/**
 * Is this value a typed array object?. E.g. Uint8Array or Uint8ClampedArray?
 * @private
 */ const typedArray = (val)=>{
    if (defined(val)) {
        switch(val.constructor){
            case Uint8Array:
            case Uint8ClampedArray:
            case Int8Array:
            case Uint16Array:
            case Int16Array:
            case Uint32Array:
            case Int32Array:
            case Float32Array:
            case Float64Array:
                return true;
        }
    }
    return false;
};
/**
 * Is this value an ArrayBuffer object?
 * @private
 */ const arrayBuffer = (val)=>val instanceof ArrayBuffer;
/**
 * Is this value a non-empty string?
 * @private
 */ const string = (val)=>typeof val === 'string' && val.length > 0;
/**
 * Is this value a real number?
 * @private
 */ const number = (val)=>typeof val === 'number' && !Number.isNaN(val);
/**
 * Is this value an integer?
 * @private
 */ const integer = (val)=>Number.isInteger(val);
/**
 * Is this value within an inclusive given range?
 * @private
 */ const inRange = (val, min, max)=>val >= min && val <= max;
/**
 * Is this value within the elements of an array?
 * @private
 */ const inArray = (val, list)=>list.includes(val);
/**
 * Create an Error with a message relating to an invalid parameter.
 *
 * @param {string} name - parameter name.
 * @param {string} expected - description of the type/value/range expected.
 * @param {*} actual - the value received.
 * @returns {Error} Containing the formatted message.
 * @private
 */ const invalidParameterError = (name, expected, actual)=>new Error(`Expected ${expected} for ${name} but received ${actual} of type ${typeof actual}`);
/**
 * Ensures an Error from C++ contains a JS stack.
 *
 * @param {Error} native - Error with message from C++.
 * @param {Error} context - Error with stack from JS.
 * @returns {Error} Error with message and stack.
 * @private
 */ const nativeError = (native, context)=>{
    context.message = native.message;
    return context;
};
module.exports = {
    defined,
    object,
    plainObject,
    fn,
    bool,
    buffer,
    typedArray,
    arrayBuffer,
    string,
    number,
    integer,
    inRange,
    inArray,
    invalidParameterError,
    nativeError
};
}),
"[project]/node_modules/detect-libc/lib/process.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Copyright 2017 Lovell Fuller and others.
// SPDX-License-Identifier: Apache-2.0
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
'use strict';
const isLinux = ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].platform === 'linux';
let report = null;
const getReport = ()=>{
    if (!report) {
        /* istanbul ignore next */ if (isLinux() && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].report) //TURBOPACK unreachable
        ;
        else {
            report = {};
        }
    }
    return report;
};
module.exports = {
    isLinux,
    getReport
};
}),
"[project]/node_modules/detect-libc/lib/filesystem.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Copyright 2017 Lovell Fuller and others.
// SPDX-License-Identifier: Apache-2.0
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/compiled/buffer/index.js [app-client] (ecmascript)");
'use strict';
const fs = (()=>{
    const e = new Error("Cannot find module 'fs'");
    e.code = 'MODULE_NOT_FOUND';
    throw e;
})();
const LDD_PATH = '/usr/bin/ldd';
const SELF_PATH = '/proc/self/exe';
const MAX_LENGTH = 2048;
/**
 * Read the content of a file synchronous
 *
 * @param {string} path
 * @returns {Buffer}
 */ const readFileSync = (path)=>{
    const fd = fs.openSync(path, 'r');
    const buffer = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].alloc(MAX_LENGTH);
    const bytesRead = fs.readSync(fd, buffer, 0, MAX_LENGTH, 0);
    fs.close(fd, ()=>{});
    return buffer.subarray(0, bytesRead);
};
/**
 * Read the content of a file
 *
 * @param {string} path
 * @returns {Promise<Buffer>}
 */ const readFile = (path)=>new Promise((resolve, reject)=>{
        fs.open(path, 'r', (err, fd)=>{
            if (err) {
                reject(err);
            } else {
                const buffer = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].alloc(MAX_LENGTH);
                fs.read(fd, buffer, 0, MAX_LENGTH, 0, (_, bytesRead)=>{
                    resolve(buffer.subarray(0, bytesRead));
                    fs.close(fd, ()=>{});
                });
            }
        });
    });
module.exports = {
    LDD_PATH,
    SELF_PATH,
    readFileSync,
    readFile
};
}),
"[project]/node_modules/detect-libc/lib/elf.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Copyright 2017 Lovell Fuller and others.
// SPDX-License-Identifier: Apache-2.0
const interpreterPath = (elf)=>{
    if (elf.length < 64) {
        return null;
    }
    if (elf.readUInt32BE(0) !== 0x7F454C46) {
        // Unexpected magic bytes
        return null;
    }
    if (elf.readUInt8(4) !== 2) {
        // Not a 64-bit ELF
        return null;
    }
    if (elf.readUInt8(5) !== 1) {
        // Not little-endian
        return null;
    }
    const offset = elf.readUInt32LE(32);
    const size = elf.readUInt16LE(54);
    const count = elf.readUInt16LE(56);
    for(let i = 0; i < count; i++){
        const headerOffset = offset + i * size;
        const type = elf.readUInt32LE(headerOffset);
        if (type === 3) {
            const fileOffset = elf.readUInt32LE(headerOffset + 8);
            const fileSize = elf.readUInt32LE(headerOffset + 32);
            return elf.subarray(fileOffset, fileOffset + fileSize).toString().replace(/\0.*$/g, '');
        }
    }
    return null;
};
module.exports = {
    interpreterPath
};
}),
"[project]/node_modules/detect-libc/lib/detect-libc.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Copyright 2017 Lovell Fuller and others.
// SPDX-License-Identifier: Apache-2.0
const childProcess = (()=>{
    const e = new Error("Cannot find module 'child_process'");
    e.code = 'MODULE_NOT_FOUND';
    throw e;
})();
const { isLinux, getReport } = __turbopack_context__.r("[project]/node_modules/detect-libc/lib/process.js [app-client] (ecmascript)");
const { LDD_PATH, SELF_PATH, readFile, readFileSync } = __turbopack_context__.r("[project]/node_modules/detect-libc/lib/filesystem.js [app-client] (ecmascript)");
const { interpreterPath } = __turbopack_context__.r("[project]/node_modules/detect-libc/lib/elf.js [app-client] (ecmascript)");
let cachedFamilyInterpreter;
let cachedFamilyFilesystem;
let cachedVersionFilesystem;
const command = 'getconf GNU_LIBC_VERSION 2>&1 || true; ldd --version 2>&1 || true';
let commandOut = '';
const safeCommand = ()=>{
    if (!commandOut) {
        return new Promise((resolve)=>{
            childProcess.exec(command, (err, out)=>{
                commandOut = err ? ' ' : out;
                resolve(commandOut);
            });
        });
    }
    return commandOut;
};
const safeCommandSync = ()=>{
    if (!commandOut) {
        try {
            commandOut = childProcess.execSync(command, {
                encoding: 'utf8'
            });
        } catch (_err) {
            commandOut = ' ';
        }
    }
    return commandOut;
};
/**
 * A String constant containing the value `glibc`.
 * @type {string}
 * @public
 */ const GLIBC = 'glibc';
/**
 * A Regexp constant to get the GLIBC Version.
 * @type {string}
 */ const RE_GLIBC_VERSION = /LIBC[a-z0-9 \-).]*?(\d+\.\d+)/i;
/**
 * A String constant containing the value `musl`.
 * @type {string}
 * @public
 */ const MUSL = 'musl';
const isFileMusl = (f)=>f.includes('libc.musl-') || f.includes('ld-musl-');
const familyFromReport = ()=>{
    const report = getReport();
    if (report.header && report.header.glibcVersionRuntime) {
        return GLIBC;
    }
    if (Array.isArray(report.sharedObjects)) {
        if (report.sharedObjects.some(isFileMusl)) {
            return MUSL;
        }
    }
    return null;
};
const familyFromCommand = (out)=>{
    const [getconf, ldd1] = out.split(/[\r\n]+/);
    if (getconf && getconf.includes(GLIBC)) {
        return GLIBC;
    }
    if (ldd1 && ldd1.includes(MUSL)) {
        return MUSL;
    }
    return null;
};
const familyFromInterpreterPath = (path)=>{
    if (path) {
        if (path.includes('/ld-musl-')) {
            return MUSL;
        } else if (path.includes('/ld-linux-')) {
            return GLIBC;
        }
    }
    return null;
};
const getFamilyFromLddContent = (content)=>{
    content = content.toString();
    if (content.includes('musl')) {
        return MUSL;
    }
    if (content.includes('GNU C Library')) {
        return GLIBC;
    }
    return null;
};
const familyFromFilesystem = async ()=>{
    if (cachedFamilyFilesystem !== undefined) {
        return cachedFamilyFilesystem;
    }
    cachedFamilyFilesystem = null;
    try {
        const lddContent = await readFile(LDD_PATH);
        cachedFamilyFilesystem = getFamilyFromLddContent(lddContent);
    } catch (e) {}
    return cachedFamilyFilesystem;
};
const familyFromFilesystemSync = ()=>{
    if (cachedFamilyFilesystem !== undefined) {
        return cachedFamilyFilesystem;
    }
    cachedFamilyFilesystem = null;
    try {
        const lddContent = readFileSync(LDD_PATH);
        cachedFamilyFilesystem = getFamilyFromLddContent(lddContent);
    } catch (e) {}
    return cachedFamilyFilesystem;
};
const familyFromInterpreter = async ()=>{
    if (cachedFamilyInterpreter !== undefined) {
        return cachedFamilyInterpreter;
    }
    cachedFamilyInterpreter = null;
    try {
        const selfContent = await readFile(SELF_PATH);
        const path = interpreterPath(selfContent);
        cachedFamilyInterpreter = familyFromInterpreterPath(path);
    } catch (e) {}
    return cachedFamilyInterpreter;
};
const familyFromInterpreterSync = ()=>{
    if (cachedFamilyInterpreter !== undefined) {
        return cachedFamilyInterpreter;
    }
    cachedFamilyInterpreter = null;
    try {
        const selfContent = readFileSync(SELF_PATH);
        const path = interpreterPath(selfContent);
        cachedFamilyInterpreter = familyFromInterpreterPath(path);
    } catch (e) {}
    return cachedFamilyInterpreter;
};
/**
 * Resolves with the libc family when it can be determined, `null` otherwise.
 * @returns {Promise<?string>}
 */ const family = async ()=>{
    let family = null;
    if (isLinux()) {
        family = await familyFromInterpreter();
        if (!family) {
            family = await familyFromFilesystem();
            if (!family) {
                family = familyFromReport();
            }
            if (!family) {
                const out = await safeCommand();
                family = familyFromCommand(out);
            }
        }
    }
    return family;
};
/**
 * Returns the libc family when it can be determined, `null` otherwise.
 * @returns {?string}
 */ const familySync = ()=>{
    let family = null;
    if (isLinux()) {
        family = familyFromInterpreterSync();
        if (!family) {
            family = familyFromFilesystemSync();
            if (!family) {
                family = familyFromReport();
            }
            if (!family) {
                const out = safeCommandSync();
                family = familyFromCommand(out);
            }
        }
    }
    return family;
};
/**
 * Resolves `true` only when the platform is Linux and the libc family is not `glibc`.
 * @returns {Promise<boolean>}
 */ const isNonGlibcLinux = async ()=>isLinux() && await family() !== GLIBC;
/**
 * Returns `true` only when the platform is Linux and the libc family is not `glibc`.
 * @returns {boolean}
 */ const isNonGlibcLinuxSync = ()=>isLinux() && familySync() !== GLIBC;
const versionFromFilesystem = async ()=>{
    if (cachedVersionFilesystem !== undefined) {
        return cachedVersionFilesystem;
    }
    cachedVersionFilesystem = null;
    try {
        const lddContent = await readFile(LDD_PATH);
        const versionMatch = lddContent.match(RE_GLIBC_VERSION);
        if (versionMatch) {
            cachedVersionFilesystem = versionMatch[1];
        }
    } catch (e) {}
    return cachedVersionFilesystem;
};
const versionFromFilesystemSync = ()=>{
    if (cachedVersionFilesystem !== undefined) {
        return cachedVersionFilesystem;
    }
    cachedVersionFilesystem = null;
    try {
        const lddContent = readFileSync(LDD_PATH);
        const versionMatch = lddContent.match(RE_GLIBC_VERSION);
        if (versionMatch) {
            cachedVersionFilesystem = versionMatch[1];
        }
    } catch (e) {}
    return cachedVersionFilesystem;
};
const versionFromReport = ()=>{
    const report = getReport();
    if (report.header && report.header.glibcVersionRuntime) {
        return report.header.glibcVersionRuntime;
    }
    return null;
};
const versionSuffix = (s)=>s.trim().split(/\s+/)[1];
const versionFromCommand = (out)=>{
    const [getconf, ldd1, ldd2] = out.split(/[\r\n]+/);
    if (getconf && getconf.includes(GLIBC)) {
        return versionSuffix(getconf);
    }
    if (ldd1 && ldd2 && ldd1.includes(MUSL)) {
        return versionSuffix(ldd2);
    }
    return null;
};
/**
 * Resolves with the libc version when it can be determined, `null` otherwise.
 * @returns {Promise<?string>}
 */ const version = async ()=>{
    let version = null;
    if (isLinux()) {
        version = await versionFromFilesystem();
        if (!version) {
            version = versionFromReport();
        }
        if (!version) {
            const out = await safeCommand();
            version = versionFromCommand(out);
        }
    }
    return version;
};
/**
 * Returns the libc version when it can be determined, `null` otherwise.
 * @returns {?string}
 */ const versionSync = ()=>{
    let version = null;
    if (isLinux()) {
        version = versionFromFilesystemSync();
        if (!version) {
            version = versionFromReport();
        }
        if (!version) {
            const out = safeCommandSync();
            version = versionFromCommand(out);
        }
    }
    return version;
};
module.exports = {
    GLIBC,
    MUSL,
    family,
    familySync,
    isNonGlibcLinux,
    isNonGlibcLinuxSync,
    version,
    versionSync
};
}),
"[project]/node_modules/semver/internal/debug.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
'use strict';
const debug = typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] === 'object' && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].env && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].env.NODE_DEBUG && /\bsemver\b/i.test(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].env.NODE_DEBUG) ? (...args)=>console.error('SEMVER', ...args) : ()=>{};
module.exports = debug;
}),
"[project]/node_modules/semver/internal/constants.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Note: this is the semver.org version of the spec that it implements
// Not necessarily the package version of this code.
const SEMVER_SPEC_VERSION = '2.0.0';
const MAX_LENGTH = 256;
const MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */ 9007199254740991;
// Max safe segment length for coercion.
const MAX_SAFE_COMPONENT_LENGTH = 16;
// Max safe length for a build identifier. The max length minus 6 characters for
// the shortest version with a build 0.0.0+BUILD.
const MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
const RELEASE_TYPES = [
    'major',
    'premajor',
    'minor',
    'preminor',
    'patch',
    'prepatch',
    'prerelease'
];
module.exports = {
    MAX_LENGTH,
    MAX_SAFE_COMPONENT_LENGTH,
    MAX_SAFE_BUILD_LENGTH,
    MAX_SAFE_INTEGER,
    RELEASE_TYPES,
    SEMVER_SPEC_VERSION,
    FLAG_INCLUDE_PRERELEASE: 0b001,
    FLAG_LOOSE: 0b010
};
}),
"[project]/node_modules/semver/internal/re.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const { MAX_SAFE_COMPONENT_LENGTH, MAX_SAFE_BUILD_LENGTH, MAX_LENGTH } = __turbopack_context__.r("[project]/node_modules/semver/internal/constants.js [app-client] (ecmascript)");
const debug = __turbopack_context__.r("[project]/node_modules/semver/internal/debug.js [app-client] (ecmascript)");
exports = module.exports = {};
// The actual regexps go on exports.re
const re = exports.re = [];
const safeRe = exports.safeRe = [];
const src = exports.src = [];
const safeSrc = exports.safeSrc = [];
const t = exports.t = {};
let R = 0;
const LETTERDASHNUMBER = '[a-zA-Z0-9-]';
// Replace some greedy regex tokens to prevent regex dos issues. These regex are
// used internally via the safeRe object since all inputs in this library get
// normalized first to trim and collapse all extra whitespace. The original
// regexes are exported for userland consumption and lower level usage. A
// future breaking change could export the safer regex only with a note that
// all input should have extra whitespace removed.
const safeRegexReplacements = [
    [
        '\\s',
        1
    ],
    [
        '\\d',
        MAX_LENGTH
    ],
    [
        LETTERDASHNUMBER,
        MAX_SAFE_BUILD_LENGTH
    ]
];
const makeSafeRegex = (value)=>{
    for (const [token, max] of safeRegexReplacements){
        value = value.split(`${token}*`).join(`${token}{0,${max}}`).split(`${token}+`).join(`${token}{1,${max}}`);
    }
    return value;
};
const createToken = (name, value, isGlobal)=>{
    const safe = makeSafeRegex(value);
    const index = R++;
    debug(name, index, value);
    t[name] = index;
    src[index] = value;
    safeSrc[index] = safe;
    re[index] = new RegExp(value, isGlobal ? 'g' : undefined);
    safeRe[index] = new RegExp(safe, isGlobal ? 'g' : undefined);
};
// The following Regular Expressions can be used for tokenizing,
// validating, and parsing SemVer version strings.
// ## Numeric Identifier
// A single `0`, or a non-zero digit followed by zero or more digits.
createToken('NUMERICIDENTIFIER', '0|[1-9]\\d*');
createToken('NUMERICIDENTIFIERLOOSE', '\\d+');
// ## Non-numeric Identifier
// Zero or more digits, followed by a letter or hyphen, and then zero or
// more letters, digits, or hyphens.
createToken('NONNUMERICIDENTIFIER', `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
// ## Main Version
// Three dot-separated numeric identifiers.
createToken('MAINVERSION', `(${src[t.NUMERICIDENTIFIER]})\\.` + `(${src[t.NUMERICIDENTIFIER]})\\.` + `(${src[t.NUMERICIDENTIFIER]})`);
createToken('MAINVERSIONLOOSE', `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` + `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` + `(${src[t.NUMERICIDENTIFIERLOOSE]})`);
// ## Pre-release Version Identifier
// A numeric identifier, or a non-numeric identifier.
// Non-numberic identifiers include numberic identifiers but can be longer.
// Therefore non-numberic identifiers must go first.
createToken('PRERELEASEIDENTIFIER', `(?:${src[t.NONNUMERICIDENTIFIER]}|${src[t.NUMERICIDENTIFIER]})`);
createToken('PRERELEASEIDENTIFIERLOOSE', `(?:${src[t.NONNUMERICIDENTIFIER]}|${src[t.NUMERICIDENTIFIERLOOSE]})`);
// ## Pre-release Version
// Hyphen, followed by one or more dot-separated pre-release version
// identifiers.
createToken('PRERELEASE', `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`);
createToken('PRERELEASELOOSE', `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);
// ## Build Metadata Identifier
// Any combination of digits, letters, or hyphens.
createToken('BUILDIDENTIFIER', `${LETTERDASHNUMBER}+`);
// ## Build Metadata
// Plus sign, followed by one or more period-separated build metadata
// identifiers.
createToken('BUILD', `(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`);
// ## Full Version String
// A main version, followed optionally by a pre-release version and
// build metadata.
// Note that the only major, minor, patch, and pre-release sections of
// the version string are capturing groups.  The build metadata is not a
// capturing group, because it should not ever be used in version
// comparison.
createToken('FULLPLAIN', `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`);
createToken('FULL', `^${src[t.FULLPLAIN]}$`);
// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.
// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty
// common in the npm registry.
createToken('LOOSEPLAIN', `[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`);
createToken('LOOSE', `^${src[t.LOOSEPLAIN]}$`);
createToken('GTLT', '((?:<|>)?=?)');
// Something like "2.*" or "1.2.x".
// Note that "x.x" is a valid xRange identifer, meaning "any version"
// Only the first item is strictly required.
createToken('XRANGEIDENTIFIERLOOSE', `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
createToken('XRANGEIDENTIFIER', `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);
createToken('XRANGEPLAIN', `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})` + `(?:\\.(${src[t.XRANGEIDENTIFIER]})` + `(?:\\.(${src[t.XRANGEIDENTIFIER]})` + `(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?` + `)?)?`);
createToken('XRANGEPLAINLOOSE', `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})` + `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` + `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` + `(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?` + `)?)?`);
createToken('XRANGE', `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`);
createToken('XRANGELOOSE', `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`);
// Coercion.
// Extract anything that could conceivably be a part of a valid semver
createToken('COERCEPLAIN', `${'(^|[^\\d])' + '(\\d{1,'}${MAX_SAFE_COMPONENT_LENGTH}})` + `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` + `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`);
createToken('COERCE', `${src[t.COERCEPLAIN]}(?:$|[^\\d])`);
createToken('COERCEFULL', src[t.COERCEPLAIN] + `(?:${src[t.PRERELEASE]})?` + `(?:${src[t.BUILD]})?` + `(?:$|[^\\d])`);
createToken('COERCERTL', src[t.COERCE], true);
createToken('COERCERTLFULL', src[t.COERCEFULL], true);
// Tilde ranges.
// Meaning is "reasonably at or greater than"
createToken('LONETILDE', '(?:~>?)');
createToken('TILDETRIM', `(\\s*)${src[t.LONETILDE]}\\s+`, true);
exports.tildeTrimReplace = '$1~';
createToken('TILDE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);
createToken('TILDELOOSE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);
// Caret ranges.
// Meaning is "at least and backwards compatible with"
createToken('LONECARET', '(?:\\^)');
createToken('CARETTRIM', `(\\s*)${src[t.LONECARET]}\\s+`, true);
exports.caretTrimReplace = '$1^';
createToken('CARET', `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);
createToken('CARETLOOSE', `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);
// A simple gt/lt/eq thing, or just "" to indicate "any version"
createToken('COMPARATORLOOSE', `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`);
createToken('COMPARATOR', `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`);
// An expression to strip any whitespace between the gtlt and the thing
// it modifies, so that `> 1.2.3` ==> `>1.2.3`
createToken('COMPARATORTRIM', `(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);
exports.comparatorTrimReplace = '$1$2$3';
// Something like `1.2.3 - 1.2.4`
// Note that these all use the loose form, because they'll be
// checked against either the strict or loose comparator form
// later.
createToken('HYPHENRANGE', `^\\s*(${src[t.XRANGEPLAIN]})` + `\\s+-\\s+` + `(${src[t.XRANGEPLAIN]})` + `\\s*$`);
createToken('HYPHENRANGELOOSE', `^\\s*(${src[t.XRANGEPLAINLOOSE]})` + `\\s+-\\s+` + `(${src[t.XRANGEPLAINLOOSE]})` + `\\s*$`);
// Star ranges basically just allow anything at all.
createToken('STAR', '(<|>)?=?\\s*\\*');
// >=0.0.0 is like a star
createToken('GTE0', '^\\s*>=\\s*0\\.0\\.0\\s*$');
createToken('GTE0PRE', '^\\s*>=\\s*0\\.0\\.0-0\\s*$');
}),
"[project]/node_modules/semver/internal/parse-options.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// parse out just the options we care about
const looseOption = Object.freeze({
    loose: true
});
const emptyOpts = Object.freeze({});
const parseOptions = (options)=>{
    if (!options) {
        return emptyOpts;
    }
    if (typeof options !== 'object') {
        return looseOption;
    }
    return options;
};
module.exports = parseOptions;
}),
"[project]/node_modules/semver/internal/identifiers.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const numeric = /^[0-9]+$/;
const compareIdentifiers = (a, b)=>{
    if (typeof a === 'number' && typeof b === 'number') {
        return a === b ? 0 : a < b ? -1 : 1;
    }
    const anum = numeric.test(a);
    const bnum = numeric.test(b);
    if (anum && bnum) {
        a = +a;
        b = +b;
    }
    return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
};
const rcompareIdentifiers = (a, b)=>compareIdentifiers(b, a);
module.exports = {
    compareIdentifiers,
    rcompareIdentifiers
};
}),
"[project]/node_modules/semver/classes/semver.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const debug = __turbopack_context__.r("[project]/node_modules/semver/internal/debug.js [app-client] (ecmascript)");
const { MAX_LENGTH, MAX_SAFE_INTEGER } = __turbopack_context__.r("[project]/node_modules/semver/internal/constants.js [app-client] (ecmascript)");
const { safeRe: re, t } = __turbopack_context__.r("[project]/node_modules/semver/internal/re.js [app-client] (ecmascript)");
const parseOptions = __turbopack_context__.r("[project]/node_modules/semver/internal/parse-options.js [app-client] (ecmascript)");
const { compareIdentifiers } = __turbopack_context__.r("[project]/node_modules/semver/internal/identifiers.js [app-client] (ecmascript)");
class SemVer {
    constructor(version, options){
        options = parseOptions(options);
        if (version instanceof SemVer) {
            if (version.loose === !!options.loose && version.includePrerelease === !!options.includePrerelease) {
                return version;
            } else {
                version = version.version;
            }
        } else if (typeof version !== 'string') {
            throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version}".`);
        }
        if (version.length > MAX_LENGTH) {
            throw new TypeError(`version is longer than ${MAX_LENGTH} characters`);
        }
        debug('SemVer', version, options);
        this.options = options;
        this.loose = !!options.loose;
        // this isn't actually relevant for versions, but keep it so that we
        // don't run into trouble passing this.options around.
        this.includePrerelease = !!options.includePrerelease;
        const m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);
        if (!m) {
            throw new TypeError(`Invalid Version: ${version}`);
        }
        this.raw = version;
        // these are actually numbers
        this.major = +m[1];
        this.minor = +m[2];
        this.patch = +m[3];
        if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
            throw new TypeError('Invalid major version');
        }
        if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
            throw new TypeError('Invalid minor version');
        }
        if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
            throw new TypeError('Invalid patch version');
        }
        // numberify any prerelease numeric ids
        if (!m[4]) {
            this.prerelease = [];
        } else {
            this.prerelease = m[4].split('.').map((id)=>{
                if (/^[0-9]+$/.test(id)) {
                    const num = +id;
                    if (num >= 0 && num < MAX_SAFE_INTEGER) {
                        return num;
                    }
                }
                return id;
            });
        }
        this.build = m[5] ? m[5].split('.') : [];
        this.format();
    }
    format() {
        this.version = `${this.major}.${this.minor}.${this.patch}`;
        if (this.prerelease.length) {
            this.version += `-${this.prerelease.join('.')}`;
        }
        return this.version;
    }
    toString() {
        return this.version;
    }
    compare(other) {
        debug('SemVer.compare', this.version, this.options, other);
        if (!(other instanceof SemVer)) {
            if (typeof other === 'string' && other === this.version) {
                return 0;
            }
            other = new SemVer(other, this.options);
        }
        if (other.version === this.version) {
            return 0;
        }
        return this.compareMain(other) || this.comparePre(other);
    }
    compareMain(other) {
        if (!(other instanceof SemVer)) {
            other = new SemVer(other, this.options);
        }
        if (this.major < other.major) {
            return -1;
        }
        if (this.major > other.major) {
            return 1;
        }
        if (this.minor < other.minor) {
            return -1;
        }
        if (this.minor > other.minor) {
            return 1;
        }
        if (this.patch < other.patch) {
            return -1;
        }
        if (this.patch > other.patch) {
            return 1;
        }
        return 0;
    }
    comparePre(other) {
        if (!(other instanceof SemVer)) {
            other = new SemVer(other, this.options);
        }
        // NOT having a prerelease is > having one
        if (this.prerelease.length && !other.prerelease.length) {
            return -1;
        } else if (!this.prerelease.length && other.prerelease.length) {
            return 1;
        } else if (!this.prerelease.length && !other.prerelease.length) {
            return 0;
        }
        let i = 0;
        do {
            const a = this.prerelease[i];
            const b = other.prerelease[i];
            debug('prerelease compare', i, a, b);
            if (a === undefined && b === undefined) {
                return 0;
            } else if (b === undefined) {
                return 1;
            } else if (a === undefined) {
                return -1;
            } else if (a === b) {
                continue;
            } else {
                return compareIdentifiers(a, b);
            }
        }while (++i)
    }
    compareBuild(other) {
        if (!(other instanceof SemVer)) {
            other = new SemVer(other, this.options);
        }
        let i = 0;
        do {
            const a = this.build[i];
            const b = other.build[i];
            debug('build compare', i, a, b);
            if (a === undefined && b === undefined) {
                return 0;
            } else if (b === undefined) {
                return 1;
            } else if (a === undefined) {
                return -1;
            } else if (a === b) {
                continue;
            } else {
                return compareIdentifiers(a, b);
            }
        }while (++i)
    }
    // preminor will bump the version up to the next minor release, and immediately
    // down to pre-release. premajor and prepatch work the same way.
    inc(release, identifier, identifierBase) {
        if (release.startsWith('pre')) {
            if (!identifier && identifierBase === false) {
                throw new Error('invalid increment argument: identifier is empty');
            }
            // Avoid an invalid semver results
            if (identifier) {
                const match = `-${identifier}`.match(this.options.loose ? re[t.PRERELEASELOOSE] : re[t.PRERELEASE]);
                if (!match || match[1] !== identifier) {
                    throw new Error(`invalid identifier: ${identifier}`);
                }
            }
        }
        switch(release){
            case 'premajor':
                this.prerelease.length = 0;
                this.patch = 0;
                this.minor = 0;
                this.major++;
                this.inc('pre', identifier, identifierBase);
                break;
            case 'preminor':
                this.prerelease.length = 0;
                this.patch = 0;
                this.minor++;
                this.inc('pre', identifier, identifierBase);
                break;
            case 'prepatch':
                // If this is already a prerelease, it will bump to the next version
                // drop any prereleases that might already exist, since they are not
                // relevant at this point.
                this.prerelease.length = 0;
                this.inc('patch', identifier, identifierBase);
                this.inc('pre', identifier, identifierBase);
                break;
            // If the input is a non-prerelease version, this acts the same as
            // prepatch.
            case 'prerelease':
                if (this.prerelease.length === 0) {
                    this.inc('patch', identifier, identifierBase);
                }
                this.inc('pre', identifier, identifierBase);
                break;
            case 'release':
                if (this.prerelease.length === 0) {
                    throw new Error(`version ${this.raw} is not a prerelease`);
                }
                this.prerelease.length = 0;
                break;
            case 'major':
                // If this is a pre-major version, bump up to the same major version.
                // Otherwise increment major.
                // 1.0.0-5 bumps to 1.0.0
                // 1.1.0 bumps to 2.0.0
                if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
                    this.major++;
                }
                this.minor = 0;
                this.patch = 0;
                this.prerelease = [];
                break;
            case 'minor':
                // If this is a pre-minor version, bump up to the same minor version.
                // Otherwise increment minor.
                // 1.2.0-5 bumps to 1.2.0
                // 1.2.1 bumps to 1.3.0
                if (this.patch !== 0 || this.prerelease.length === 0) {
                    this.minor++;
                }
                this.patch = 0;
                this.prerelease = [];
                break;
            case 'patch':
                // If this is not a pre-release version, it will increment the patch.
                // If it is a pre-release it will bump up to the same patch version.
                // 1.2.0-5 patches to 1.2.0
                // 1.2.0 patches to 1.2.1
                if (this.prerelease.length === 0) {
                    this.patch++;
                }
                this.prerelease = [];
                break;
            // This probably shouldn't be used publicly.
            // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.
            case 'pre':
                {
                    const base = Number(identifierBase) ? 1 : 0;
                    if (this.prerelease.length === 0) {
                        this.prerelease = [
                            base
                        ];
                    } else {
                        let i = this.prerelease.length;
                        while(--i >= 0){
                            if (typeof this.prerelease[i] === 'number') {
                                this.prerelease[i]++;
                                i = -2;
                            }
                        }
                        if (i === -1) {
                            // didn't increment anything
                            if (identifier === this.prerelease.join('.') && identifierBase === false) {
                                throw new Error('invalid increment argument: identifier already exists');
                            }
                            this.prerelease.push(base);
                        }
                    }
                    if (identifier) {
                        // 1.2.0-beta.1 bumps to 1.2.0-beta.2,
                        // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0
                        let prerelease = [
                            identifier,
                            base
                        ];
                        if (identifierBase === false) {
                            prerelease = [
                                identifier
                            ];
                        }
                        if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
                            if (isNaN(this.prerelease[1])) {
                                this.prerelease = prerelease;
                            }
                        } else {
                            this.prerelease = prerelease;
                        }
                    }
                    break;
                }
            default:
                throw new Error(`invalid increment argument: ${release}`);
        }
        this.raw = this.format();
        if (this.build.length) {
            this.raw += `+${this.build.join('.')}`;
        }
        return this;
    }
}
module.exports = SemVer;
}),
"[project]/node_modules/semver/functions/parse.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const SemVer = __turbopack_context__.r("[project]/node_modules/semver/classes/semver.js [app-client] (ecmascript)");
const parse = (version, options, throwErrors = false)=>{
    if (version instanceof SemVer) {
        return version;
    }
    try {
        return new SemVer(version, options);
    } catch (er) {
        if (!throwErrors) {
            return null;
        }
        throw er;
    }
};
module.exports = parse;
}),
"[project]/node_modules/semver/functions/coerce.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const SemVer = __turbopack_context__.r("[project]/node_modules/semver/classes/semver.js [app-client] (ecmascript)");
const parse = __turbopack_context__.r("[project]/node_modules/semver/functions/parse.js [app-client] (ecmascript)");
const { safeRe: re, t } = __turbopack_context__.r("[project]/node_modules/semver/internal/re.js [app-client] (ecmascript)");
const coerce = (version, options)=>{
    if (version instanceof SemVer) {
        return version;
    }
    if (typeof version === 'number') {
        version = String(version);
    }
    if (typeof version !== 'string') {
        return null;
    }
    options = options || {};
    let match = null;
    if (!options.rtl) {
        match = version.match(options.includePrerelease ? re[t.COERCEFULL] : re[t.COERCE]);
    } else {
        // Find the right-most coercible string that does not share
        // a terminus with a more left-ward coercible string.
        // Eg, '1.2.3.4' wants to coerce '2.3.4', not '3.4' or '4'
        // With includePrerelease option set, '1.2.3.4-rc' wants to coerce '2.3.4-rc', not '2.3.4'
        //
        // Walk through the string checking with a /g regexp
        // Manually set the index so as to pick up overlapping matches.
        // Stop when we get a match that ends at the string end, since no
        // coercible string can be more right-ward without the same terminus.
        const coerceRtlRegex = options.includePrerelease ? re[t.COERCERTLFULL] : re[t.COERCERTL];
        let next;
        while((next = coerceRtlRegex.exec(version)) && (!match || match.index + match[0].length !== version.length)){
            if (!match || next.index + next[0].length !== match.index + match[0].length) {
                match = next;
            }
            coerceRtlRegex.lastIndex = next.index + next[1].length + next[2].length;
        }
        // leave it in a clean state
        coerceRtlRegex.lastIndex = -1;
    }
    if (match === null) {
        return null;
    }
    const major = match[2];
    const minor = match[3] || '0';
    const patch = match[4] || '0';
    const prerelease = options.includePrerelease && match[5] ? `-${match[5]}` : '';
    const build = options.includePrerelease && match[6] ? `+${match[6]}` : '';
    return parse(`${major}.${minor}.${patch}${prerelease}${build}`, options);
};
module.exports = coerce;
}),
"[project]/node_modules/semver/functions/compare.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const SemVer = __turbopack_context__.r("[project]/node_modules/semver/classes/semver.js [app-client] (ecmascript)");
const compare = (a, b, loose)=>new SemVer(a, loose).compare(new SemVer(b, loose));
module.exports = compare;
}),
"[project]/node_modules/semver/functions/gte.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const compare = __turbopack_context__.r("[project]/node_modules/semver/functions/compare.js [app-client] (ecmascript)");
const gte = (a, b, loose)=>compare(a, b, loose) >= 0;
module.exports = gte;
}),
"[project]/node_modules/semver/internal/lrucache.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

class LRUCache {
    constructor(){
        this.max = 1000;
        this.map = new Map();
    }
    get(key) {
        const value = this.map.get(key);
        if (value === undefined) {
            return undefined;
        } else {
            // Remove the key from the map and add it to the end
            this.map.delete(key);
            this.map.set(key, value);
            return value;
        }
    }
    delete(key) {
        return this.map.delete(key);
    }
    set(key, value) {
        const deleted = this.delete(key);
        if (!deleted && value !== undefined) {
            // If cache is full, delete the least recently used item
            if (this.map.size >= this.max) {
                const firstKey = this.map.keys().next().value;
                this.delete(firstKey);
            }
            this.map.set(key, value);
        }
        return this;
    }
}
module.exports = LRUCache;
}),
"[project]/node_modules/semver/functions/eq.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const compare = __turbopack_context__.r("[project]/node_modules/semver/functions/compare.js [app-client] (ecmascript)");
const eq = (a, b, loose)=>compare(a, b, loose) === 0;
module.exports = eq;
}),
"[project]/node_modules/semver/functions/neq.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const compare = __turbopack_context__.r("[project]/node_modules/semver/functions/compare.js [app-client] (ecmascript)");
const neq = (a, b, loose)=>compare(a, b, loose) !== 0;
module.exports = neq;
}),
"[project]/node_modules/semver/functions/gt.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const compare = __turbopack_context__.r("[project]/node_modules/semver/functions/compare.js [app-client] (ecmascript)");
const gt = (a, b, loose)=>compare(a, b, loose) > 0;
module.exports = gt;
}),
"[project]/node_modules/semver/functions/lt.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const compare = __turbopack_context__.r("[project]/node_modules/semver/functions/compare.js [app-client] (ecmascript)");
const lt = (a, b, loose)=>compare(a, b, loose) < 0;
module.exports = lt;
}),
"[project]/node_modules/semver/functions/lte.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const compare = __turbopack_context__.r("[project]/node_modules/semver/functions/compare.js [app-client] (ecmascript)");
const lte = (a, b, loose)=>compare(a, b, loose) <= 0;
module.exports = lte;
}),
"[project]/node_modules/semver/functions/cmp.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const eq = __turbopack_context__.r("[project]/node_modules/semver/functions/eq.js [app-client] (ecmascript)");
const neq = __turbopack_context__.r("[project]/node_modules/semver/functions/neq.js [app-client] (ecmascript)");
const gt = __turbopack_context__.r("[project]/node_modules/semver/functions/gt.js [app-client] (ecmascript)");
const gte = __turbopack_context__.r("[project]/node_modules/semver/functions/gte.js [app-client] (ecmascript)");
const lt = __turbopack_context__.r("[project]/node_modules/semver/functions/lt.js [app-client] (ecmascript)");
const lte = __turbopack_context__.r("[project]/node_modules/semver/functions/lte.js [app-client] (ecmascript)");
const cmp = (a, op, b, loose)=>{
    switch(op){
        case '===':
            if (typeof a === 'object') {
                a = a.version;
            }
            if (typeof b === 'object') {
                b = b.version;
            }
            return a === b;
        case '!==':
            if (typeof a === 'object') {
                a = a.version;
            }
            if (typeof b === 'object') {
                b = b.version;
            }
            return a !== b;
        case '':
        case '=':
        case '==':
            return eq(a, b, loose);
        case '!=':
            return neq(a, b, loose);
        case '>':
            return gt(a, b, loose);
        case '>=':
            return gte(a, b, loose);
        case '<':
            return lt(a, b, loose);
        case '<=':
            return lte(a, b, loose);
        default:
            throw new TypeError(`Invalid operator: ${op}`);
    }
};
module.exports = cmp;
}),
"[project]/node_modules/semver/classes/comparator.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const ANY = Symbol('SemVer ANY');
// hoisted class for cyclic dependency
class Comparator {
    static get ANY() {
        return ANY;
    }
    constructor(comp, options){
        options = parseOptions(options);
        if (comp instanceof Comparator) {
            if (comp.loose === !!options.loose) {
                return comp;
            } else {
                comp = comp.value;
            }
        }
        comp = comp.trim().split(/\s+/).join(' ');
        debug('comparator', comp, options);
        this.options = options;
        this.loose = !!options.loose;
        this.parse(comp);
        if (this.semver === ANY) {
            this.value = '';
        } else {
            this.value = this.operator + this.semver.version;
        }
        debug('comp', this);
    }
    parse(comp) {
        const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
        const m = comp.match(r);
        if (!m) {
            throw new TypeError(`Invalid comparator: ${comp}`);
        }
        this.operator = m[1] !== undefined ? m[1] : '';
        if (this.operator === '=') {
            this.operator = '';
        }
        // if it literally is just '>' or '' then allow anything.
        if (!m[2]) {
            this.semver = ANY;
        } else {
            this.semver = new SemVer(m[2], this.options.loose);
        }
    }
    toString() {
        return this.value;
    }
    test(version) {
        debug('Comparator.test', version, this.options.loose);
        if (this.semver === ANY || version === ANY) {
            return true;
        }
        if (typeof version === 'string') {
            try {
                version = new SemVer(version, this.options);
            } catch (er) {
                return false;
            }
        }
        return cmp(version, this.operator, this.semver, this.options);
    }
    intersects(comp, options) {
        if (!(comp instanceof Comparator)) {
            throw new TypeError('a Comparator is required');
        }
        if (this.operator === '') {
            if (this.value === '') {
                return true;
            }
            return new Range(comp.value, options).test(this.value);
        } else if (comp.operator === '') {
            if (comp.value === '') {
                return true;
            }
            return new Range(this.value, options).test(comp.semver);
        }
        options = parseOptions(options);
        // Special cases where nothing can possibly be lower
        if (options.includePrerelease && (this.value === '<0.0.0-0' || comp.value === '<0.0.0-0')) {
            return false;
        }
        if (!options.includePrerelease && (this.value.startsWith('<0.0.0') || comp.value.startsWith('<0.0.0'))) {
            return false;
        }
        // Same direction increasing (> or >=)
        if (this.operator.startsWith('>') && comp.operator.startsWith('>')) {
            return true;
        }
        // Same direction decreasing (< or <=)
        if (this.operator.startsWith('<') && comp.operator.startsWith('<')) {
            return true;
        }
        // same SemVer and both sides are inclusive (<= or >=)
        if (this.semver.version === comp.semver.version && this.operator.includes('=') && comp.operator.includes('=')) {
            return true;
        }
        // opposite directions less than
        if (cmp(this.semver, '<', comp.semver, options) && this.operator.startsWith('>') && comp.operator.startsWith('<')) {
            return true;
        }
        // opposite directions greater than
        if (cmp(this.semver, '>', comp.semver, options) && this.operator.startsWith('<') && comp.operator.startsWith('>')) {
            return true;
        }
        return false;
    }
}
module.exports = Comparator;
const parseOptions = __turbopack_context__.r("[project]/node_modules/semver/internal/parse-options.js [app-client] (ecmascript)");
const { safeRe: re, t } = __turbopack_context__.r("[project]/node_modules/semver/internal/re.js [app-client] (ecmascript)");
const cmp = __turbopack_context__.r("[project]/node_modules/semver/functions/cmp.js [app-client] (ecmascript)");
const debug = __turbopack_context__.r("[project]/node_modules/semver/internal/debug.js [app-client] (ecmascript)");
const SemVer = __turbopack_context__.r("[project]/node_modules/semver/classes/semver.js [app-client] (ecmascript)");
const Range = __turbopack_context__.r("[project]/node_modules/semver/classes/range.js [app-client] (ecmascript)");
}),
"[project]/node_modules/semver/classes/range.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const SPACE_CHARACTERS = /\s+/g;
// hoisted class for cyclic dependency
class Range {
    constructor(range, options){
        options = parseOptions(options);
        if (range instanceof Range) {
            if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
                return range;
            } else {
                return new Range(range.raw, options);
            }
        }
        if (range instanceof Comparator) {
            // just put it in the set and return
            this.raw = range.value;
            this.set = [
                [
                    range
                ]
            ];
            this.formatted = undefined;
            return this;
        }
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        // First reduce all whitespace as much as possible so we do not have to rely
        // on potentially slow regexes like \s*. This is then stored and used for
        // future error messages as well.
        this.raw = range.trim().replace(SPACE_CHARACTERS, ' ');
        // First, split on ||
        this.set = this.raw.split('||')// map the range to a 2d array of comparators
        .map((r)=>this.parseRange(r.trim()))// throw out any comparator lists that are empty
        // this generally means that it was not a valid range, which is allowed
        // in loose mode, but will still throw if the WHOLE range is invalid.
        .filter((c)=>c.length);
        if (!this.set.length) {
            throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
        }
        // if we have any that are not the null set, throw out null sets.
        if (this.set.length > 1) {
            // keep the first one, in case they're all null sets
            const first = this.set[0];
            this.set = this.set.filter((c)=>!isNullSet(c[0]));
            if (this.set.length === 0) {
                this.set = [
                    first
                ];
            } else if (this.set.length > 1) {
                // if we have any that are *, then the range is just *
                for (const c of this.set){
                    if (c.length === 1 && isAny(c[0])) {
                        this.set = [
                            c
                        ];
                        break;
                    }
                }
            }
        }
        this.formatted = undefined;
    }
    get range() {
        if (this.formatted === undefined) {
            this.formatted = '';
            for(let i = 0; i < this.set.length; i++){
                if (i > 0) {
                    this.formatted += '||';
                }
                const comps = this.set[i];
                for(let k = 0; k < comps.length; k++){
                    if (k > 0) {
                        this.formatted += ' ';
                    }
                    this.formatted += comps[k].toString().trim();
                }
            }
        }
        return this.formatted;
    }
    format() {
        return this.range;
    }
    toString() {
        return this.range;
    }
    parseRange(range) {
        // memoize range parsing for performance.
        // this is a very hot path, and fully deterministic.
        const memoOpts = (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE);
        const memoKey = memoOpts + ':' + range;
        const cached = cache.get(memoKey);
        if (cached) {
            return cached;
        }
        const loose = this.options.loose;
        // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`
        const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
        range = range.replace(hr, hyphenReplace(this.options.includePrerelease));
        debug('hyphen replace', range);
        // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`
        range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
        debug('comparator trim', range);
        // `~ 1.2.3` => `~1.2.3`
        range = range.replace(re[t.TILDETRIM], tildeTrimReplace);
        debug('tilde trim', range);
        // `^ 1.2.3` => `^1.2.3`
        range = range.replace(re[t.CARETTRIM], caretTrimReplace);
        debug('caret trim', range);
        // At this point, the range is completely trimmed and
        // ready to be split into comparators.
        let rangeList = range.split(' ').map((comp)=>parseComparator(comp, this.options)).join(' ').split(/\s+/)// >=0.0.0 is equivalent to *
        .map((comp)=>replaceGTE0(comp, this.options));
        if (loose) {
            // in loose mode, throw out any that are not valid comparators
            rangeList = rangeList.filter((comp)=>{
                debug('loose invalid filter', comp, this.options);
                return !!comp.match(re[t.COMPARATORLOOSE]);
            });
        }
        debug('range list', rangeList);
        // if any comparators are the null set, then replace with JUST null set
        // if more than one comparator, remove any * comparators
        // also, don't include the same comparator more than once
        const rangeMap = new Map();
        const comparators = rangeList.map((comp)=>new Comparator(comp, this.options));
        for (const comp of comparators){
            if (isNullSet(comp)) {
                return [
                    comp
                ];
            }
            rangeMap.set(comp.value, comp);
        }
        if (rangeMap.size > 1 && rangeMap.has('')) {
            rangeMap.delete('');
        }
        const result = [
            ...rangeMap.values()
        ];
        cache.set(memoKey, result);
        return result;
    }
    intersects(range, options) {
        if (!(range instanceof Range)) {
            throw new TypeError('a Range is required');
        }
        return this.set.some((thisComparators)=>{
            return isSatisfiable(thisComparators, options) && range.set.some((rangeComparators)=>{
                return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator)=>{
                    return rangeComparators.every((rangeComparator)=>{
                        return thisComparator.intersects(rangeComparator, options);
                    });
                });
            });
        });
    }
    // if ANY of the sets match ALL of its comparators, then pass
    test(version) {
        if (!version) {
            return false;
        }
        if (typeof version === 'string') {
            try {
                version = new SemVer(version, this.options);
            } catch (er) {
                return false;
            }
        }
        for(let i = 0; i < this.set.length; i++){
            if (testSet(this.set[i], version, this.options)) {
                return true;
            }
        }
        return false;
    }
}
module.exports = Range;
const LRU = __turbopack_context__.r("[project]/node_modules/semver/internal/lrucache.js [app-client] (ecmascript)");
const cache = new LRU();
const parseOptions = __turbopack_context__.r("[project]/node_modules/semver/internal/parse-options.js [app-client] (ecmascript)");
const Comparator = __turbopack_context__.r("[project]/node_modules/semver/classes/comparator.js [app-client] (ecmascript)");
const debug = __turbopack_context__.r("[project]/node_modules/semver/internal/debug.js [app-client] (ecmascript)");
const SemVer = __turbopack_context__.r("[project]/node_modules/semver/classes/semver.js [app-client] (ecmascript)");
const { safeRe: re, t, comparatorTrimReplace, tildeTrimReplace, caretTrimReplace } = __turbopack_context__.r("[project]/node_modules/semver/internal/re.js [app-client] (ecmascript)");
const { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = __turbopack_context__.r("[project]/node_modules/semver/internal/constants.js [app-client] (ecmascript)");
const isNullSet = (c)=>c.value === '<0.0.0-0';
const isAny = (c)=>c.value === '';
// take a set of comparators and determine whether there
// exists a version which can satisfy it
const isSatisfiable = (comparators, options)=>{
    let result = true;
    const remainingComparators = comparators.slice();
    let testComparator = remainingComparators.pop();
    while(result && remainingComparators.length){
        result = remainingComparators.every((otherComparator)=>{
            return testComparator.intersects(otherComparator, options);
        });
        testComparator = remainingComparators.pop();
    }
    return result;
};
// comprised of xranges, tildes, stars, and gtlt's at this point.
// already replaced the hyphen ranges
// turn into a set of JUST comparators.
const parseComparator = (comp, options)=>{
    comp = comp.replace(re[t.BUILD], '');
    debug('comp', comp, options);
    comp = replaceCarets(comp, options);
    debug('caret', comp);
    comp = replaceTildes(comp, options);
    debug('tildes', comp);
    comp = replaceXRanges(comp, options);
    debug('xrange', comp);
    comp = replaceStars(comp, options);
    debug('stars', comp);
    return comp;
};
const isX = (id)=>!id || id.toLowerCase() === 'x' || id === '*';
// ~, ~> --> * (any, kinda silly)
// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0-0
// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0-0
// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0-0
// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0-0
// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0-0
// ~0.0.1 --> >=0.0.1 <0.1.0-0
const replaceTildes = (comp, options)=>{
    return comp.trim().split(/\s+/).map((c)=>replaceTilde(c, options)).join(' ');
};
const replaceTilde = (comp, options)=>{
    const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
    return comp.replace(r, (_, M, m, p, pr)=>{
        debug('tilde', comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) {
            ret = '';
        } else if (isX(m)) {
            ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
            // ~1.2 == >=1.2.0 <1.3.0-0
            ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;
        } else if (pr) {
            debug('replaceTilde pr', pr);
            ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
        } else {
            // ~1.2.3 == >=1.2.3 <1.3.0-0
            ret = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`;
        }
        debug('tilde return', ret);
        return ret;
    });
};
// ^ --> * (any, kinda silly)
// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0-0
// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0-0
// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0-0
// ^1.2.3 --> >=1.2.3 <2.0.0-0
// ^1.2.0 --> >=1.2.0 <2.0.0-0
// ^0.0.1 --> >=0.0.1 <0.0.2-0
// ^0.1.0 --> >=0.1.0 <0.2.0-0
const replaceCarets = (comp, options)=>{
    return comp.trim().split(/\s+/).map((c)=>replaceCaret(c, options)).join(' ');
};
const replaceCaret = (comp, options)=>{
    debug('caret', comp, options);
    const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];
    const z = options.includePrerelease ? '-0' : '';
    return comp.replace(r, (_, M, m, p, pr)=>{
        debug('caret', comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) {
            ret = '';
        } else if (isX(m)) {
            ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
            if (M === '0') {
                ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`;
            } else {
                ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`;
            }
        } else if (pr) {
            debug('replaceCaret pr', pr);
            if (M === '0') {
                if (m === '0') {
                    ret = `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0`;
                } else {
                    ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
                }
            } else {
                ret = `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`;
            }
        } else {
            debug('no pr');
            if (M === '0') {
                if (m === '0') {
                    ret = `>=${M}.${m}.${p}${z} <${M}.${m}.${+p + 1}-0`;
                } else {
                    ret = `>=${M}.${m}.${p}${z} <${M}.${+m + 1}.0-0`;
                }
            } else {
                ret = `>=${M}.${m}.${p} <${+M + 1}.0.0-0`;
            }
        }
        debug('caret return', ret);
        return ret;
    });
};
const replaceXRanges = (comp, options)=>{
    debug('replaceXRanges', comp, options);
    return comp.split(/\s+/).map((c)=>replaceXRange(c, options)).join(' ');
};
const replaceXRange = (comp, options)=>{
    comp = comp.trim();
    const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
    return comp.replace(r, (ret, gtlt, M, m, p, pr)=>{
        debug('xRange', comp, ret, gtlt, M, m, p, pr);
        const xM = isX(M);
        const xm = xM || isX(m);
        const xp = xm || isX(p);
        const anyX = xp;
        if (gtlt === '=' && anyX) {
            gtlt = '';
        }
        // if we're including prereleases in the match, then we need
        // to fix this to -0, the lowest possible prerelease value
        pr = options.includePrerelease ? '-0' : '';
        if (xM) {
            if (gtlt === '>' || gtlt === '<') {
                // nothing is allowed
                ret = '<0.0.0-0';
            } else {
                // nothing is forbidden
                ret = '*';
            }
        } else if (gtlt && anyX) {
            // we know patch is an x, because we have any x at all.
            // replace X with 0
            if (xm) {
                m = 0;
            }
            p = 0;
            if (gtlt === '>') {
                // >1 => >=2.0.0
                // >1.2 => >=1.3.0
                gtlt = '>=';
                if (xm) {
                    M = +M + 1;
                    m = 0;
                    p = 0;
                } else {
                    m = +m + 1;
                    p = 0;
                }
            } else if (gtlt === '<=') {
                // <=0.7.x is actually <0.8.0, since any 0.7.x should
                // pass.  Similarly, <=7.x is actually <8.0.0, etc.
                gtlt = '<';
                if (xm) {
                    M = +M + 1;
                } else {
                    m = +m + 1;
                }
            }
            if (gtlt === '<') {
                pr = '-0';
            }
            ret = `${gtlt + M}.${m}.${p}${pr}`;
        } else if (xm) {
            ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
        } else if (xp) {
            ret = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`;
        }
        debug('xRange return', ret);
        return ret;
    });
};
// Because * is AND-ed with everything else in the comparator,
// and '' means "any version", just remove the *s entirely.
const replaceStars = (comp, options)=>{
    debug('replaceStars', comp, options);
    // Looseness is ignored here.  star is always as loose as it gets!
    return comp.trim().replace(re[t.STAR], '');
};
const replaceGTE0 = (comp, options)=>{
    debug('replaceGTE0', comp, options);
    return comp.trim().replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], '');
};
// This function is passed to string.replace(re[t.HYPHENRANGE])
// M, m, patch, prerelease, build
// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5
// 1.2.3 - 3.4 => >=1.2.0 <3.5.0-0 Any 3.4.x will do
// 1.2 - 3.4 => >=1.2.0 <3.5.0-0
// TODO build?
const hyphenReplace = (incPr)=>($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr)=>{
        if (isX(fM)) {
            from = '';
        } else if (isX(fm)) {
            from = `>=${fM}.0.0${incPr ? '-0' : ''}`;
        } else if (isX(fp)) {
            from = `>=${fM}.${fm}.0${incPr ? '-0' : ''}`;
        } else if (fpr) {
            from = `>=${from}`;
        } else {
            from = `>=${from}${incPr ? '-0' : ''}`;
        }
        if (isX(tM)) {
            to = '';
        } else if (isX(tm)) {
            to = `<${+tM + 1}.0.0-0`;
        } else if (isX(tp)) {
            to = `<${tM}.${+tm + 1}.0-0`;
        } else if (tpr) {
            to = `<=${tM}.${tm}.${tp}-${tpr}`;
        } else if (incPr) {
            to = `<${tM}.${tm}.${+tp + 1}-0`;
        } else {
            to = `<=${to}`;
        }
        return `${from} ${to}`.trim();
    };
const testSet = (set, version, options)=>{
    for(let i = 0; i < set.length; i++){
        if (!set[i].test(version)) {
            return false;
        }
    }
    if (version.prerelease.length && !options.includePrerelease) {
        // Find the set of versions that are allowed to have prereleases
        // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0
        // That should allow `1.2.3-pr.2` to pass.
        // However, `1.2.4-alpha.notready` should NOT be allowed,
        // even though it's within the range set by the comparators.
        for(let i = 0; i < set.length; i++){
            debug(set[i].semver);
            if (set[i].semver === Comparator.ANY) {
                continue;
            }
            if (set[i].semver.prerelease.length > 0) {
                const allowed = set[i].semver;
                if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
                    return true;
                }
            }
        }
        // Version has a -pre, but it's not one of the ones we like.
        return false;
    }
    return true;
};
}),
"[project]/node_modules/semver/functions/satisfies.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const Range = __turbopack_context__.r("[project]/node_modules/semver/classes/range.js [app-client] (ecmascript)");
const satisfies = (version, range, options)=>{
    try {
        range = new Range(range, options);
    } catch (er) {
        return false;
    }
    return range.test(version);
};
module.exports = satisfies;
}),
"[project]/node_modules/sharp/package.json (json)", ((__turbopack_context__) => {

__turbopack_context__.v({"name":"sharp","description":"High performance Node.js image processing, the fastest module to resize JPEG, PNG, WebP, GIF, AVIF and TIFF images","version":"0.34.5","author":"Lovell Fuller <npm@lovell.info>","homepage":"https://sharp.pixelplumbing.com","contributors":["Pierre Inglebert <pierre.inglebert@gmail.com>","Jonathan Ong <jonathanrichardong@gmail.com>","Chanon Sajjamanochai <chanon.s@gmail.com>","Juliano Julio <julianojulio@gmail.com>","Daniel Gasienica <daniel@gasienica.ch>","Julian Walker <julian@fiftythree.com>","Amit Pitaru <pitaru.amit@gmail.com>","Brandon Aaron <hello.brandon@aaron.sh>","Andreas Lind <andreas@one.com>","Maurus Cuelenaere <mcuelenaere@gmail.com>","Linus Unnebck <linus@folkdatorn.se>","Victor Mateevitsi <mvictoras@gmail.com>","Alaric Holloway <alaric.holloway@gmail.com>","Bernhard K. Weisshuhn <bkw@codingforce.com>","Chris Riley <criley@primedia.com>","David Carley <dacarley@gmail.com>","John Tobin <john@limelightmobileinc.com>","Kenton Gray <kentongray@gmail.com>","Felix Bnemann <Felix.Buenemann@gmail.com>","Samy Al Zahrani <samyalzahrany@gmail.com>","Chintan Thakkar <lemnisk8@gmail.com>","F. Orlando Galashan <frulo@gmx.de>","Kleis Auke Wolthuizen <info@kleisauke.nl>","Matt Hirsch <mhirsch@media.mit.edu>","Matthias Thoemmes <thoemmes@gmail.com>","Patrick Paskaris <patrick@paskaris.gr>","Jrmy Lal <kapouer@melix.org>","Rahul Nanwani <r.nanwani@gmail.com>","Alice Monday <alice0meta@gmail.com>","Kristo Jorgenson <kristo.jorgenson@gmail.com>","YvesBos <yves_bos@outlook.com>","Guy Maliar <guy@tailorbrands.com>","Nicolas Coden <nicolas@ncoden.fr>","Matt Parrish <matt.r.parrish@gmail.com>","Marcel Bretschneider <marcel.bretschneider@gmail.com>","Matthew McEachen <matthew+github@mceachen.org>","Jarda Kotovec <jarda.kotesovec@gmail.com>","Kenric D'Souza <kenric.dsouza@gmail.com>","Oleh Aleinyk <oleg.aleynik@gmail.com>","Marcel Bretschneider <marcel.bretschneider@gmail.com>","Andrea Bianco <andrea.bianco@unibas.ch>","Rik Heywood <rik@rik.org>","Thomas Parisot <hi@oncletom.io>","Nathan Graves <nathanrgraves+github@gmail.com>","Tom Lokhorst <tom@lokhorst.eu>","Espen Hovlandsdal <espen@hovlandsdal.com>","Sylvain Dumont <sylvain.dumont35@gmail.com>","Alun Davies <alun.owain.davies@googlemail.com>","Aidan Hoolachan <ajhoolachan21@gmail.com>","Axel Eirola <axel.eirola@iki.fi>","Freezy <freezy@xbmc.org>","Daiz <taneli.vatanen@gmail.com>","Julian Aubourg <j@ubourg.net>","Keith Belovay <keith@picthrive.com>","Michael B. Klein <mbklein@gmail.com>","Jordan Prudhomme <jordan@raboland.fr>","Ilya Ovdin <iovdin@gmail.com>","Andargor <andargor@yahoo.com>","Paul Neave <paul.neave@gmail.com>","Brendan Kennedy <brenwken@gmail.com>","Brychan Bennett-Odlum <git@brychan.io>","Edward Silverton <e.silverton@gmail.com>","Roman Malieiev <aromaleev@gmail.com>","Tomas Szabo <tomas.szabo@deftomat.com>","Robert O'Rourke <robert@o-rourke.org>","Guillermo Alfonso Varela Choucio <guillevch@gmail.com>","Christian Flintrup <chr@gigahost.dk>","Manan Jadhav <manan@motionden.com>","Leon Radley <leon@radley.se>","alza54 <alza54@thiocod.in>","Jacob Smith <jacob@frende.me>","Michael Nutt <michael@nutt.im>","Brad Parham <baparham@gmail.com>","Taneli Vatanen <taneli.vatanen@gmail.com>","Joris Dugu <zaruike10@gmail.com>","Chris Banks <christopher.bradley.banks@gmail.com>","Ompal Singh <ompal.hitm09@gmail.com>","Brodan <christopher.hranj@gmail.com>","Ankur Parihar <ankur.github@gmail.com>","Brahim Ait elhaj <brahima@gmail.com>","Mart Jansink <m.jansink@gmail.com>","Lachlan Newman <lachnewman007@gmail.com>","Dennis Beatty <dennis@dcbeatty.com>","Ingvar Stepanyan <me@rreverser.com>","Don Denton <don@happycollision.com>"],"scripts":{"build":"node install/build.js","install":"node install/check.js || npm run build","clean":"rm -rf src/build/ .nyc_output/ coverage/ test/fixtures/output.*","test":"npm run lint && npm run test-unit","lint":"npm run lint-cpp && npm run lint-js && npm run lint-types","lint-cpp":"cpplint --quiet src/*.h src/*.cc","lint-js":"biome lint","lint-types":"tsd --files ./test/types/sharp.test-d.ts","test-leak":"./test/leak/leak.sh","test-unit":"node --experimental-test-coverage test/unit.mjs","package-from-local-build":"node npm/from-local-build.js","package-release-notes":"node npm/release-notes.js","docs-build":"node docs/build.mjs","docs-serve":"cd docs && npm start","docs-publish":"cd docs && npm run build && npx firebase-tools deploy --project pixelplumbing --only hosting:pixelplumbing-sharp"},"type":"commonjs","main":"lib/index.js","types":"lib/index.d.ts","files":["install","lib","src/*.{cc,h,gyp}"],"repository":{"type":"git","url":"git://github.com/lovell/sharp.git"},"keywords":["jpeg","png","webp","avif","tiff","gif","svg","jp2","dzi","image","resize","thumbnail","crop","embed","libvips","vips"],"dependencies":{"@img/colour":"^1.0.0","detect-libc":"^2.1.2","semver":"^7.7.3"},"optionalDependencies":{"@img/sharp-darwin-arm64":"0.34.5","@img/sharp-darwin-x64":"0.34.5","@img/sharp-libvips-darwin-arm64":"1.2.4","@img/sharp-libvips-darwin-x64":"1.2.4","@img/sharp-libvips-linux-arm":"1.2.4","@img/sharp-libvips-linux-arm64":"1.2.4","@img/sharp-libvips-linux-ppc64":"1.2.4","@img/sharp-libvips-linux-riscv64":"1.2.4","@img/sharp-libvips-linux-s390x":"1.2.4","@img/sharp-libvips-linux-x64":"1.2.4","@img/sharp-libvips-linuxmusl-arm64":"1.2.4","@img/sharp-libvips-linuxmusl-x64":"1.2.4","@img/sharp-linux-arm":"0.34.5","@img/sharp-linux-arm64":"0.34.5","@img/sharp-linux-ppc64":"0.34.5","@img/sharp-linux-riscv64":"0.34.5","@img/sharp-linux-s390x":"0.34.5","@img/sharp-linux-x64":"0.34.5","@img/sharp-linuxmusl-arm64":"0.34.5","@img/sharp-linuxmusl-x64":"0.34.5","@img/sharp-wasm32":"0.34.5","@img/sharp-win32-arm64":"0.34.5","@img/sharp-win32-ia32":"0.34.5","@img/sharp-win32-x64":"0.34.5"},"devDependencies":{"@biomejs/biome":"^2.3.4","@cpplint/cli":"^0.1.0","@emnapi/runtime":"^1.7.0","@img/sharp-libvips-dev":"1.2.4","@img/sharp-libvips-dev-wasm32":"1.2.4","@img/sharp-libvips-win32-arm64":"1.2.4","@img/sharp-libvips-win32-ia32":"1.2.4","@img/sharp-libvips-win32-x64":"1.2.4","@types/node":"*","emnapi":"^1.7.0","exif-reader":"^2.0.2","extract-zip":"^2.0.1","icc":"^3.0.0","jsdoc-to-markdown":"^9.1.3","node-addon-api":"^8.5.0","node-gyp":"^11.5.0","tar-fs":"^3.1.1","tsd":"^0.33.0"},"license":"Apache-2.0","engines":{"node":"^18.17.0 || ^20.3.0 || >=21.0.0"},"config":{"libvips":">=8.17.3"},"funding":{"url":"https://opencollective.com/libvips"}});}),
"[project]/node_modules/sharp/lib/libvips.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

/*!
  Copyright 2013 Lovell Fuller and others.
  SPDX-License-Identifier: Apache-2.0
*/ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
const { spawnSync } = (()=>{
    const e = new Error("Cannot find module 'node:child_process': Unsupported external type Url for commonjs reference");
    e.code = 'MODULE_NOT_FOUND';
    throw e;
})();
const { createHash } = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/crypto-browserify/index.js [app-client] (ecmascript)");
const semverCoerce = __turbopack_context__.r("[project]/node_modules/semver/functions/coerce.js [app-client] (ecmascript)");
const semverGreaterThanOrEqualTo = __turbopack_context__.r("[project]/node_modules/semver/functions/gte.js [app-client] (ecmascript)");
const semverSatisfies = __turbopack_context__.r("[project]/node_modules/semver/functions/satisfies.js [app-client] (ecmascript)");
const detectLibc = __turbopack_context__.r("[project]/node_modules/detect-libc/lib/detect-libc.js [app-client] (ecmascript)");
const { config, engines, optionalDependencies } = __turbopack_context__.r("[project]/node_modules/sharp/package.json (json)");
/* node:coverage ignore next */ const minimumLibvipsVersionLabelled = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].env.npm_package_config_libvips || config.libvips;
const minimumLibvipsVersion = semverCoerce(minimumLibvipsVersionLabelled).version;
const prebuiltPlatforms = [
    'darwin-arm64',
    'darwin-x64',
    'linux-arm',
    'linux-arm64',
    'linux-ppc64',
    'linux-riscv64',
    'linux-s390x',
    'linux-x64',
    'linuxmusl-arm64',
    'linuxmusl-x64',
    'win32-arm64',
    'win32-ia32',
    'win32-x64'
];
const spawnSyncOptions = {
    encoding: 'utf8',
    shell: true
};
const log = (item)=>{
    if (item instanceof Error) {
        console.error(`sharp: Installation error: ${item.message}`);
    } else {
        console.log(`sharp: ${item}`);
    }
};
/* node:coverage ignore next */ const runtimeLibc = ()=>detectLibc.isNonGlibcLinuxSync() ? detectLibc.familySync() : '';
const runtimePlatformArch = ()=>`${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].platform}${runtimeLibc()}-${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].arch}`;
const buildPlatformArch = ()=>{
    /* node:coverage ignore next 3 */ if (isEmscripten()) {
        return 'wasm32';
    }
    const { npm_config_arch, npm_config_platform, npm_config_libc } = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].env;
    const libc = typeof npm_config_libc === 'string' ? npm_config_libc : runtimeLibc();
    return `${npm_config_platform || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].platform}${libc}-${npm_config_arch || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].arch}`;
};
const buildSharpLibvipsIncludeDir = ()=>{
    try {
        return (()=>{
            const e = new Error("Cannot find module 'unknown'");
            e.code = 'MODULE_NOT_FOUND';
            throw e;
        })();
    } catch  {
        /* node:coverage ignore next 5 */ try {
            return (()=>{
                const e = new Error("Cannot find module '@img/sharp-libvips-dev/include'");
                e.code = 'MODULE_NOT_FOUND';
                throw e;
            })();
        } catch  {}
    }
    return '';
};
const buildSharpLibvipsCPlusPlusDir = ()=>{
    /* node:coverage ignore next 4 */ try {
        return (()=>{
            const e = new Error("Cannot find module '@img/sharp-libvips-dev/cplusplus'");
            e.code = 'MODULE_NOT_FOUND';
            throw e;
        })();
    } catch  {}
    return '';
};
const buildSharpLibvipsLibDir = ()=>{
    try {
        return (()=>{
            const e = new Error("Cannot find module 'unknown'");
            e.code = 'MODULE_NOT_FOUND';
            throw e;
        })();
    } catch  {
        /* node:coverage ignore next 5 */ try {
            return (()=>{
                const e = new Error("Cannot find module 'unknown'");
                e.code = 'MODULE_NOT_FOUND';
                throw e;
            })();
        } catch  {}
    }
    return '';
};
/* node:coverage disable */ const isUnsupportedNodeRuntime = ()=>{
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].release?.name === 'node' && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].versions) {
        if (!semverSatisfies(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].versions.node, engines.node)) {
            return {
                found: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].versions.node,
                expected: engines.node
            };
        }
    }
};
const isEmscripten = ()=>{
    const { CC } = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].env;
    return Boolean(CC?.endsWith('/emcc'));
};
const isRosetta = ()=>{
    if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
    ;
    return false;
};
/* node:coverage enable */ const sha512 = (s)=>createHash('sha512').update(s).digest('hex');
const yarnLocator = ()=>{
    try {
        const identHash = sha512(`imgsharp-libvips-${buildPlatformArch()}`);
        const npmVersion = semverCoerce(optionalDependencies[`@img/sharp-libvips-${buildPlatformArch()}`], {
            includePrerelease: true
        }).version;
        return sha512(`${identHash}npm:${npmVersion}`).slice(0, 10);
    } catch  {}
    return '';
};
/* node:coverage disable */ const spawnRebuild = ()=>spawnSync(`node-gyp rebuild --directory=src ${isEmscripten() ? '--nodedir=emscripten' : ''}`, {
        ...spawnSyncOptions,
        stdio: 'inherit'
    }).status;
const globalLibvipsVersion = ()=>{
    if ("TURBOPACK compile-time truthy", 1) {
        const globalLibvipsVersion = spawnSync('pkg-config --modversion vips-cpp', {
            ...spawnSyncOptions,
            env: {
                ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].env,
                PKG_CONFIG_PATH: pkgConfigPath()
            }
        }).stdout;
        return (globalLibvipsVersion || '').trim();
    } else //TURBOPACK unreachable
    ;
};
/* node:coverage enable */ const pkgConfigPath = ()=>{
    if ("TURBOPACK compile-time truthy", 1) {
        /* node:coverage ignore next 4 */ const brewPkgConfigPath = spawnSync('which brew >/dev/null 2>&1 && brew environment --plain | grep PKG_CONFIG_LIBDIR | cut -d" " -f2', spawnSyncOptions).stdout || '';
        return [
            brewPkgConfigPath.trim(),
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].env.PKG_CONFIG_PATH,
            '/usr/local/lib/pkgconfig',
            '/usr/lib/pkgconfig',
            '/usr/local/libdata/pkgconfig',
            '/usr/libdata/pkgconfig'
        ].filter(Boolean).join(':');
    } else //TURBOPACK unreachable
    ;
};
const skipSearch = (status, reason, logger)=>{
    if (logger) {
        logger(`Detected ${reason}, skipping search for globally-installed libvips`);
    }
    return status;
};
const useGlobalLibvips = (logger)=>{
    if (Boolean(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].env.SHARP_IGNORE_GLOBAL_LIBVIPS) === true) {
        return skipSearch(false, 'SHARP_IGNORE_GLOBAL_LIBVIPS', logger);
    }
    if (Boolean(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].env.SHARP_FORCE_GLOBAL_LIBVIPS) === true) {
        return skipSearch(true, 'SHARP_FORCE_GLOBAL_LIBVIPS', logger);
    }
    /* node:coverage ignore next 3 */ if (isRosetta()) {
        return skipSearch(false, 'Rosetta', logger);
    }
    const globalVipsVersion = globalLibvipsVersion();
    /* node:coverage ignore next */ return !!globalVipsVersion && semverGreaterThanOrEqualTo(globalVipsVersion, minimumLibvipsVersion);
};
module.exports = {
    minimumLibvipsVersion,
    prebuiltPlatforms,
    buildPlatformArch,
    buildSharpLibvipsIncludeDir,
    buildSharpLibvipsCPlusPlusDir,
    buildSharpLibvipsLibDir,
    isUnsupportedNodeRuntime,
    runtimePlatformArch,
    log,
    yarnLocator,
    spawnRebuild,
    globalLibvipsVersion,
    pkgConfigPath,
    useGlobalLibvips
};
}),
"[project]/node_modules/sharp/lib/sharp.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

/*!
  Copyright 2013 Lovell Fuller and others.
  SPDX-License-Identifier: Apache-2.0
*/ // Inspects the runtime environment and exports the relevant sharp.node binary
const { familySync, versionSync } = __turbopack_context__.r("[project]/node_modules/detect-libc/lib/detect-libc.js [app-client] (ecmascript)");
const { runtimePlatformArch, isUnsupportedNodeRuntime, prebuiltPlatforms, minimumLibvipsVersion } = __turbopack_context__.r("[project]/node_modules/sharp/lib/libvips.js [app-client] (ecmascript)");
const runtimePlatform = runtimePlatformArch();
const paths = [
    `../src/build/Release/sharp-${runtimePlatform}.node`,
    '../src/build/Release/sharp-wasm32.node',
    `@img/sharp-${runtimePlatform}/sharp.node`,
    '@img/sharp-wasm32/sharp.node'
];
/* node:coverage disable */ let path, sharp;
const errors = [];
for (path of paths){
    try {
        sharp = __turbopack_context__.f({
            "@img/sharp-win32-x64/sharp.node": {
                id: ()=>(()=>{
                        throw new Error('could not resolve "' + path + '" into a module');
                    })(),
                module: ()=>(()=>{
                        throw new Error('could not resolve "' + path + '" into a module');
                    })()
            }
        })(path);
        break;
    } catch (err) {
        errors.push(err);
    }
}
if (sharp && path.startsWith('@img/sharp-linux-x64') && !sharp._isUsingX64V2()) {
    const err = new Error('Prebuilt binaries for linux-x64 require v2 microarchitecture');
    err.code = 'Unsupported CPU';
    errors.push(err);
    sharp = null;
}
if (sharp) {
    module.exports = sharp;
} else {
    const [isLinux, isMacOs, isWindows] = [
        'linux',
        'darwin',
        'win32'
    ].map((os)=>runtimePlatform.startsWith(os));
    const help = [
        `Could not load the "sharp" module using the ${runtimePlatform} runtime`
    ];
    errors.forEach((err)=>{
        if (err.code !== 'MODULE_NOT_FOUND') {
            help.push(`${err.code}: ${err.message}`);
        }
    });
    const messages = errors.map((err)=>err.message).join(' ');
    help.push('Possible solutions:');
    // Common error messages
    if (isUnsupportedNodeRuntime()) {
        const { found, expected } = isUnsupportedNodeRuntime();
        help.push('- Please upgrade Node.js:', `    Found ${found}`, `    Requires ${expected}`);
    } else if (prebuiltPlatforms.includes(runtimePlatform)) {
        const [os, cpu] = runtimePlatform.split('-');
        const libc = os.endsWith('musl') ? ' --libc=musl' : '';
        help.push('- Ensure optional dependencies can be installed:', '    npm install --include=optional sharp', '- Ensure your package manager supports multi-platform installation:', '    See https://sharp.pixelplumbing.com/install#cross-platform', '- Add platform-specific dependencies:', `    npm install --os=${os.replace('musl', '')}${libc} --cpu=${cpu} sharp`);
    } else {
        help.push(`- Manually install libvips >= ${minimumLibvipsVersion}`, '- Add experimental WebAssembly-based dependencies:', '    npm install --cpu=wasm32 sharp', '    npm install @img/sharp-wasm32');
    }
    if (isLinux && /(symbol not found|CXXABI_)/i.test(messages)) {
        try {
            const { config } = (()=>{
                const e = new Error("Cannot find module 'unknown'");
                e.code = 'MODULE_NOT_FOUND';
                throw e;
            })();
            const libcFound = `${familySync()} ${versionSync()}`;
            const libcRequires = `${config.musl ? 'musl' : 'glibc'} ${config.musl || config.glibc}`;
            help.push('- Update your OS:', `    Found ${libcFound}`, `    Requires ${libcRequires}`);
        } catch (_errEngines) {}
    }
    if (isLinux && /\/snap\/core[0-9]{2}/.test(messages)) {
        help.push('- Remove the Node.js Snap, which does not support native modules', '    snap remove node');
    }
    if (isMacOs && /Incompatible library version/.test(messages)) {
        help.push('- Update Homebrew:', '    brew update && brew upgrade vips');
    }
    if (errors.some((err)=>err.code === 'ERR_DLOPEN_DISABLED')) {
        help.push('- Run Node.js without using the --no-addons flag');
    }
    // Link to installation docs
    if (isWindows && /The specified procedure could not be found/.test(messages)) {
        help.push('- Using the canvas package on Windows?', '    See https://sharp.pixelplumbing.com/install#canvas-and-windows', '- Check for outdated versions of sharp in the dependency tree:', '    npm ls sharp');
    }
    help.push('- Consult the installation documentation:', '    See https://sharp.pixelplumbing.com/install');
    throw new Error(help.join('\n'));
}
}),
"[project]/node_modules/sharp/lib/constructor.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

/*!
  Copyright 2013 Lovell Fuller and others.
  SPDX-License-Identifier: Apache-2.0
*/ const util = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/util/util.js [app-client] (ecmascript)");
const stream = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/stream-browserify/index.js [app-client] (ecmascript)");
const is = __turbopack_context__.r("[project]/node_modules/sharp/lib/is.js [app-client] (ecmascript)");
__turbopack_context__.r("[project]/node_modules/sharp/lib/sharp.js [app-client] (ecmascript)");
// Use NODE_DEBUG=sharp to enable libvips warnings
const debuglog = util.debuglog('sharp');
const queueListener = (queueLength)=>{
    Sharp.queue.emit('change', queueLength);
};
/**
 * Constructor factory to create an instance of `sharp`, to which further methods are chained.
 *
 * JPEG, PNG, WebP, GIF, AVIF or TIFF format image data can be streamed out from this object.
 * When using Stream based output, derived attributes are available from the `info` event.
 *
 * Non-critical problems encountered during processing are emitted as `warning` events.
 *
 * Implements the [stream.Duplex](http://nodejs.org/api/stream.html#stream_class_stream_duplex) class.
 *
 * When loading more than one page/frame of an animated image,
 * these are combined as a vertically-stacked "toilet roll" image
 * where the overall height is the `pageHeight` multiplied by the number of `pages`.
 *
 * @constructs Sharp
 *
 * @emits Sharp#info
 * @emits Sharp#warning
 *
 * @example
 * sharp('input.jpg')
 *   .resize(300, 200)
 *   .toFile('output.jpg', function(err) {
 *     // output.jpg is a 300 pixels wide and 200 pixels high image
 *     // containing a scaled and cropped version of input.jpg
 *   });
 *
 * @example
 * // Read image data from remote URL,
 * // resize to 300 pixels wide,
 * // emit an 'info' event with calculated dimensions
 * // and finally write image data to writableStream
 * const { body } = fetch('https://...');
 * const readableStream = Readable.fromWeb(body);
 * const transformer = sharp()
 *   .resize(300)
 *   .on('info', ({ height }) => {
 *     console.log(`Image height is ${height}`);
 *   });
 * readableStream.pipe(transformer).pipe(writableStream);
 *
 * @example
 * // Create a blank 300x200 PNG image of semi-translucent red pixels
 * sharp({
 *   create: {
 *     width: 300,
 *     height: 200,
 *     channels: 4,
 *     background: { r: 255, g: 0, b: 0, alpha: 0.5 }
 *   }
 * })
 * .png()
 * .toBuffer()
 * .then( ... );
 *
 * @example
 * // Convert an animated GIF to an animated WebP
 * await sharp('in.gif', { animated: true }).toFile('out.webp');
 *
 * @example
 * // Read a raw array of pixels and save it to a png
 * const input = Uint8Array.from([255, 255, 255, 0, 0, 0]); // or Uint8ClampedArray
 * const image = sharp(input, {
 *   // because the input does not contain its dimensions or how many channels it has
 *   // we need to specify it in the constructor options
 *   raw: {
 *     width: 2,
 *     height: 1,
 *     channels: 3
 *   }
 * });
 * await image.toFile('my-two-pixels.png');
 *
 * @example
 * // Generate RGB Gaussian noise
 * await sharp({
 *   create: {
 *     width: 300,
 *     height: 200,
 *     channels: 3,
 *     noise: {
 *       type: 'gaussian',
 *       mean: 128,
 *       sigma: 30
 *     }
 *  }
 * }).toFile('noise.png');
 *
 * @example
 * // Generate an image from text
 * await sharp({
 *   text: {
 *     text: 'Hello, world!',
 *     width: 400, // max width
 *     height: 300 // max height
 *   }
 * }).toFile('text_bw.png');
 *
 * @example
 * // Generate an rgba image from text using pango markup and font
 * await sharp({
 *   text: {
 *     text: '<span foreground="red">Red!</span><span background="cyan">blue</span>',
 *     font: 'sans',
 *     rgba: true,
 *     dpi: 300
 *   }
 * }).toFile('text_rgba.png');
 *
 * @example
 * // Join four input images as a 2x2 grid with a 4 pixel gutter
 * const data = await sharp(
 *  [image1, image2, image3, image4],
 *  { join: { across: 2, shim: 4 } }
 * ).toBuffer();
 *
 * @example
 * // Generate a two-frame animated image from emoji
 * const images = ['', ''].map(text => ({
 *   text: { text, width: 64, height: 64, channels: 4, rgba: true }
 * }));
 * await sharp(images, { join: { animated: true } }).toFile('out.gif');
 *
 * @param {(Buffer|ArrayBuffer|Uint8Array|Uint8ClampedArray|Int8Array|Uint16Array|Int16Array|Uint32Array|Int32Array|Float32Array|Float64Array|string|Array)} [input] - if present, can be
 *  a Buffer / ArrayBuffer / Uint8Array / Uint8ClampedArray containing JPEG, PNG, WebP, AVIF, GIF, SVG or TIFF image data, or
 *  a TypedArray containing raw pixel image data, or
 *  a String containing the filesystem path to an JPEG, PNG, WebP, AVIF, GIF, SVG or TIFF image file.
 *  An array of inputs can be provided, and these will be joined together.
 *  JPEG, PNG, WebP, AVIF, GIF, SVG, TIFF or raw pixel image data can be streamed into the object when not present.
 * @param {Object} [options] - if present, is an Object with optional attributes.
 * @param {string} [options.failOn='warning'] - When to abort processing of invalid pixel data, one of (in order of sensitivity, least to most): 'none', 'truncated', 'error', 'warning'. Higher levels imply lower levels. Invalid metadata will always abort.
 * @param {number|boolean} [options.limitInputPixels=268402689] - Do not process input images where the number of pixels
 *  (width x height) exceeds this limit. Assumes image dimensions contained in the input metadata can be trusted.
 *  An integral Number of pixels, zero or false to remove limit, true to use default limit of 268402689 (0x3FFF x 0x3FFF).
 * @param {boolean} [options.unlimited=false] - Set this to `true` to remove safety features that help prevent memory exhaustion (JPEG, PNG, SVG, HEIF).
 * @param {boolean} [options.autoOrient=false] - Set this to `true` to rotate/flip the image to match EXIF `Orientation`, if any.
 * @param {boolean} [options.sequentialRead=true] - Set this to `false` to use random access rather than sequential read. Some operations will do this automatically.
 * @param {number} [options.density=72] - number representing the DPI for vector images in the range 1 to 100000.
 * @param {number} [options.ignoreIcc=false] - should the embedded ICC profile, if any, be ignored.
 * @param {number} [options.pages=1] - Number of pages to extract for multi-page input (GIF, WebP, TIFF), use -1 for all pages.
 * @param {number} [options.page=0] - Page number to start extracting from for multi-page input (GIF, WebP, TIFF), zero based.
 * @param {boolean} [options.animated=false] - Set to `true` to read all frames/pages of an animated image (GIF, WebP, TIFF), equivalent of setting `pages` to `-1`.
 * @param {Object} [options.raw] - describes raw pixel input image data. See `raw()` for pixel ordering.
 * @param {number} [options.raw.width] - integral number of pixels wide.
 * @param {number} [options.raw.height] - integral number of pixels high.
 * @param {number} [options.raw.channels] - integral number of channels, between 1 and 4.
 * @param {boolean} [options.raw.premultiplied] - specifies that the raw input has already been premultiplied, set to `true`
 *  to avoid sharp premultiplying the image. (optional, default `false`)
 * @param {number} [options.raw.pageHeight] - The pixel height of each page/frame for animated images, must be an integral factor of `raw.height`.
 * @param {Object} [options.create] - describes a new image to be created.
 * @param {number} [options.create.width] - integral number of pixels wide.
 * @param {number} [options.create.height] - integral number of pixels high.
 * @param {number} [options.create.channels] - integral number of channels, either 3 (RGB) or 4 (RGBA).
 * @param {string|Object} [options.create.background] - parsed by the [color](https://www.npmjs.org/package/color) module to extract values for red, green, blue and alpha.
 * @param {number} [options.create.pageHeight] - The pixel height of each page/frame for animated images, must be an integral factor of `create.height`.
 * @param {Object} [options.create.noise] - describes a noise to be created.
 * @param {string} [options.create.noise.type] - type of generated noise, currently only `gaussian` is supported.
 * @param {number} [options.create.noise.mean=128] - Mean value of pixels in the generated noise.
 * @param {number} [options.create.noise.sigma=30] - Standard deviation of pixel values in the generated noise.
 * @param {Object} [options.text] - describes a new text image to be created.
 * @param {string} [options.text.text] - text to render as a UTF-8 string. It can contain Pango markup, for example `<i>Le</i>Monde`.
 * @param {string} [options.text.font] - font name to render with.
 * @param {string} [options.text.fontfile] - absolute filesystem path to a font file that can be used by `font`.
 * @param {number} [options.text.width=0] - Integral number of pixels to word-wrap at. Lines of text wider than this will be broken at word boundaries.
 * @param {number} [options.text.height=0] - Maximum integral number of pixels high. When defined, `dpi` will be ignored and the text will automatically fit the pixel resolution defined by `width` and `height`. Will be ignored if `width` is not specified or set to 0.
 * @param {string} [options.text.align='left'] - Alignment style for multi-line text (`'left'`, `'centre'`, `'center'`, `'right'`).
 * @param {boolean} [options.text.justify=false] - set this to true to apply justification to the text.
 * @param {number} [options.text.dpi=72] - the resolution (size) at which to render the text. Does not take effect if `height` is specified.
 * @param {boolean} [options.text.rgba=false] - set this to true to enable RGBA output. This is useful for colour emoji rendering, or support for pango markup features like `<span foreground="red">Red!</span>`.
 * @param {number} [options.text.spacing=0] - text line height in points. Will use the font line height if none is specified.
 * @param {string} [options.text.wrap='word'] - word wrapping style when width is provided, one of: 'word', 'char', 'word-char' (prefer word, fallback to char) or 'none'.
 * @param {Object} [options.join] - describes how an array of input images should be joined.
 * @param {number} [options.join.across=1] - number of images to join horizontally.
 * @param {boolean} [options.join.animated=false] - set this to `true` to join the images as an animated image.
 * @param {number} [options.join.shim=0] - number of pixels to insert between joined images.
 * @param {string|Object} [options.join.background] - parsed by the [color](https://www.npmjs.org/package/color) module to extract values for red, green, blue and alpha.
 * @param {string} [options.join.halign='left'] - horizontal alignment style for images joined horizontally (`'left'`, `'centre'`, `'center'`, `'right'`).
 * @param {string} [options.join.valign='top'] - vertical alignment style for images joined vertically (`'top'`, `'centre'`, `'center'`, `'bottom'`).
 * @param {Object} [options.tiff] - Describes TIFF specific options.
 * @param {number} [options.tiff.subifd=-1] - Sub Image File Directory to extract for OME-TIFF, defaults to main image.
 * @param {Object} [options.svg] - Describes SVG specific options.
 * @param {string} [options.svg.stylesheet] - Custom CSS for SVG input, applied with a User Origin during the CSS cascade.
 * @param {boolean} [options.svg.highBitdepth=false] - Set to `true` to render SVG input at 32-bits per channel (128-bit) instead of 8-bits per channel (32-bit) RGBA.
 * @param {Object} [options.pdf] - Describes PDF specific options. Requires the use of a globally-installed libvips compiled with support for PDFium, Poppler, ImageMagick or GraphicsMagick.
 * @param {string|Object} [options.pdf.background] - Background colour to use when PDF is partially transparent. Parsed by the [color](https://www.npmjs.org/package/color) module to extract values for red, green, blue and alpha.
 * @param {Object} [options.openSlide] - Describes OpenSlide specific options. Requires the use of a globally-installed libvips compiled with support for OpenSlide.
 * @param {number} [options.openSlide.level=0] - Level to extract from a multi-level input, zero based.
 * @param {Object} [options.jp2] - Describes JPEG 2000 specific options. Requires the use of a globally-installed libvips compiled with support for OpenJPEG.
 * @param {boolean} [options.jp2.oneshot=false] - Set to `true` to decode tiled JPEG 2000 images in a single operation, improving compatibility.
 * @returns {Sharp}
 * @throws {Error} Invalid parameters
 */ const Sharp = function(input, options) {
    // biome-ignore lint/complexity/noArguments: constructor factory
    if (arguments.length === 1 && !is.defined(input)) {
        throw new Error('Invalid input');
    }
    if (!(this instanceof Sharp)) {
        return new Sharp(input, options);
    }
    stream.Duplex.call(this);
    this.options = {
        // resize options
        topOffsetPre: -1,
        leftOffsetPre: -1,
        widthPre: -1,
        heightPre: -1,
        topOffsetPost: -1,
        leftOffsetPost: -1,
        widthPost: -1,
        heightPost: -1,
        width: -1,
        height: -1,
        canvas: 'crop',
        position: 0,
        resizeBackground: [
            0,
            0,
            0,
            255
        ],
        angle: 0,
        rotationAngle: 0,
        rotationBackground: [
            0,
            0,
            0,
            255
        ],
        rotateBefore: false,
        orientBefore: false,
        flip: false,
        flop: false,
        extendTop: 0,
        extendBottom: 0,
        extendLeft: 0,
        extendRight: 0,
        extendBackground: [
            0,
            0,
            0,
            255
        ],
        extendWith: 'background',
        withoutEnlargement: false,
        withoutReduction: false,
        affineMatrix: [],
        affineBackground: [
            0,
            0,
            0,
            255
        ],
        affineIdx: 0,
        affineIdy: 0,
        affineOdx: 0,
        affineOdy: 0,
        affineInterpolator: this.constructor.interpolators.bilinear,
        kernel: 'lanczos3',
        fastShrinkOnLoad: true,
        // operations
        tint: [
            -1,
            0,
            0,
            0
        ],
        flatten: false,
        flattenBackground: [
            0,
            0,
            0
        ],
        unflatten: false,
        negate: false,
        negateAlpha: true,
        medianSize: 0,
        blurSigma: 0,
        precision: 'integer',
        minAmpl: 0.2,
        sharpenSigma: 0,
        sharpenM1: 1,
        sharpenM2: 2,
        sharpenX1: 2,
        sharpenY2: 10,
        sharpenY3: 20,
        threshold: 0,
        thresholdGrayscale: true,
        trimBackground: [],
        trimThreshold: -1,
        trimLineArt: false,
        dilateWidth: 0,
        erodeWidth: 0,
        gamma: 0,
        gammaOut: 0,
        greyscale: false,
        normalise: false,
        normaliseLower: 1,
        normaliseUpper: 99,
        claheWidth: 0,
        claheHeight: 0,
        claheMaxSlope: 3,
        brightness: 1,
        saturation: 1,
        hue: 0,
        lightness: 0,
        booleanBufferIn: null,
        booleanFileIn: '',
        joinChannelIn: [],
        extractChannel: -1,
        removeAlpha: false,
        ensureAlpha: -1,
        colourspace: 'srgb',
        colourspacePipeline: 'last',
        composite: [],
        // output
        fileOut: '',
        formatOut: 'input',
        streamOut: false,
        keepMetadata: 0,
        withMetadataOrientation: -1,
        withMetadataDensity: 0,
        withIccProfile: '',
        withExif: {},
        withExifMerge: true,
        withXmp: '',
        resolveWithObject: false,
        loop: -1,
        delay: [],
        // output format
        jpegQuality: 80,
        jpegProgressive: false,
        jpegChromaSubsampling: '4:2:0',
        jpegTrellisQuantisation: false,
        jpegOvershootDeringing: false,
        jpegOptimiseScans: false,
        jpegOptimiseCoding: true,
        jpegQuantisationTable: 0,
        pngProgressive: false,
        pngCompressionLevel: 6,
        pngAdaptiveFiltering: false,
        pngPalette: false,
        pngQuality: 100,
        pngEffort: 7,
        pngBitdepth: 8,
        pngDither: 1,
        jp2Quality: 80,
        jp2TileHeight: 512,
        jp2TileWidth: 512,
        jp2Lossless: false,
        jp2ChromaSubsampling: '4:4:4',
        webpQuality: 80,
        webpAlphaQuality: 100,
        webpLossless: false,
        webpNearLossless: false,
        webpSmartSubsample: false,
        webpSmartDeblock: false,
        webpPreset: 'default',
        webpEffort: 4,
        webpMinSize: false,
        webpMixed: false,
        gifBitdepth: 8,
        gifEffort: 7,
        gifDither: 1,
        gifInterFrameMaxError: 0,
        gifInterPaletteMaxError: 3,
        gifKeepDuplicateFrames: false,
        gifReuse: true,
        gifProgressive: false,
        tiffQuality: 80,
        tiffCompression: 'jpeg',
        tiffBigtiff: false,
        tiffPredictor: 'horizontal',
        tiffPyramid: false,
        tiffMiniswhite: false,
        tiffBitdepth: 8,
        tiffTile: false,
        tiffTileHeight: 256,
        tiffTileWidth: 256,
        tiffXres: 1.0,
        tiffYres: 1.0,
        tiffResolutionUnit: 'inch',
        heifQuality: 50,
        heifLossless: false,
        heifCompression: 'av1',
        heifEffort: 4,
        heifChromaSubsampling: '4:4:4',
        heifBitdepth: 8,
        jxlDistance: 1,
        jxlDecodingTier: 0,
        jxlEffort: 7,
        jxlLossless: false,
        rawDepth: 'uchar',
        tileSize: 256,
        tileOverlap: 0,
        tileContainer: 'fs',
        tileLayout: 'dz',
        tileFormat: 'last',
        tileDepth: 'last',
        tileAngle: 0,
        tileSkipBlanks: -1,
        tileBackground: [
            255,
            255,
            255,
            255
        ],
        tileCentre: false,
        tileId: 'https://example.com/iiif',
        tileBasename: '',
        timeoutSeconds: 0,
        linearA: [],
        linearB: [],
        pdfBackground: [
            255,
            255,
            255,
            255
        ],
        // Function to notify of libvips warnings
        debuglog: (warning)=>{
            this.emit('warning', warning);
            debuglog(warning);
        },
        // Function to notify of queue length changes
        queueListener
    };
    this.options.input = this._createInputDescriptor(input, options, {
        allowStream: true
    });
    return this;
};
Object.setPrototypeOf(Sharp.prototype, stream.Duplex.prototype);
Object.setPrototypeOf(Sharp, stream.Duplex);
/**
 * Take a "snapshot" of the Sharp instance, returning a new instance.
 * Cloned instances inherit the input of their parent instance.
 * This allows multiple output Streams and therefore multiple processing pipelines to share a single input Stream.
 *
 * @example
 * const pipeline = sharp().rotate();
 * pipeline.clone().resize(800, 600).pipe(firstWritableStream);
 * pipeline.clone().extract({ left: 20, top: 20, width: 100, height: 100 }).pipe(secondWritableStream);
 * readableStream.pipe(pipeline);
 * // firstWritableStream receives auto-rotated, resized readableStream
 * // secondWritableStream receives auto-rotated, extracted region of readableStream
 *
 * @example
 * // Create a pipeline that will download an image, resize it and format it to different files
 * // Using Promises to know when the pipeline is complete
 * const fs = require("fs");
 * const got = require("got");
 * const sharpStream = sharp({ failOn: 'none' });
 *
 * const promises = [];
 *
 * promises.push(
 *   sharpStream
 *     .clone()
 *     .jpeg({ quality: 100 })
 *     .toFile("originalFile.jpg")
 * );
 *
 * promises.push(
 *   sharpStream
 *     .clone()
 *     .resize({ width: 500 })
 *     .jpeg({ quality: 80 })
 *     .toFile("optimized-500.jpg")
 * );
 *
 * promises.push(
 *   sharpStream
 *     .clone()
 *     .resize({ width: 500 })
 *     .webp({ quality: 80 })
 *     .toFile("optimized-500.webp")
 * );
 *
 * // https://github.com/sindresorhus/got/blob/main/documentation/3-streams.md
 * got.stream("https://www.example.com/some-file.jpg").pipe(sharpStream);
 *
 * Promise.all(promises)
 *   .then(res => { console.log("Done!", res); })
 *   .catch(err => {
 *     console.error("Error processing files, let's clean it up", err);
 *     try {
 *       fs.unlinkSync("originalFile.jpg");
 *       fs.unlinkSync("optimized-500.jpg");
 *       fs.unlinkSync("optimized-500.webp");
 *     } catch (e) {}
 *   });
 *
 * @returns {Sharp}
 */ function clone() {
    // Clone existing options
    const clone = this.constructor.call();
    const { debuglog, queueListener, ...options } = this.options;
    clone.options = structuredClone(options);
    clone.options.debuglog = debuglog;
    clone.options.queueListener = queueListener;
    // Pass 'finish' event to clone for Stream-based input
    if (this._isStreamInput()) {
        this.on('finish', ()=>{
            // Clone inherits input data
            this._flattenBufferIn();
            clone.options.input.buffer = this.options.input.buffer;
            clone.emit('finish');
        });
    }
    return clone;
}
Object.assign(Sharp.prototype, {
    clone
});
/**
 * Export constructor.
 * @module Sharp
 * @private
 */ module.exports = Sharp;
}),
"[project]/node_modules/sharp/lib/input.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

/*!
  Copyright 2013 Lovell Fuller and others.
  SPDX-License-Identifier: Apache-2.0
*/ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/compiled/buffer/index.js [app-client] (ecmascript)");
const is = __turbopack_context__.r("[project]/node_modules/sharp/lib/is.js [app-client] (ecmascript)");
const sharp = __turbopack_context__.r("[project]/node_modules/sharp/lib/sharp.js [app-client] (ecmascript)");
/**
 * Justification alignment
 * @member
 * @private
 */ const align = {
    left: 'low',
    top: 'low',
    low: 'low',
    center: 'centre',
    centre: 'centre',
    right: 'high',
    bottom: 'high',
    high: 'high'
};
const inputStreamParameters = [
    // Limits and error handling
    'failOn',
    'limitInputPixels',
    'unlimited',
    // Format-generic
    'animated',
    'autoOrient',
    'density',
    'ignoreIcc',
    'page',
    'pages',
    'sequentialRead',
    // Format-specific
    'jp2',
    'openSlide',
    'pdf',
    'raw',
    'svg',
    'tiff',
    // Deprecated
    'failOnError',
    'openSlideLevel',
    'pdfBackground',
    'tiffSubifd'
];
/**
 * Extract input options, if any, from an object.
 * @private
 */ function _inputOptionsFromObject(obj) {
    const params = inputStreamParameters.filter((p)=>is.defined(obj[p])).map((p)=>[
            p,
            obj[p]
        ]);
    return params.length ? Object.fromEntries(params) : undefined;
}
/**
 * Create Object containing input and input-related options.
 * @private
 */ function _createInputDescriptor(input, inputOptions, containerOptions) {
    const inputDescriptor = {
        autoOrient: false,
        failOn: 'warning',
        limitInputPixels: 0x3FFF ** 2,
        ignoreIcc: false,
        unlimited: false,
        sequentialRead: true
    };
    if (is.string(input)) {
        // filesystem
        inputDescriptor.file = input;
    } else if (is.buffer(input)) {
        // Buffer
        if (input.length === 0) {
            throw Error('Input Buffer is empty');
        }
        inputDescriptor.buffer = input;
    } else if (is.arrayBuffer(input)) {
        if (input.byteLength === 0) {
            throw Error('Input bit Array is empty');
        }
        inputDescriptor.buffer = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(input, 0, input.byteLength);
    } else if (is.typedArray(input)) {
        if (input.length === 0) {
            throw Error('Input Bit Array is empty');
        }
        inputDescriptor.buffer = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(input.buffer, input.byteOffset, input.byteLength);
    } else if (is.plainObject(input) && !is.defined(inputOptions)) {
        // Plain Object descriptor, e.g. create
        inputOptions = input;
        if (_inputOptionsFromObject(inputOptions)) {
            // Stream with options
            inputDescriptor.buffer = [];
        }
    } else if (!is.defined(input) && !is.defined(inputOptions) && is.object(containerOptions) && containerOptions.allowStream) {
        // Stream without options
        inputDescriptor.buffer = [];
    } else if (Array.isArray(input)) {
        if (input.length > 1) {
            // Join images together
            if (!this.options.joining) {
                this.options.joining = true;
                this.options.join = input.map((i)=>this._createInputDescriptor(i));
            } else {
                throw new Error('Recursive join is unsupported');
            }
        } else {
            throw new Error('Expected at least two images to join');
        }
    } else {
        throw new Error(`Unsupported input '${input}' of type ${typeof input}${is.defined(inputOptions) ? ` when also providing options of type ${typeof inputOptions}` : ''}`);
    }
    if (is.object(inputOptions)) {
        // Deprecated: failOnError
        if (is.defined(inputOptions.failOnError)) {
            if (is.bool(inputOptions.failOnError)) {
                inputDescriptor.failOn = inputOptions.failOnError ? 'warning' : 'none';
            } else {
                throw is.invalidParameterError('failOnError', 'boolean', inputOptions.failOnError);
            }
        }
        // failOn
        if (is.defined(inputOptions.failOn)) {
            if (is.string(inputOptions.failOn) && is.inArray(inputOptions.failOn, [
                'none',
                'truncated',
                'error',
                'warning'
            ])) {
                inputDescriptor.failOn = inputOptions.failOn;
            } else {
                throw is.invalidParameterError('failOn', 'one of: none, truncated, error, warning', inputOptions.failOn);
            }
        }
        // autoOrient
        if (is.defined(inputOptions.autoOrient)) {
            if (is.bool(inputOptions.autoOrient)) {
                inputDescriptor.autoOrient = inputOptions.autoOrient;
            } else {
                throw is.invalidParameterError('autoOrient', 'boolean', inputOptions.autoOrient);
            }
        }
        // Density
        if (is.defined(inputOptions.density)) {
            if (is.inRange(inputOptions.density, 1, 100000)) {
                inputDescriptor.density = inputOptions.density;
            } else {
                throw is.invalidParameterError('density', 'number between 1 and 100000', inputOptions.density);
            }
        }
        // Ignore embeddded ICC profile
        if (is.defined(inputOptions.ignoreIcc)) {
            if (is.bool(inputOptions.ignoreIcc)) {
                inputDescriptor.ignoreIcc = inputOptions.ignoreIcc;
            } else {
                throw is.invalidParameterError('ignoreIcc', 'boolean', inputOptions.ignoreIcc);
            }
        }
        // limitInputPixels
        if (is.defined(inputOptions.limitInputPixels)) {
            if (is.bool(inputOptions.limitInputPixels)) {
                inputDescriptor.limitInputPixels = inputOptions.limitInputPixels ? 0x3FFF ** 2 : 0;
            } else if (is.integer(inputOptions.limitInputPixels) && is.inRange(inputOptions.limitInputPixels, 0, Number.MAX_SAFE_INTEGER)) {
                inputDescriptor.limitInputPixels = inputOptions.limitInputPixels;
            } else {
                throw is.invalidParameterError('limitInputPixels', 'positive integer', inputOptions.limitInputPixels);
            }
        }
        // unlimited
        if (is.defined(inputOptions.unlimited)) {
            if (is.bool(inputOptions.unlimited)) {
                inputDescriptor.unlimited = inputOptions.unlimited;
            } else {
                throw is.invalidParameterError('unlimited', 'boolean', inputOptions.unlimited);
            }
        }
        // sequentialRead
        if (is.defined(inputOptions.sequentialRead)) {
            if (is.bool(inputOptions.sequentialRead)) {
                inputDescriptor.sequentialRead = inputOptions.sequentialRead;
            } else {
                throw is.invalidParameterError('sequentialRead', 'boolean', inputOptions.sequentialRead);
            }
        }
        // Raw pixel input
        if (is.defined(inputOptions.raw)) {
            if (is.object(inputOptions.raw) && is.integer(inputOptions.raw.width) && inputOptions.raw.width > 0 && is.integer(inputOptions.raw.height) && inputOptions.raw.height > 0 && is.integer(inputOptions.raw.channels) && is.inRange(inputOptions.raw.channels, 1, 4)) {
                inputDescriptor.rawWidth = inputOptions.raw.width;
                inputDescriptor.rawHeight = inputOptions.raw.height;
                inputDescriptor.rawChannels = inputOptions.raw.channels;
                switch(input.constructor){
                    case Uint8Array:
                    case Uint8ClampedArray:
                        inputDescriptor.rawDepth = 'uchar';
                        break;
                    case Int8Array:
                        inputDescriptor.rawDepth = 'char';
                        break;
                    case Uint16Array:
                        inputDescriptor.rawDepth = 'ushort';
                        break;
                    case Int16Array:
                        inputDescriptor.rawDepth = 'short';
                        break;
                    case Uint32Array:
                        inputDescriptor.rawDepth = 'uint';
                        break;
                    case Int32Array:
                        inputDescriptor.rawDepth = 'int';
                        break;
                    case Float32Array:
                        inputDescriptor.rawDepth = 'float';
                        break;
                    case Float64Array:
                        inputDescriptor.rawDepth = 'double';
                        break;
                    default:
                        inputDescriptor.rawDepth = 'uchar';
                        break;
                }
            } else {
                throw new Error('Expected width, height and channels for raw pixel input');
            }
            inputDescriptor.rawPremultiplied = false;
            if (is.defined(inputOptions.raw.premultiplied)) {
                if (is.bool(inputOptions.raw.premultiplied)) {
                    inputDescriptor.rawPremultiplied = inputOptions.raw.premultiplied;
                } else {
                    throw is.invalidParameterError('raw.premultiplied', 'boolean', inputOptions.raw.premultiplied);
                }
            }
            inputDescriptor.rawPageHeight = 0;
            if (is.defined(inputOptions.raw.pageHeight)) {
                if (is.integer(inputOptions.raw.pageHeight) && inputOptions.raw.pageHeight > 0 && inputOptions.raw.pageHeight <= inputOptions.raw.height) {
                    if (inputOptions.raw.height % inputOptions.raw.pageHeight !== 0) {
                        throw new Error(`Expected raw.height ${inputOptions.raw.height} to be a multiple of raw.pageHeight ${inputOptions.raw.pageHeight}`);
                    }
                    inputDescriptor.rawPageHeight = inputOptions.raw.pageHeight;
                } else {
                    throw is.invalidParameterError('raw.pageHeight', 'positive integer', inputOptions.raw.pageHeight);
                }
            }
        }
        // Multi-page input (GIF, TIFF, PDF)
        if (is.defined(inputOptions.animated)) {
            if (is.bool(inputOptions.animated)) {
                inputDescriptor.pages = inputOptions.animated ? -1 : 1;
            } else {
                throw is.invalidParameterError('animated', 'boolean', inputOptions.animated);
            }
        }
        if (is.defined(inputOptions.pages)) {
            if (is.integer(inputOptions.pages) && is.inRange(inputOptions.pages, -1, 100000)) {
                inputDescriptor.pages = inputOptions.pages;
            } else {
                throw is.invalidParameterError('pages', 'integer between -1 and 100000', inputOptions.pages);
            }
        }
        if (is.defined(inputOptions.page)) {
            if (is.integer(inputOptions.page) && is.inRange(inputOptions.page, 0, 100000)) {
                inputDescriptor.page = inputOptions.page;
            } else {
                throw is.invalidParameterError('page', 'integer between 0 and 100000', inputOptions.page);
            }
        }
        // OpenSlide specific options
        if (is.object(inputOptions.openSlide) && is.defined(inputOptions.openSlide.level)) {
            if (is.integer(inputOptions.openSlide.level) && is.inRange(inputOptions.openSlide.level, 0, 256)) {
                inputDescriptor.openSlideLevel = inputOptions.openSlide.level;
            } else {
                throw is.invalidParameterError('openSlide.level', 'integer between 0 and 256', inputOptions.openSlide.level);
            }
        } else if (is.defined(inputOptions.level)) {
            // Deprecated
            if (is.integer(inputOptions.level) && is.inRange(inputOptions.level, 0, 256)) {
                inputDescriptor.openSlideLevel = inputOptions.level;
            } else {
                throw is.invalidParameterError('level', 'integer between 0 and 256', inputOptions.level);
            }
        }
        // TIFF specific options
        if (is.object(inputOptions.tiff) && is.defined(inputOptions.tiff.subifd)) {
            if (is.integer(inputOptions.tiff.subifd) && is.inRange(inputOptions.tiff.subifd, -1, 100000)) {
                inputDescriptor.tiffSubifd = inputOptions.tiff.subifd;
            } else {
                throw is.invalidParameterError('tiff.subifd', 'integer between -1 and 100000', inputOptions.tiff.subifd);
            }
        } else if (is.defined(inputOptions.subifd)) {
            // Deprecated
            if (is.integer(inputOptions.subifd) && is.inRange(inputOptions.subifd, -1, 100000)) {
                inputDescriptor.tiffSubifd = inputOptions.subifd;
            } else {
                throw is.invalidParameterError('subifd', 'integer between -1 and 100000', inputOptions.subifd);
            }
        }
        // SVG specific options
        if (is.object(inputOptions.svg)) {
            if (is.defined(inputOptions.svg.stylesheet)) {
                if (is.string(inputOptions.svg.stylesheet)) {
                    inputDescriptor.svgStylesheet = inputOptions.svg.stylesheet;
                } else {
                    throw is.invalidParameterError('svg.stylesheet', 'string', inputOptions.svg.stylesheet);
                }
            }
            if (is.defined(inputOptions.svg.highBitdepth)) {
                if (is.bool(inputOptions.svg.highBitdepth)) {
                    inputDescriptor.svgHighBitdepth = inputOptions.svg.highBitdepth;
                } else {
                    throw is.invalidParameterError('svg.highBitdepth', 'boolean', inputOptions.svg.highBitdepth);
                }
            }
        }
        // PDF specific options
        if (is.object(inputOptions.pdf) && is.defined(inputOptions.pdf.background)) {
            inputDescriptor.pdfBackground = this._getBackgroundColourOption(inputOptions.pdf.background);
        } else if (is.defined(inputOptions.pdfBackground)) {
            // Deprecated
            inputDescriptor.pdfBackground = this._getBackgroundColourOption(inputOptions.pdfBackground);
        }
        // JPEG 2000 specific options
        if (is.object(inputOptions.jp2) && is.defined(inputOptions.jp2.oneshot)) {
            if (is.bool(inputOptions.jp2.oneshot)) {
                inputDescriptor.jp2Oneshot = inputOptions.jp2.oneshot;
            } else {
                throw is.invalidParameterError('jp2.oneshot', 'boolean', inputOptions.jp2.oneshot);
            }
        }
        // Create new image
        if (is.defined(inputOptions.create)) {
            if (is.object(inputOptions.create) && is.integer(inputOptions.create.width) && inputOptions.create.width > 0 && is.integer(inputOptions.create.height) && inputOptions.create.height > 0 && is.integer(inputOptions.create.channels)) {
                inputDescriptor.createWidth = inputOptions.create.width;
                inputDescriptor.createHeight = inputOptions.create.height;
                inputDescriptor.createChannels = inputOptions.create.channels;
                inputDescriptor.createPageHeight = 0;
                if (is.defined(inputOptions.create.pageHeight)) {
                    if (is.integer(inputOptions.create.pageHeight) && inputOptions.create.pageHeight > 0 && inputOptions.create.pageHeight <= inputOptions.create.height) {
                        if (inputOptions.create.height % inputOptions.create.pageHeight !== 0) {
                            throw new Error(`Expected create.height ${inputOptions.create.height} to be a multiple of create.pageHeight ${inputOptions.create.pageHeight}`);
                        }
                        inputDescriptor.createPageHeight = inputOptions.create.pageHeight;
                    } else {
                        throw is.invalidParameterError('create.pageHeight', 'positive integer', inputOptions.create.pageHeight);
                    }
                }
                // Noise
                if (is.defined(inputOptions.create.noise)) {
                    if (!is.object(inputOptions.create.noise)) {
                        throw new Error('Expected noise to be an object');
                    }
                    if (inputOptions.create.noise.type !== 'gaussian') {
                        throw new Error('Only gaussian noise is supported at the moment');
                    }
                    inputDescriptor.createNoiseType = inputOptions.create.noise.type;
                    if (!is.inRange(inputOptions.create.channels, 1, 4)) {
                        throw is.invalidParameterError('create.channels', 'number between 1 and 4', inputOptions.create.channels);
                    }
                    inputDescriptor.createNoiseMean = 128;
                    if (is.defined(inputOptions.create.noise.mean)) {
                        if (is.number(inputOptions.create.noise.mean) && is.inRange(inputOptions.create.noise.mean, 0, 10000)) {
                            inputDescriptor.createNoiseMean = inputOptions.create.noise.mean;
                        } else {
                            throw is.invalidParameterError('create.noise.mean', 'number between 0 and 10000', inputOptions.create.noise.mean);
                        }
                    }
                    inputDescriptor.createNoiseSigma = 30;
                    if (is.defined(inputOptions.create.noise.sigma)) {
                        if (is.number(inputOptions.create.noise.sigma) && is.inRange(inputOptions.create.noise.sigma, 0, 10000)) {
                            inputDescriptor.createNoiseSigma = inputOptions.create.noise.sigma;
                        } else {
                            throw is.invalidParameterError('create.noise.sigma', 'number between 0 and 10000', inputOptions.create.noise.sigma);
                        }
                    }
                } else if (is.defined(inputOptions.create.background)) {
                    if (!is.inRange(inputOptions.create.channels, 3, 4)) {
                        throw is.invalidParameterError('create.channels', 'number between 3 and 4', inputOptions.create.channels);
                    }
                    inputDescriptor.createBackground = this._getBackgroundColourOption(inputOptions.create.background);
                } else {
                    throw new Error('Expected valid noise or background to create a new input image');
                }
                delete inputDescriptor.buffer;
            } else {
                throw new Error('Expected valid width, height and channels to create a new input image');
            }
        }
        // Create a new image with text
        if (is.defined(inputOptions.text)) {
            if (is.object(inputOptions.text) && is.string(inputOptions.text.text)) {
                inputDescriptor.textValue = inputOptions.text.text;
                if (is.defined(inputOptions.text.height) && is.defined(inputOptions.text.dpi)) {
                    throw new Error('Expected only one of dpi or height');
                }
                if (is.defined(inputOptions.text.font)) {
                    if (is.string(inputOptions.text.font)) {
                        inputDescriptor.textFont = inputOptions.text.font;
                    } else {
                        throw is.invalidParameterError('text.font', 'string', inputOptions.text.font);
                    }
                }
                if (is.defined(inputOptions.text.fontfile)) {
                    if (is.string(inputOptions.text.fontfile)) {
                        inputDescriptor.textFontfile = inputOptions.text.fontfile;
                    } else {
                        throw is.invalidParameterError('text.fontfile', 'string', inputOptions.text.fontfile);
                    }
                }
                if (is.defined(inputOptions.text.width)) {
                    if (is.integer(inputOptions.text.width) && inputOptions.text.width > 0) {
                        inputDescriptor.textWidth = inputOptions.text.width;
                    } else {
                        throw is.invalidParameterError('text.width', 'positive integer', inputOptions.text.width);
                    }
                }
                if (is.defined(inputOptions.text.height)) {
                    if (is.integer(inputOptions.text.height) && inputOptions.text.height > 0) {
                        inputDescriptor.textHeight = inputOptions.text.height;
                    } else {
                        throw is.invalidParameterError('text.height', 'positive integer', inputOptions.text.height);
                    }
                }
                if (is.defined(inputOptions.text.align)) {
                    if (is.string(inputOptions.text.align) && is.string(this.constructor.align[inputOptions.text.align])) {
                        inputDescriptor.textAlign = this.constructor.align[inputOptions.text.align];
                    } else {
                        throw is.invalidParameterError('text.align', 'valid alignment', inputOptions.text.align);
                    }
                }
                if (is.defined(inputOptions.text.justify)) {
                    if (is.bool(inputOptions.text.justify)) {
                        inputDescriptor.textJustify = inputOptions.text.justify;
                    } else {
                        throw is.invalidParameterError('text.justify', 'boolean', inputOptions.text.justify);
                    }
                }
                if (is.defined(inputOptions.text.dpi)) {
                    if (is.integer(inputOptions.text.dpi) && is.inRange(inputOptions.text.dpi, 1, 1000000)) {
                        inputDescriptor.textDpi = inputOptions.text.dpi;
                    } else {
                        throw is.invalidParameterError('text.dpi', 'integer between 1 and 1000000', inputOptions.text.dpi);
                    }
                }
                if (is.defined(inputOptions.text.rgba)) {
                    if (is.bool(inputOptions.text.rgba)) {
                        inputDescriptor.textRgba = inputOptions.text.rgba;
                    } else {
                        throw is.invalidParameterError('text.rgba', 'bool', inputOptions.text.rgba);
                    }
                }
                if (is.defined(inputOptions.text.spacing)) {
                    if (is.integer(inputOptions.text.spacing) && is.inRange(inputOptions.text.spacing, -1000000, 1000000)) {
                        inputDescriptor.textSpacing = inputOptions.text.spacing;
                    } else {
                        throw is.invalidParameterError('text.spacing', 'integer between -1000000 and 1000000', inputOptions.text.spacing);
                    }
                }
                if (is.defined(inputOptions.text.wrap)) {
                    if (is.string(inputOptions.text.wrap) && is.inArray(inputOptions.text.wrap, [
                        'word',
                        'char',
                        'word-char',
                        'none'
                    ])) {
                        inputDescriptor.textWrap = inputOptions.text.wrap;
                    } else {
                        throw is.invalidParameterError('text.wrap', 'one of: word, char, word-char, none', inputOptions.text.wrap);
                    }
                }
                delete inputDescriptor.buffer;
            } else {
                throw new Error('Expected a valid string to create an image with text.');
            }
        }
        // Join images together
        if (is.defined(inputOptions.join)) {
            if (is.defined(this.options.join)) {
                if (is.defined(inputOptions.join.animated)) {
                    if (is.bool(inputOptions.join.animated)) {
                        inputDescriptor.joinAnimated = inputOptions.join.animated;
                    } else {
                        throw is.invalidParameterError('join.animated', 'boolean', inputOptions.join.animated);
                    }
                }
                if (is.defined(inputOptions.join.across)) {
                    if (is.integer(inputOptions.join.across) && is.inRange(inputOptions.join.across, 1, 1000000)) {
                        inputDescriptor.joinAcross = inputOptions.join.across;
                    } else {
                        throw is.invalidParameterError('join.across', 'integer between 1 and 100000', inputOptions.join.across);
                    }
                }
                if (is.defined(inputOptions.join.shim)) {
                    if (is.integer(inputOptions.join.shim) && is.inRange(inputOptions.join.shim, 0, 1000000)) {
                        inputDescriptor.joinShim = inputOptions.join.shim;
                    } else {
                        throw is.invalidParameterError('join.shim', 'integer between 0 and 100000', inputOptions.join.shim);
                    }
                }
                if (is.defined(inputOptions.join.background)) {
                    inputDescriptor.joinBackground = this._getBackgroundColourOption(inputOptions.join.background);
                }
                if (is.defined(inputOptions.join.halign)) {
                    if (is.string(inputOptions.join.halign) && is.string(this.constructor.align[inputOptions.join.halign])) {
                        inputDescriptor.joinHalign = this.constructor.align[inputOptions.join.halign];
                    } else {
                        throw is.invalidParameterError('join.halign', 'valid alignment', inputOptions.join.halign);
                    }
                }
                if (is.defined(inputOptions.join.valign)) {
                    if (is.string(inputOptions.join.valign) && is.string(this.constructor.align[inputOptions.join.valign])) {
                        inputDescriptor.joinValign = this.constructor.align[inputOptions.join.valign];
                    } else {
                        throw is.invalidParameterError('join.valign', 'valid alignment', inputOptions.join.valign);
                    }
                }
            } else {
                throw new Error('Expected input to be an array of images to join');
            }
        }
    } else if (is.defined(inputOptions)) {
        throw new Error(`Invalid input options ${inputOptions}`);
    }
    return inputDescriptor;
}
/**
 * Handle incoming Buffer chunk on Writable Stream.
 * @private
 * @param {Buffer} chunk
 * @param {string} encoding - unused
 * @param {Function} callback
 */ function _write(chunk, _encoding, callback) {
    if (Array.isArray(this.options.input.buffer)) {
        if (is.buffer(chunk)) {
            if (this.options.input.buffer.length === 0) {
                this.on('finish', ()=>{
                    this.streamInFinished = true;
                });
            }
            this.options.input.buffer.push(chunk);
            callback();
        } else {
            callback(new Error('Non-Buffer data on Writable Stream'));
        }
    } else {
        callback(new Error('Unexpected data on Writable Stream'));
    }
}
/**
 * Flattens the array of chunks accumulated in input.buffer.
 * @private
 */ function _flattenBufferIn() {
    if (this._isStreamInput()) {
        this.options.input.buffer = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].concat(this.options.input.buffer);
    }
}
/**
 * Are we expecting Stream-based input?
 * @private
 * @returns {boolean}
 */ function _isStreamInput() {
    return Array.isArray(this.options.input.buffer);
}
/**
 * Fast access to (uncached) image metadata without decoding any compressed pixel data.
 *
 * This is read from the header of the input image.
 * It does not take into consideration any operations to be applied to the output image,
 * such as resize or rotate.
 *
 * Dimensions in the response will respect the `page` and `pages` properties of the
 * {@link /api-constructor/ constructor parameters}.
 *
 * A `Promise` is returned when `callback` is not provided.
 *
 * - `format`: Name of decoder used to decompress image data e.g. `jpeg`, `png`, `webp`, `gif`, `svg`
 * - `size`: Total size of image in bytes, for Stream and Buffer input only
 * - `width`: Number of pixels wide (EXIF orientation is not taken into consideration, see example below)
 * - `height`: Number of pixels high (EXIF orientation is not taken into consideration, see example below)
 * - `space`: Name of colour space interpretation e.g. `srgb`, `rgb`, `cmyk`, `lab`, `b-w` [...](https://www.libvips.org/API/current/enum.Interpretation.html)
 * - `channels`: Number of bands e.g. `3` for sRGB, `4` for CMYK
 * - `depth`: Name of pixel depth format e.g. `uchar`, `char`, `ushort`, `float` [...](https://www.libvips.org/API/current/enum.BandFormat.html)
 * - `density`: Number of pixels per inch (DPI), if present
 * - `chromaSubsampling`: String containing JPEG chroma subsampling, `4:2:0` or `4:4:4` for RGB, `4:2:0:4` or `4:4:4:4` for CMYK
 * - `isProgressive`: Boolean indicating whether the image is interlaced using a progressive scan
 * - `isPalette`: Boolean indicating whether the image is palette-based (GIF, PNG).
 * - `bitsPerSample`: Number of bits per sample for each channel (GIF, PNG, HEIF).
 * - `pages`: Number of pages/frames contained within the image, with support for TIFF, HEIF, PDF, animated GIF and animated WebP
 * - `pageHeight`: Number of pixels high each page in a multi-page image will be.
 * - `loop`: Number of times to loop an animated image, zero refers to a continuous loop.
 * - `delay`: Delay in ms between each page in an animated image, provided as an array of integers.
 * - `pagePrimary`: Number of the primary page in a HEIF image
 * - `levels`: Details of each level in a multi-level image provided as an array of objects, requires libvips compiled with support for OpenSlide
 * - `subifds`: Number of Sub Image File Directories in an OME-TIFF image
 * - `background`: Default background colour, if present, for PNG (bKGD) and GIF images
 * - `compression`: The encoder used to compress an HEIF file, `av1` (AVIF) or `hevc` (HEIC)
 * - `resolutionUnit`: The unit of resolution (density), either `inch` or `cm`, if present
 * - `hasProfile`: Boolean indicating the presence of an embedded ICC profile
 * - `hasAlpha`: Boolean indicating the presence of an alpha transparency channel
 * - `orientation`: Number value of the EXIF Orientation header, if present
 * - `exif`: Buffer containing raw EXIF data, if present
 * - `icc`: Buffer containing raw [ICC](https://www.npmjs.com/package/icc) profile data, if present
 * - `iptc`: Buffer containing raw IPTC data, if present
 * - `xmp`: Buffer containing raw XMP data, if present
 * - `xmpAsString`: String containing XMP data, if valid UTF-8.
 * - `tifftagPhotoshop`: Buffer containing raw TIFFTAG_PHOTOSHOP data, if present
 * - `formatMagick`: String containing format for images loaded via *magick
 * - `comments`: Array of keyword/text pairs representing PNG text blocks, if present.
 *
 * @example
 * const metadata = await sharp(input).metadata();
 *
 * @example
 * const image = sharp(inputJpg);
 * image
 *   .metadata()
 *   .then(function(metadata) {
 *     return image
 *       .resize(Math.round(metadata.width / 2))
 *       .webp()
 *       .toBuffer();
 *   })
 *   .then(function(data) {
 *     // data contains a WebP image half the width and height of the original JPEG
 *   });
 *
 * @example
 * // Get dimensions taking EXIF Orientation into account.
 * const { autoOrient } = await sharp(input).metadata();
 * const { width, height } = autoOrient;
 *
 * @param {Function} [callback] - called with the arguments `(err, metadata)`
 * @returns {Promise<Object>|Sharp}
 */ function metadata(callback) {
    const stack = Error();
    if (is.fn(callback)) {
        if (this._isStreamInput()) {
            this.on('finish', ()=>{
                this._flattenBufferIn();
                sharp.metadata(this.options, (err, metadata)=>{
                    if (err) {
                        callback(is.nativeError(err, stack));
                    } else {
                        callback(null, metadata);
                    }
                });
            });
        } else {
            sharp.metadata(this.options, (err, metadata)=>{
                if (err) {
                    callback(is.nativeError(err, stack));
                } else {
                    callback(null, metadata);
                }
            });
        }
        return this;
    } else {
        if (this._isStreamInput()) {
            return new Promise((resolve, reject)=>{
                const finished = ()=>{
                    this._flattenBufferIn();
                    sharp.metadata(this.options, (err, metadata)=>{
                        if (err) {
                            reject(is.nativeError(err, stack));
                        } else {
                            resolve(metadata);
                        }
                    });
                };
                if (this.writableFinished) {
                    finished();
                } else {
                    this.once('finish', finished);
                }
            });
        } else {
            return new Promise((resolve, reject)=>{
                sharp.metadata(this.options, (err, metadata)=>{
                    if (err) {
                        reject(is.nativeError(err, stack));
                    } else {
                        resolve(metadata);
                    }
                });
            });
        }
    }
}
/**
 * Access to pixel-derived image statistics for every channel in the image.
 * A `Promise` is returned when `callback` is not provided.
 *
 * - `channels`: Array of channel statistics for each channel in the image. Each channel statistic contains
 *     - `min` (minimum value in the channel)
 *     - `max` (maximum value in the channel)
 *     - `sum` (sum of all values in a channel)
 *     - `squaresSum` (sum of squared values in a channel)
 *     - `mean` (mean of the values in a channel)
 *     - `stdev` (standard deviation for the values in a channel)
 *     - `minX` (x-coordinate of one of the pixel where the minimum lies)
 *     - `minY` (y-coordinate of one of the pixel where the minimum lies)
 *     - `maxX` (x-coordinate of one of the pixel where the maximum lies)
 *     - `maxY` (y-coordinate of one of the pixel where the maximum lies)
 * - `isOpaque`: Is the image fully opaque? Will be `true` if the image has no alpha channel or if every pixel is fully opaque.
 * - `entropy`: Histogram-based estimation of greyscale entropy, discarding alpha channel if any.
 * - `sharpness`: Estimation of greyscale sharpness based on the standard deviation of a Laplacian convolution, discarding alpha channel if any.
 * - `dominant`: Object containing most dominant sRGB colour based on a 4096-bin 3D histogram.
 *
 * **Note**: Statistics are derived from the original input image. Any operations performed on the image must first be
 * written to a buffer in order to run `stats` on the result (see third example).
 *
 * @example
 * const image = sharp(inputJpg);
 * image
 *   .stats()
 *   .then(function(stats) {
 *      // stats contains the channel-wise statistics array and the isOpaque value
 *   });
 *
 * @example
 * const { entropy, sharpness, dominant } = await sharp(input).stats();
 * const { r, g, b } = dominant;
 *
 * @example
 * const image = sharp(input);
 * // store intermediate result
 * const part = await image.extract(region).toBuffer();
 * // create new instance to obtain statistics of extracted region
 * const stats = await sharp(part).stats();
 *
 * @param {Function} [callback] - called with the arguments `(err, stats)`
 * @returns {Promise<Object>}
 */ function stats(callback) {
    const stack = Error();
    if (is.fn(callback)) {
        if (this._isStreamInput()) {
            this.on('finish', ()=>{
                this._flattenBufferIn();
                sharp.stats(this.options, (err, stats)=>{
                    if (err) {
                        callback(is.nativeError(err, stack));
                    } else {
                        callback(null, stats);
                    }
                });
            });
        } else {
            sharp.stats(this.options, (err, stats)=>{
                if (err) {
                    callback(is.nativeError(err, stack));
                } else {
                    callback(null, stats);
                }
            });
        }
        return this;
    } else {
        if (this._isStreamInput()) {
            return new Promise((resolve, reject)=>{
                this.on('finish', function() {
                    this._flattenBufferIn();
                    sharp.stats(this.options, (err, stats)=>{
                        if (err) {
                            reject(is.nativeError(err, stack));
                        } else {
                            resolve(stats);
                        }
                    });
                });
            });
        } else {
            return new Promise((resolve, reject)=>{
                sharp.stats(this.options, (err, stats)=>{
                    if (err) {
                        reject(is.nativeError(err, stack));
                    } else {
                        resolve(stats);
                    }
                });
            });
        }
    }
}
/**
 * Decorate the Sharp prototype with input-related functions.
 * @module Sharp
 * @private
 */ module.exports = (Sharp)=>{
    Object.assign(Sharp.prototype, {
        // Private
        _inputOptionsFromObject,
        _createInputDescriptor,
        _write,
        _flattenBufferIn,
        _isStreamInput,
        // Public
        metadata,
        stats
    });
    // Class attributes
    Sharp.align = align;
};
}),
"[project]/node_modules/sharp/lib/resize.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

/*!
  Copyright 2013 Lovell Fuller and others.
  SPDX-License-Identifier: Apache-2.0
*/ const is = __turbopack_context__.r("[project]/node_modules/sharp/lib/is.js [app-client] (ecmascript)");
/**
 * Weighting to apply when using contain/cover fit.
 * @member
 * @private
 */ const gravity = {
    center: 0,
    centre: 0,
    north: 1,
    east: 2,
    south: 3,
    west: 4,
    northeast: 5,
    southeast: 6,
    southwest: 7,
    northwest: 8
};
/**
 * Position to apply when using contain/cover fit.
 * @member
 * @private
 */ const position = {
    top: 1,
    right: 2,
    bottom: 3,
    left: 4,
    'right top': 5,
    'right bottom': 6,
    'left bottom': 7,
    'left top': 8
};
/**
 * How to extend the image.
 * @member
 * @private
 */ const extendWith = {
    background: 'background',
    copy: 'copy',
    repeat: 'repeat',
    mirror: 'mirror'
};
/**
 * Strategies for automagic cover behaviour.
 * @member
 * @private
 */ const strategy = {
    entropy: 16,
    attention: 17
};
/**
 * Reduction kernels.
 * @member
 * @private
 */ const kernel = {
    nearest: 'nearest',
    linear: 'linear',
    cubic: 'cubic',
    mitchell: 'mitchell',
    lanczos2: 'lanczos2',
    lanczos3: 'lanczos3',
    mks2013: 'mks2013',
    mks2021: 'mks2021'
};
/**
 * Methods by which an image can be resized to fit the provided dimensions.
 * @member
 * @private
 */ const fit = {
    contain: 'contain',
    cover: 'cover',
    fill: 'fill',
    inside: 'inside',
    outside: 'outside'
};
/**
 * Map external fit property to internal canvas property.
 * @member
 * @private
 */ const mapFitToCanvas = {
    contain: 'embed',
    cover: 'crop',
    fill: 'ignore_aspect',
    inside: 'max',
    outside: 'min'
};
/**
 * @private
 */ function isRotationExpected(options) {
    return options.angle % 360 !== 0 || options.rotationAngle !== 0;
}
/**
 * @private
 */ function isResizeExpected(options) {
    return options.width !== -1 || options.height !== -1;
}
/**
 * Resize image to `width`, `height` or `width x height`.
 *
 * When both a `width` and `height` are provided, the possible methods by which the image should **fit** these are:
 * - `cover`: (default) Preserving aspect ratio, attempt to ensure the image covers both provided dimensions by cropping/clipping to fit.
 * - `contain`: Preserving aspect ratio, contain within both provided dimensions using "letterboxing" where necessary.
 * - `fill`: Ignore the aspect ratio of the input and stretch to both provided dimensions.
 * - `inside`: Preserving aspect ratio, resize the image to be as large as possible while ensuring its dimensions are less than or equal to both those specified.
 * - `outside`: Preserving aspect ratio, resize the image to be as small as possible while ensuring its dimensions are greater than or equal to both those specified.
 *
 * Some of these values are based on the [object-fit](https://developer.mozilla.org/en-US/docs/Web/CSS/object-fit) CSS property.
 *
 * <img alt="Examples of various values for the fit property when resizing" width="100%" style="aspect-ratio: 998/243" src="/api-resize-fit.svg">
 *
 * When using a **fit** of `cover` or `contain`, the default **position** is `centre`. Other options are:
 * - `sharp.position`: `top`, `right top`, `right`, `right bottom`, `bottom`, `left bottom`, `left`, `left top`.
 * - `sharp.gravity`: `north`, `northeast`, `east`, `southeast`, `south`, `southwest`, `west`, `northwest`, `center` or `centre`.
 * - `sharp.strategy`: `cover` only, dynamically crop using either the `entropy` or `attention` strategy.
 *
 * Some of these values are based on the [object-position](https://developer.mozilla.org/en-US/docs/Web/CSS/object-position) CSS property.
 *
 * The strategy-based approach initially resizes so one dimension is at its target length
 * then repeatedly ranks edge regions, discarding the edge with the lowest score based on the selected strategy.
 * - `entropy`: focus on the region with the highest [Shannon entropy](https://en.wikipedia.org/wiki/Entropy_%28information_theory%29).
 * - `attention`: focus on the region with the highest luminance frequency, colour saturation and presence of skin tones.
 *
 * Possible downsizing kernels are:
 * - `nearest`: Use [nearest neighbour interpolation](http://en.wikipedia.org/wiki/Nearest-neighbor_interpolation).
 * - `linear`: Use a [triangle filter](https://en.wikipedia.org/wiki/Triangular_function).
 * - `cubic`: Use a [Catmull-Rom spline](https://en.wikipedia.org/wiki/Centripetal_Catmull%E2%80%93Rom_spline).
 * - `mitchell`: Use a [Mitchell-Netravali spline](https://www.cs.utexas.edu/~fussell/courses/cs384g-fall2013/lectures/mitchell/Mitchell.pdf).
 * - `lanczos2`: Use a [Lanczos kernel](https://en.wikipedia.org/wiki/Lanczos_resampling#Lanczos_kernel) with `a=2`.
 * - `lanczos3`: Use a Lanczos kernel with `a=3` (the default).
 * - `mks2013`: Use a [Magic Kernel Sharp](https://johncostella.com/magic/mks.pdf) 2013 kernel, as adopted by Facebook.
 * - `mks2021`: Use a Magic Kernel Sharp 2021 kernel, with more accurate (reduced) sharpening than the 2013 version.
 *
 * When upsampling, these kernels map to `nearest`, `linear` and `cubic` interpolators.
 * Downsampling kernels without a matching upsampling interpolator map to `cubic`.
 *
 * Only one resize can occur per pipeline.
 * Previous calls to `resize` in the same pipeline will be ignored.
 *
 * @example
 * sharp(input)
 *   .resize({ width: 100 })
 *   .toBuffer()
 *   .then(data => {
 *     // 100 pixels wide, auto-scaled height
 *   });
 *
 * @example
 * sharp(input)
 *   .resize({ height: 100 })
 *   .toBuffer()
 *   .then(data => {
 *     // 100 pixels high, auto-scaled width
 *   });
 *
 * @example
 * sharp(input)
 *   .resize(200, 300, {
 *     kernel: sharp.kernel.nearest,
 *     fit: 'contain',
 *     position: 'right top',
 *     background: { r: 255, g: 255, b: 255, alpha: 0.5 }
 *   })
 *   .toFile('output.png')
 *   .then(() => {
 *     // output.png is a 200 pixels wide and 300 pixels high image
 *     // containing a nearest-neighbour scaled version
 *     // contained within the north-east corner of a semi-transparent white canvas
 *   });
 *
 * @example
 * const transformer = sharp()
 *   .resize({
 *     width: 200,
 *     height: 200,
 *     fit: sharp.fit.cover,
 *     position: sharp.strategy.entropy
 *   });
 * // Read image data from readableStream
 * // Write 200px square auto-cropped image data to writableStream
 * readableStream
 *   .pipe(transformer)
 *   .pipe(writableStream);
 *
 * @example
 * sharp(input)
 *   .resize(200, 200, {
 *     fit: sharp.fit.inside,
 *     withoutEnlargement: true
 *   })
 *   .toFormat('jpeg')
 *   .toBuffer()
 *   .then(function(outputBuffer) {
 *     // outputBuffer contains JPEG image data
 *     // no wider and no higher than 200 pixels
 *     // and no larger than the input image
 *   });
 *
 * @example
 * sharp(input)
 *   .resize(200, 200, {
 *     fit: sharp.fit.outside,
 *     withoutReduction: true
 *   })
 *   .toFormat('jpeg')
 *   .toBuffer()
 *   .then(function(outputBuffer) {
 *     // outputBuffer contains JPEG image data
 *     // of at least 200 pixels wide and 200 pixels high while maintaining aspect ratio
 *     // and no smaller than the input image
 *   });
 *
 * @example
 * const scaleByHalf = await sharp(input)
 *   .metadata()
 *   .then(({ width }) => sharp(input)
 *     .resize(Math.round(width * 0.5))
 *     .toBuffer()
 *   );
 *
 * @param {number} [width] - How many pixels wide the resultant image should be. Use `null` or `undefined` to auto-scale the width to match the height.
 * @param {number} [height] - How many pixels high the resultant image should be. Use `null` or `undefined` to auto-scale the height to match the width.
 * @param {Object} [options]
 * @param {number} [options.width] - An alternative means of specifying `width`. If both are present this takes priority.
 * @param {number} [options.height] - An alternative means of specifying `height`. If both are present this takes priority.
 * @param {String} [options.fit='cover'] - How the image should be resized/cropped to fit the target dimension(s), one of `cover`, `contain`, `fill`, `inside` or `outside`.
 * @param {String} [options.position='centre'] - A position, gravity or strategy to use when `fit` is `cover` or `contain`.
 * @param {String|Object} [options.background={r: 0, g: 0, b: 0, alpha: 1}] - background colour when `fit` is `contain`, parsed by the [color](https://www.npmjs.org/package/color) module, defaults to black without transparency.
 * @param {String} [options.kernel='lanczos3'] - The kernel to use for image reduction and the inferred interpolator to use for upsampling. Use the `fastShrinkOnLoad` option to control kernel vs shrink-on-load.
 * @param {Boolean} [options.withoutEnlargement=false] - Do not scale up if the width *or* height are already less than the target dimensions, equivalent to GraphicsMagick's `>` geometry option. This may result in output dimensions smaller than the target dimensions.
 * @param {Boolean} [options.withoutReduction=false] - Do not scale down if the width *or* height are already greater than the target dimensions, equivalent to GraphicsMagick's `<` geometry option. This may still result in a crop to reach the target dimensions.
 * @param {Boolean} [options.fastShrinkOnLoad=true] - Take greater advantage of the JPEG and WebP shrink-on-load feature, which can lead to a slight moir pattern or round-down of an auto-scaled dimension.
 * @returns {Sharp}
 * @throws {Error} Invalid parameters
 */ function resize(widthOrOptions, height, options) {
    if (isResizeExpected(this.options)) {
        this.options.debuglog('ignoring previous resize options');
    }
    if (this.options.widthPost !== -1) {
        this.options.debuglog('operation order will be: extract, resize, extract');
    }
    if (is.defined(widthOrOptions)) {
        if (is.object(widthOrOptions) && !is.defined(options)) {
            options = widthOrOptions;
        } else if (is.integer(widthOrOptions) && widthOrOptions > 0) {
            this.options.width = widthOrOptions;
        } else {
            throw is.invalidParameterError('width', 'positive integer', widthOrOptions);
        }
    } else {
        this.options.width = -1;
    }
    if (is.defined(height)) {
        if (is.integer(height) && height > 0) {
            this.options.height = height;
        } else {
            throw is.invalidParameterError('height', 'positive integer', height);
        }
    } else {
        this.options.height = -1;
    }
    if (is.object(options)) {
        // Width
        if (is.defined(options.width)) {
            if (is.integer(options.width) && options.width > 0) {
                this.options.width = options.width;
            } else {
                throw is.invalidParameterError('width', 'positive integer', options.width);
            }
        }
        // Height
        if (is.defined(options.height)) {
            if (is.integer(options.height) && options.height > 0) {
                this.options.height = options.height;
            } else {
                throw is.invalidParameterError('height', 'positive integer', options.height);
            }
        }
        // Fit
        if (is.defined(options.fit)) {
            const canvas = mapFitToCanvas[options.fit];
            if (is.string(canvas)) {
                this.options.canvas = canvas;
            } else {
                throw is.invalidParameterError('fit', 'valid fit', options.fit);
            }
        }
        // Position
        if (is.defined(options.position)) {
            const pos = is.integer(options.position) ? options.position : strategy[options.position] || position[options.position] || gravity[options.position];
            if (is.integer(pos) && (is.inRange(pos, 0, 8) || is.inRange(pos, 16, 17))) {
                this.options.position = pos;
            } else {
                throw is.invalidParameterError('position', 'valid position/gravity/strategy', options.position);
            }
        }
        // Background
        this._setBackgroundColourOption('resizeBackground', options.background);
        // Kernel
        if (is.defined(options.kernel)) {
            if (is.string(kernel[options.kernel])) {
                this.options.kernel = kernel[options.kernel];
            } else {
                throw is.invalidParameterError('kernel', 'valid kernel name', options.kernel);
            }
        }
        // Without enlargement
        if (is.defined(options.withoutEnlargement)) {
            this._setBooleanOption('withoutEnlargement', options.withoutEnlargement);
        }
        // Without reduction
        if (is.defined(options.withoutReduction)) {
            this._setBooleanOption('withoutReduction', options.withoutReduction);
        }
        // Shrink on load
        if (is.defined(options.fastShrinkOnLoad)) {
            this._setBooleanOption('fastShrinkOnLoad', options.fastShrinkOnLoad);
        }
    }
    if (isRotationExpected(this.options) && isResizeExpected(this.options)) {
        this.options.rotateBefore = true;
    }
    return this;
}
/**
 * Extend / pad / extrude one or more edges of the image with either
 * the provided background colour or pixels derived from the image.
 * This operation will always occur after resizing and extraction, if any.
 *
 * @example
 * // Resize to 140 pixels wide, then add 10 transparent pixels
 * // to the top, left and right edges and 20 to the bottom edge
 * sharp(input)
 *   .resize(140)
 *   .extend({
 *     top: 10,
 *     bottom: 20,
 *     left: 10,
 *     right: 10,
 *     background: { r: 0, g: 0, b: 0, alpha: 0 }
 *   })
 *   ...
 *
* @example
 * // Add a row of 10 red pixels to the bottom
 * sharp(input)
 *   .extend({
 *     bottom: 10,
 *     background: 'red'
 *   })
 *   ...
 *
 * @example
 * // Extrude image by 8 pixels to the right, mirroring existing right hand edge
 * sharp(input)
 *   .extend({
 *     right: 8,
 *     background: 'mirror'
 *   })
 *   ...
 *
 * @param {(number|Object)} extend - single pixel count to add to all edges or an Object with per-edge counts
 * @param {number} [extend.top=0]
 * @param {number} [extend.left=0]
 * @param {number} [extend.bottom=0]
 * @param {number} [extend.right=0]
 * @param {String} [extend.extendWith='background'] - populate new pixels using this method, one of: background, copy, repeat, mirror.
 * @param {String|Object} [extend.background={r: 0, g: 0, b: 0, alpha: 1}] - background colour, parsed by the [color](https://www.npmjs.org/package/color) module, defaults to black without transparency.
 * @returns {Sharp}
 * @throws {Error} Invalid parameters
*/ function extend(extend) {
    if (is.integer(extend) && extend > 0) {
        this.options.extendTop = extend;
        this.options.extendBottom = extend;
        this.options.extendLeft = extend;
        this.options.extendRight = extend;
    } else if (is.object(extend)) {
        if (is.defined(extend.top)) {
            if (is.integer(extend.top) && extend.top >= 0) {
                this.options.extendTop = extend.top;
            } else {
                throw is.invalidParameterError('top', 'positive integer', extend.top);
            }
        }
        if (is.defined(extend.bottom)) {
            if (is.integer(extend.bottom) && extend.bottom >= 0) {
                this.options.extendBottom = extend.bottom;
            } else {
                throw is.invalidParameterError('bottom', 'positive integer', extend.bottom);
            }
        }
        if (is.defined(extend.left)) {
            if (is.integer(extend.left) && extend.left >= 0) {
                this.options.extendLeft = extend.left;
            } else {
                throw is.invalidParameterError('left', 'positive integer', extend.left);
            }
        }
        if (is.defined(extend.right)) {
            if (is.integer(extend.right) && extend.right >= 0) {
                this.options.extendRight = extend.right;
            } else {
                throw is.invalidParameterError('right', 'positive integer', extend.right);
            }
        }
        this._setBackgroundColourOption('extendBackground', extend.background);
        if (is.defined(extend.extendWith)) {
            if (is.string(extendWith[extend.extendWith])) {
                this.options.extendWith = extendWith[extend.extendWith];
            } else {
                throw is.invalidParameterError('extendWith', 'one of: background, copy, repeat, mirror', extend.extendWith);
            }
        }
    } else {
        throw is.invalidParameterError('extend', 'integer or object', extend);
    }
    return this;
}
/**
 * Extract/crop a region of the image.
 *
 * - Use `extract` before `resize` for pre-resize extraction.
 * - Use `extract` after `resize` for post-resize extraction.
 * - Use `extract` twice and `resize` once for extract-then-resize-then-extract in a fixed operation order.
 *
 * @example
 * sharp(input)
 *   .extract({ left: left, top: top, width: width, height: height })
 *   .toFile(output, function(err) {
 *     // Extract a region of the input image, saving in the same format.
 *   });
 * @example
 * sharp(input)
 *   .extract({ left: leftOffsetPre, top: topOffsetPre, width: widthPre, height: heightPre })
 *   .resize(width, height)
 *   .extract({ left: leftOffsetPost, top: topOffsetPost, width: widthPost, height: heightPost })
 *   .toFile(output, function(err) {
 *     // Extract a region, resize, then extract from the resized image
 *   });
 *
 * @param {Object} options - describes the region to extract using integral pixel values
 * @param {number} options.left - zero-indexed offset from left edge
 * @param {number} options.top - zero-indexed offset from top edge
 * @param {number} options.width - width of region to extract
 * @param {number} options.height - height of region to extract
 * @returns {Sharp}
 * @throws {Error} Invalid parameters
 */ function extract(options) {
    const suffix = isResizeExpected(this.options) || this.options.widthPre !== -1 ? 'Post' : 'Pre';
    if (this.options[`width${suffix}`] !== -1) {
        this.options.debuglog('ignoring previous extract options');
    }
    [
        'left',
        'top',
        'width',
        'height'
    ].forEach(function(name) {
        const value = options[name];
        if (is.integer(value) && value >= 0) {
            this.options[name + (name === 'left' || name === 'top' ? 'Offset' : '') + suffix] = value;
        } else {
            throw is.invalidParameterError(name, 'integer', value);
        }
    }, this);
    // Ensure existing rotation occurs before pre-resize extraction
    if (isRotationExpected(this.options) && !isResizeExpected(this.options)) {
        if (this.options.widthPre === -1 || this.options.widthPost === -1) {
            this.options.rotateBefore = true;
        }
    }
    if (this.options.input.autoOrient) {
        this.options.orientBefore = true;
    }
    return this;
}
/**
 * Trim pixels from all edges that contain values similar to the given background colour, which defaults to that of the top-left pixel.
 *
 * Images with an alpha channel will use the combined bounding box of alpha and non-alpha channels.
 *
 * If the result of this operation would trim an image to nothing then no change is made.
 *
 * The `info` response Object will contain `trimOffsetLeft` and `trimOffsetTop` properties.
 *
 * @example
 * // Trim pixels with a colour similar to that of the top-left pixel.
 * await sharp(input)
 *   .trim()
 *   .toFile(output);
 *
 * @example
 * // Trim pixels with the exact same colour as that of the top-left pixel.
 * await sharp(input)
 *   .trim({
 *     threshold: 0
 *   })
 *   .toFile(output);
 *
 * @example
 * // Assume input is line art and trim only pixels with a similar colour to red.
 * const output = await sharp(input)
 *   .trim({
 *     background: "#FF0000",
 *     lineArt: true
 *   })
 *   .toBuffer();
 *
 * @example
 * // Trim all "yellow-ish" pixels, being more lenient with the higher threshold.
 * const output = await sharp(input)
 *   .trim({
 *     background: "yellow",
 *     threshold: 42,
 *   })
 *   .toBuffer();
 *
 * @param {Object} [options]
 * @param {string|Object} [options.background='top-left pixel'] - Background colour, parsed by the [color](https://www.npmjs.org/package/color) module, defaults to that of the top-left pixel.
 * @param {number} [options.threshold=10] - Allowed difference from the above colour, a positive number.
 * @param {boolean} [options.lineArt=false] - Does the input more closely resemble line art (e.g. vector) rather than being photographic?
 * @returns {Sharp}
 * @throws {Error} Invalid parameters
 */ function trim(options) {
    this.options.trimThreshold = 10;
    if (is.defined(options)) {
        if (is.object(options)) {
            if (is.defined(options.background)) {
                this._setBackgroundColourOption('trimBackground', options.background);
            }
            if (is.defined(options.threshold)) {
                if (is.number(options.threshold) && options.threshold >= 0) {
                    this.options.trimThreshold = options.threshold;
                } else {
                    throw is.invalidParameterError('threshold', 'positive number', options.threshold);
                }
            }
            if (is.defined(options.lineArt)) {
                this._setBooleanOption('trimLineArt', options.lineArt);
            }
        } else {
            throw is.invalidParameterError('trim', 'object', options);
        }
    }
    if (isRotationExpected(this.options)) {
        this.options.rotateBefore = true;
    }
    return this;
}
/**
 * Decorate the Sharp prototype with resize-related functions.
 * @module Sharp
 * @private
 */ module.exports = (Sharp)=>{
    Object.assign(Sharp.prototype, {
        resize,
        extend,
        extract,
        trim
    });
    // Class attributes
    Sharp.gravity = gravity;
    Sharp.strategy = strategy;
    Sharp.kernel = kernel;
    Sharp.fit = fit;
    Sharp.position = position;
};
}),
"[project]/node_modules/sharp/lib/composite.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

/*!
  Copyright 2013 Lovell Fuller and others.
  SPDX-License-Identifier: Apache-2.0
*/ const is = __turbopack_context__.r("[project]/node_modules/sharp/lib/is.js [app-client] (ecmascript)");
/**
 * Blend modes.
 * @member
 * @private
 */ const blend = {
    clear: 'clear',
    source: 'source',
    over: 'over',
    in: 'in',
    out: 'out',
    atop: 'atop',
    dest: 'dest',
    'dest-over': 'dest-over',
    'dest-in': 'dest-in',
    'dest-out': 'dest-out',
    'dest-atop': 'dest-atop',
    xor: 'xor',
    add: 'add',
    saturate: 'saturate',
    multiply: 'multiply',
    screen: 'screen',
    overlay: 'overlay',
    darken: 'darken',
    lighten: 'lighten',
    'colour-dodge': 'colour-dodge',
    'color-dodge': 'colour-dodge',
    'colour-burn': 'colour-burn',
    'color-burn': 'colour-burn',
    'hard-light': 'hard-light',
    'soft-light': 'soft-light',
    difference: 'difference',
    exclusion: 'exclusion'
};
/**
 * Composite image(s) over the processed (resized, extracted etc.) image.
 *
 * The images to composite must be the same size or smaller than the processed image.
 * If both `top` and `left` options are provided, they take precedence over `gravity`.
 *
 * Other operations in the same processing pipeline (e.g. resize, rotate, flip,
 * flop, extract) will always be applied to the input image before composition.
 *
 * The `blend` option can be one of `clear`, `source`, `over`, `in`, `out`, `atop`,
 * `dest`, `dest-over`, `dest-in`, `dest-out`, `dest-atop`,
 * `xor`, `add`, `saturate`, `multiply`, `screen`, `overlay`, `darken`, `lighten`,
 * `colour-dodge`, `color-dodge`, `colour-burn`,`color-burn`,
 * `hard-light`, `soft-light`, `difference`, `exclusion`.
 *
 * More information about blend modes can be found at
 * https://www.libvips.org/API/current/enum.BlendMode.html
 * and https://www.cairographics.org/operators/
 *
 * @since 0.22.0
 *
 * @example
 * await sharp(background)
 *   .composite([
 *     { input: layer1, gravity: 'northwest' },
 *     { input: layer2, gravity: 'southeast' },
 *   ])
 *   .toFile('combined.png');
 *
 * @example
 * const output = await sharp('input.gif', { animated: true })
 *   .composite([
 *     { input: 'overlay.png', tile: true, blend: 'saturate' }
 *   ])
 *   .toBuffer();
 *
 * @example
 * sharp('input.png')
 *   .rotate(180)
 *   .resize(300)
 *   .flatten( { background: '#ff6600' } )
 *   .composite([{ input: 'overlay.png', gravity: 'southeast' }])
 *   .sharpen()
 *   .withMetadata()
 *   .webp( { quality: 90 } )
 *   .toBuffer()
 *   .then(function(outputBuffer) {
 *     // outputBuffer contains upside down, 300px wide, alpha channel flattened
 *     // onto orange background, composited with overlay.png with SE gravity,
 *     // sharpened, with metadata, 90% quality WebP image data. Phew!
 *   });
 *
 * @param {Object[]} images - Ordered list of images to composite
 * @param {Buffer|String} [images[].input] - Buffer containing image data, String containing the path to an image file, or Create object (see below)
 * @param {Object} [images[].input.create] - describes a blank overlay to be created.
 * @param {Number} [images[].input.create.width]
 * @param {Number} [images[].input.create.height]
 * @param {Number} [images[].input.create.channels] - 3-4
 * @param {String|Object} [images[].input.create.background] - parsed by the [color](https://www.npmjs.org/package/color) module to extract values for red, green, blue and alpha.
 * @param {Object} [images[].input.text] - describes a new text image to be created.
 * @param {string} [images[].input.text.text] - text to render as a UTF-8 string. It can contain Pango markup, for example `<i>Le</i>Monde`.
 * @param {string} [images[].input.text.font] - font name to render with.
 * @param {string} [images[].input.text.fontfile] - absolute filesystem path to a font file that can be used by `font`.
 * @param {number} [images[].input.text.width=0] - integral number of pixels to word-wrap at. Lines of text wider than this will be broken at word boundaries.
 * @param {number} [images[].input.text.height=0] - integral number of pixels high. When defined, `dpi` will be ignored and the text will automatically fit the pixel resolution defined by `width` and `height`. Will be ignored if `width` is not specified or set to 0.
 * @param {string} [images[].input.text.align='left'] - text alignment (`'left'`, `'centre'`, `'center'`, `'right'`).
 * @param {boolean} [images[].input.text.justify=false] - set this to true to apply justification to the text.
 * @param {number} [images[].input.text.dpi=72] - the resolution (size) at which to render the text. Does not take effect if `height` is specified.
 * @param {boolean} [images[].input.text.rgba=false] - set this to true to enable RGBA output. This is useful for colour emoji rendering, or support for Pango markup features like `<span foreground="red">Red!</span>`.
 * @param {number} [images[].input.text.spacing=0] - text line height in points. Will use the font line height if none is specified.
 * @param {Boolean} [images[].autoOrient=false] - set to true to use EXIF orientation data, if present, to orient the image.
 * @param {String} [images[].blend='over'] - how to blend this image with the image below.
 * @param {String} [images[].gravity='centre'] - gravity at which to place the overlay.
 * @param {Number} [images[].top] - the pixel offset from the top edge.
 * @param {Number} [images[].left] - the pixel offset from the left edge.
 * @param {Boolean} [images[].tile=false] - set to true to repeat the overlay image across the entire image with the given `gravity`.
 * @param {Boolean} [images[].premultiplied=false] - set to true to avoid premultiplying the image below. Equivalent to the `--premultiplied` vips option.
 * @param {Number} [images[].density=72] - number representing the DPI for vector overlay image.
 * @param {Object} [images[].raw] - describes overlay when using raw pixel data.
 * @param {Number} [images[].raw.width]
 * @param {Number} [images[].raw.height]
 * @param {Number} [images[].raw.channels]
 * @param {boolean} [images[].animated=false] - Set to `true` to read all frames/pages of an animated image.
 * @param {string} [images[].failOn='warning'] - @see {@link /api-constructor/ constructor parameters}
 * @param {number|boolean} [images[].limitInputPixels=268402689] - @see {@link /api-constructor/ constructor parameters}
 * @returns {Sharp}
 * @throws {Error} Invalid parameters
 */ function composite(images) {
    if (!Array.isArray(images)) {
        throw is.invalidParameterError('images to composite', 'array', images);
    }
    this.options.composite = images.map((image)=>{
        if (!is.object(image)) {
            throw is.invalidParameterError('image to composite', 'object', image);
        }
        const inputOptions = this._inputOptionsFromObject(image);
        const composite = {
            input: this._createInputDescriptor(image.input, inputOptions, {
                allowStream: false
            }),
            blend: 'over',
            tile: false,
            left: 0,
            top: 0,
            hasOffset: false,
            gravity: 0,
            premultiplied: false
        };
        if (is.defined(image.blend)) {
            if (is.string(blend[image.blend])) {
                composite.blend = blend[image.blend];
            } else {
                throw is.invalidParameterError('blend', 'valid blend name', image.blend);
            }
        }
        if (is.defined(image.tile)) {
            if (is.bool(image.tile)) {
                composite.tile = image.tile;
            } else {
                throw is.invalidParameterError('tile', 'boolean', image.tile);
            }
        }
        if (is.defined(image.left)) {
            if (is.integer(image.left)) {
                composite.left = image.left;
            } else {
                throw is.invalidParameterError('left', 'integer', image.left);
            }
        }
        if (is.defined(image.top)) {
            if (is.integer(image.top)) {
                composite.top = image.top;
            } else {
                throw is.invalidParameterError('top', 'integer', image.top);
            }
        }
        if (is.defined(image.top) !== is.defined(image.left)) {
            throw new Error('Expected both left and top to be set');
        } else {
            composite.hasOffset = is.integer(image.top) && is.integer(image.left);
        }
        if (is.defined(image.gravity)) {
            if (is.integer(image.gravity) && is.inRange(image.gravity, 0, 8)) {
                composite.gravity = image.gravity;
            } else if (is.string(image.gravity) && is.integer(this.constructor.gravity[image.gravity])) {
                composite.gravity = this.constructor.gravity[image.gravity];
            } else {
                throw is.invalidParameterError('gravity', 'valid gravity', image.gravity);
            }
        }
        if (is.defined(image.premultiplied)) {
            if (is.bool(image.premultiplied)) {
                composite.premultiplied = image.premultiplied;
            } else {
                throw is.invalidParameterError('premultiplied', 'boolean', image.premultiplied);
            }
        }
        return composite;
    });
    return this;
}
/**
 * Decorate the Sharp prototype with composite-related functions.
 * @module Sharp
 * @private
 */ module.exports = (Sharp)=>{
    Sharp.prototype.composite = composite;
    Sharp.blend = blend;
};
}),
"[project]/node_modules/sharp/lib/operation.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

/*!
  Copyright 2013 Lovell Fuller and others.
  SPDX-License-Identifier: Apache-2.0
*/ const is = __turbopack_context__.r("[project]/node_modules/sharp/lib/is.js [app-client] (ecmascript)");
/**
 * How accurate an operation should be.
 * @member
 * @private
 */ const vipsPrecision = {
    integer: 'integer',
    float: 'float',
    approximate: 'approximate'
};
/**
 * Rotate the output image.
 *
 * The provided angle is converted to a valid positive degree rotation.
 * For example, `-450` will produce a 270 degree rotation.
 *
 * When rotating by an angle other than a multiple of 90,
 * the background colour can be provided with the `background` option.
 *
 * For backwards compatibility, if no angle is provided, `.autoOrient()` will be called.
 *
 * Only one rotation can occur per pipeline (aside from an initial call without
 * arguments to orient via EXIF data). Previous calls to `rotate` in the same
 * pipeline will be ignored.
 *
 * Multi-page images can only be rotated by 180 degrees.
 *
 * Method order is important when rotating, resizing and/or extracting regions,
 * for example `.rotate(x).extract(y)` will produce a different result to `.extract(y).rotate(x)`.
 *
 * @example
 * const rotateThenResize = await sharp(input)
 *   .rotate(90)
 *   .resize({ width: 16, height: 8, fit: 'fill' })
 *   .toBuffer();
 * const resizeThenRotate = await sharp(input)
 *   .resize({ width: 16, height: 8, fit: 'fill' })
 *   .rotate(90)
 *   .toBuffer();
 *
 * @param {number} [angle=auto] angle of rotation.
 * @param {Object} [options] - if present, is an Object with optional attributes.
 * @param {string|Object} [options.background="#000000"] parsed by the [color](https://www.npmjs.org/package/color) module to extract values for red, green, blue and alpha.
 * @returns {Sharp}
 * @throws {Error} Invalid parameters
 */ function rotate(angle, options) {
    if (!is.defined(angle)) {
        return this.autoOrient();
    }
    if (this.options.angle || this.options.rotationAngle) {
        this.options.debuglog('ignoring previous rotate options');
        this.options.angle = 0;
        this.options.rotationAngle = 0;
    }
    if (is.integer(angle) && !(angle % 90)) {
        this.options.angle = angle;
    } else if (is.number(angle)) {
        this.options.rotationAngle = angle;
        if (is.object(options) && options.background) {
            this._setBackgroundColourOption('rotationBackground', options.background);
        }
    } else {
        throw is.invalidParameterError('angle', 'numeric', angle);
    }
    return this;
}
/**
 * Auto-orient based on the EXIF `Orientation` tag, then remove the tag.
 * Mirroring is supported and may infer the use of a flip operation.
 *
 * Previous or subsequent use of `rotate(angle)` and either `flip()` or `flop()`
 * will logically occur after auto-orientation, regardless of call order.
 *
 * @example
 * const output = await sharp(input).autoOrient().toBuffer();
 *
 * @example
 * const pipeline = sharp()
 *   .autoOrient()
 *   .resize(null, 200)
 *   .toBuffer(function (err, outputBuffer, info) {
 *     // outputBuffer contains 200px high JPEG image data,
 *     // auto-oriented using EXIF Orientation tag
 *     // info.width and info.height contain the dimensions of the resized image
 *   });
 * readableStream.pipe(pipeline);
 *
 * @returns {Sharp}
 */ function autoOrient() {
    this.options.input.autoOrient = true;
    return this;
}
/**
 * Mirror the image vertically (up-down) about the x-axis.
 * This always occurs before rotation, if any.
 *
 * This operation does not work correctly with multi-page images.
 *
 * @example
 * const output = await sharp(input).flip().toBuffer();
 *
 * @param {Boolean} [flip=true]
 * @returns {Sharp}
 */ function flip(flip) {
    this.options.flip = is.bool(flip) ? flip : true;
    return this;
}
/**
 * Mirror the image horizontally (left-right) about the y-axis.
 * This always occurs before rotation, if any.
 *
 * @example
 * const output = await sharp(input).flop().toBuffer();
 *
 * @param {Boolean} [flop=true]
 * @returns {Sharp}
 */ function flop(flop) {
    this.options.flop = is.bool(flop) ? flop : true;
    return this;
}
/**
 * Perform an affine transform on an image. This operation will always occur after resizing, extraction and rotation, if any.
 *
 * You must provide an array of length 4 or a 2x2 affine transformation matrix.
 * By default, new pixels are filled with a black background. You can provide a background colour with the `background` option.
 * A particular interpolator may also be specified. Set the `interpolator` option to an attribute of the `sharp.interpolators` Object e.g. `sharp.interpolators.nohalo`.
 *
 * In the case of a 2x2 matrix, the transform is:
 * - X = `matrix[0, 0]` \* (x + `idx`) + `matrix[0, 1]` \* (y + `idy`) + `odx`
 * - Y = `matrix[1, 0]` \* (x + `idx`) + `matrix[1, 1]` \* (y + `idy`) + `ody`
 *
 * where:
 * - x and y are the coordinates in input image.
 * - X and Y are the coordinates in output image.
 * - (0,0) is the upper left corner.
 *
 * @since 0.27.0
 *
 * @example
 * const pipeline = sharp()
 *   .affine([[1, 0.3], [0.1, 0.7]], {
 *      background: 'white',
 *      interpolator: sharp.interpolators.nohalo
 *   })
 *   .toBuffer((err, outputBuffer, info) => {
 *      // outputBuffer contains the transformed image
 *      // info.width and info.height contain the new dimensions
 *   });
 *
 * inputStream
 *   .pipe(pipeline);
 *
 * @param {Array<Array<number>>|Array<number>} matrix - affine transformation matrix
 * @param {Object} [options] - if present, is an Object with optional attributes.
 * @param {String|Object} [options.background="#000000"] - parsed by the [color](https://www.npmjs.org/package/color) module to extract values for red, green, blue and alpha.
 * @param {Number} [options.idx=0] - input horizontal offset
 * @param {Number} [options.idy=0] - input vertical offset
 * @param {Number} [options.odx=0] - output horizontal offset
 * @param {Number} [options.ody=0] - output vertical offset
 * @param {String} [options.interpolator=sharp.interpolators.bicubic] - interpolator
 * @returns {Sharp}
 * @throws {Error} Invalid parameters
 */ function affine(matrix, options) {
    const flatMatrix = [].concat(...matrix);
    if (flatMatrix.length === 4 && flatMatrix.every(is.number)) {
        this.options.affineMatrix = flatMatrix;
    } else {
        throw is.invalidParameterError('matrix', '1x4 or 2x2 array', matrix);
    }
    if (is.defined(options)) {
        if (is.object(options)) {
            this._setBackgroundColourOption('affineBackground', options.background);
            if (is.defined(options.idx)) {
                if (is.number(options.idx)) {
                    this.options.affineIdx = options.idx;
                } else {
                    throw is.invalidParameterError('options.idx', 'number', options.idx);
                }
            }
            if (is.defined(options.idy)) {
                if (is.number(options.idy)) {
                    this.options.affineIdy = options.idy;
                } else {
                    throw is.invalidParameterError('options.idy', 'number', options.idy);
                }
            }
            if (is.defined(options.odx)) {
                if (is.number(options.odx)) {
                    this.options.affineOdx = options.odx;
                } else {
                    throw is.invalidParameterError('options.odx', 'number', options.odx);
                }
            }
            if (is.defined(options.ody)) {
                if (is.number(options.ody)) {
                    this.options.affineOdy = options.ody;
                } else {
                    throw is.invalidParameterError('options.ody', 'number', options.ody);
                }
            }
            if (is.defined(options.interpolator)) {
                if (is.inArray(options.interpolator, Object.values(this.constructor.interpolators))) {
                    this.options.affineInterpolator = options.interpolator;
                } else {
                    throw is.invalidParameterError('options.interpolator', 'valid interpolator name', options.interpolator);
                }
            }
        } else {
            throw is.invalidParameterError('options', 'object', options);
        }
    }
    return this;
}
/**
 * Sharpen the image.
 *
 * When used without parameters, performs a fast, mild sharpen of the output image.
 *
 * When a `sigma` is provided, performs a slower, more accurate sharpen of the L channel in the LAB colour space.
 * Fine-grained control over the level of sharpening in "flat" (m1) and "jagged" (m2) areas is available.
 *
 * See {@link https://www.libvips.org/API/current/method.Image.sharpen.html libvips sharpen} operation.
 *
 * @example
 * const data = await sharp(input).sharpen().toBuffer();
 *
 * @example
 * const data = await sharp(input).sharpen({ sigma: 2 }).toBuffer();
 *
 * @example
 * const data = await sharp(input)
 *   .sharpen({
 *     sigma: 2,
 *     m1: 0,
 *     m2: 3,
 *     x1: 3,
 *     y2: 15,
 *     y3: 15,
 *   })
 *   .toBuffer();
 *
 * @param {Object|number} [options] - if present, is an Object with attributes
 * @param {number} [options.sigma] - the sigma of the Gaussian mask, where `sigma = 1 + radius / 2`, between 0.000001 and 10
 * @param {number} [options.m1=1.0] - the level of sharpening to apply to "flat" areas, between 0 and 1000000
 * @param {number} [options.m2=2.0] - the level of sharpening to apply to "jagged" areas, between 0 and 1000000
 * @param {number} [options.x1=2.0] - threshold between "flat" and "jagged", between 0 and 1000000
 * @param {number} [options.y2=10.0] - maximum amount of brightening, between 0 and 1000000
 * @param {number} [options.y3=20.0] - maximum amount of darkening, between 0 and 1000000
 * @param {number} [flat] - (deprecated) see `options.m1`.
 * @param {number} [jagged] - (deprecated) see `options.m2`.
 * @returns {Sharp}
 * @throws {Error} Invalid parameters
 */ function sharpen(options, flat, jagged) {
    if (!is.defined(options)) {
        // No arguments: default to mild sharpen
        this.options.sharpenSigma = -1;
    } else if (is.bool(options)) {
        // Deprecated boolean argument: apply mild sharpen?
        this.options.sharpenSigma = options ? -1 : 0;
    } else if (is.number(options) && is.inRange(options, 0.01, 10000)) {
        // Deprecated numeric argument: specific sigma
        this.options.sharpenSigma = options;
        // Deprecated control over flat areas
        if (is.defined(flat)) {
            if (is.number(flat) && is.inRange(flat, 0, 10000)) {
                this.options.sharpenM1 = flat;
            } else {
                throw is.invalidParameterError('flat', 'number between 0 and 10000', flat);
            }
        }
        // Deprecated control over jagged areas
        if (is.defined(jagged)) {
            if (is.number(jagged) && is.inRange(jagged, 0, 10000)) {
                this.options.sharpenM2 = jagged;
            } else {
                throw is.invalidParameterError('jagged', 'number between 0 and 10000', jagged);
            }
        }
    } else if (is.plainObject(options)) {
        if (is.number(options.sigma) && is.inRange(options.sigma, 0.000001, 10)) {
            this.options.sharpenSigma = options.sigma;
        } else {
            throw is.invalidParameterError('options.sigma', 'number between 0.000001 and 10', options.sigma);
        }
        if (is.defined(options.m1)) {
            if (is.number(options.m1) && is.inRange(options.m1, 0, 1000000)) {
                this.options.sharpenM1 = options.m1;
            } else {
                throw is.invalidParameterError('options.m1', 'number between 0 and 1000000', options.m1);
            }
        }
        if (is.defined(options.m2)) {
            if (is.number(options.m2) && is.inRange(options.m2, 0, 1000000)) {
                this.options.sharpenM2 = options.m2;
            } else {
                throw is.invalidParameterError('options.m2', 'number between 0 and 1000000', options.m2);
            }
        }
        if (is.defined(options.x1)) {
            if (is.number(options.x1) && is.inRange(options.x1, 0, 1000000)) {
                this.options.sharpenX1 = options.x1;
            } else {
                throw is.invalidParameterError('options.x1', 'number between 0 and 1000000', options.x1);
            }
        }
        if (is.defined(options.y2)) {
            if (is.number(options.y2) && is.inRange(options.y2, 0, 1000000)) {
                this.options.sharpenY2 = options.y2;
            } else {
                throw is.invalidParameterError('options.y2', 'number between 0 and 1000000', options.y2);
            }
        }
        if (is.defined(options.y3)) {
            if (is.number(options.y3) && is.inRange(options.y3, 0, 1000000)) {
                this.options.sharpenY3 = options.y3;
            } else {
                throw is.invalidParameterError('options.y3', 'number between 0 and 1000000', options.y3);
            }
        }
    } else {
        throw is.invalidParameterError('sigma', 'number between 0.01 and 10000', options);
    }
    return this;
}
/**
 * Apply median filter.
 * When used without parameters the default window is 3x3.
 *
 * @example
 * const output = await sharp(input).median().toBuffer();
 *
 * @example
 * const output = await sharp(input).median(5).toBuffer();
 *
 * @param {number} [size=3] square mask size: size x size
 * @returns {Sharp}
 * @throws {Error} Invalid parameters
 */ function median(size) {
    if (!is.defined(size)) {
        // No arguments: default to 3x3
        this.options.medianSize = 3;
    } else if (is.integer(size) && is.inRange(size, 1, 1000)) {
        // Numeric argument: specific sigma
        this.options.medianSize = size;
    } else {
        throw is.invalidParameterError('size', 'integer between 1 and 1000', size);
    }
    return this;
}
/**
 * Blur the image.
 *
 * When used without parameters, performs a fast 3x3 box blur (equivalent to a box linear filter).
 *
 * When a `sigma` is provided, performs a slower, more accurate Gaussian blur.
 *
 * @example
 * const boxBlurred = await sharp(input)
 *   .blur()
 *   .toBuffer();
 *
 * @example
 * const gaussianBlurred = await sharp(input)
 *   .blur(5)
 *   .toBuffer();
 *
 * @param {Object|number|Boolean} [options]
 * @param {number} [options.sigma] a value between 0.3 and 1000 representing the sigma of the Gaussian mask, where `sigma = 1 + radius / 2`.
 * @param {string} [options.precision='integer'] How accurate the operation should be, one of: integer, float, approximate.
 * @param {number} [options.minAmplitude=0.2] A value between 0.001 and 1. A smaller value will generate a larger, more accurate mask.
 * @returns {Sharp}
 * @throws {Error} Invalid parameters
 */ function blur(options) {
    let sigma;
    if (is.number(options)) {
        sigma = options;
    } else if (is.plainObject(options)) {
        if (!is.number(options.sigma)) {
            throw is.invalidParameterError('options.sigma', 'number between 0.3 and 1000', sigma);
        }
        sigma = options.sigma;
        if ('precision' in options) {
            if (is.string(vipsPrecision[options.precision])) {
                this.options.precision = vipsPrecision[options.precision];
            } else {
                throw is.invalidParameterError('precision', 'one of: integer, float, approximate', options.precision);
            }
        }
        if ('minAmplitude' in options) {
            if (is.number(options.minAmplitude) && is.inRange(options.minAmplitude, 0.001, 1)) {
                this.options.minAmpl = options.minAmplitude;
            } else {
                throw is.invalidParameterError('minAmplitude', 'number between 0.001 and 1', options.minAmplitude);
            }
        }
    }
    if (!is.defined(options)) {
        // No arguments: default to mild blur
        this.options.blurSigma = -1;
    } else if (is.bool(options)) {
        // Boolean argument: apply mild blur?
        this.options.blurSigma = options ? -1 : 0;
    } else if (is.number(sigma) && is.inRange(sigma, 0.3, 1000)) {
        // Numeric argument: specific sigma
        this.options.blurSigma = sigma;
    } else {
        throw is.invalidParameterError('sigma', 'number between 0.3 and 1000', sigma);
    }
    return this;
}
/**
 * Expand foreground objects using the dilate morphological operator.
 *
 * @example
 * const output = await sharp(input)
 *   .dilate()
 *   .toBuffer();
 *
 * @param {Number} [width=1] dilation width in pixels.
 * @returns {Sharp}
 * @throws {Error} Invalid parameters
 */ function dilate(width) {
    if (!is.defined(width)) {
        this.options.dilateWidth = 1;
    } else if (is.integer(width) && width > 0) {
        this.options.dilateWidth = width;
    } else {
        throw is.invalidParameterError('dilate', 'positive integer', dilate);
    }
    return this;
}
/**
 * Shrink foreground objects using the erode morphological operator.
 *
 * @example
 * const output = await sharp(input)
 *   .erode()
 *   .toBuffer();
 *
 * @param {Number} [width=1] erosion width in pixels.
 * @returns {Sharp}
 * @throws {Error} Invalid parameters
 */ function erode(width) {
    if (!is.defined(width)) {
        this.options.erodeWidth = 1;
    } else if (is.integer(width) && width > 0) {
        this.options.erodeWidth = width;
    } else {
        throw is.invalidParameterError('erode', 'positive integer', erode);
    }
    return this;
}
/**
 * Merge alpha transparency channel, if any, with a background, then remove the alpha channel.
 *
 * See also {@link /api-channel#removealpha removeAlpha}.
 *
 * @example
 * await sharp(rgbaInput)
 *   .flatten({ background: '#F0A703' })
 *   .toBuffer();
 *
 * @param {Object} [options]
 * @param {string|Object} [options.background={r: 0, g: 0, b: 0}] - background colour, parsed by the [color](https://www.npmjs.org/package/color) module, defaults to black.
 * @returns {Sharp}
 */ function flatten(options) {
    this.options.flatten = is.bool(options) ? options : true;
    if (is.object(options)) {
        this._setBackgroundColourOption('flattenBackground', options.background);
    }
    return this;
}
/**
 * Ensure the image has an alpha channel
 * with all white pixel values made fully transparent.
 *
 * Existing alpha channel values for non-white pixels remain unchanged.
 *
 * This feature is experimental and the API may change.
 *
 * @since 0.32.1
 *
 * @example
 * await sharp(rgbInput)
 *   .unflatten()
 *   .toBuffer();
 *
 * @example
 * await sharp(rgbInput)
 *   .threshold(128, { grayscale: false }) // converter bright pixels to white
 *   .unflatten()
 *   .toBuffer();
 */ function unflatten() {
    this.options.unflatten = true;
    return this;
}
/**
 * Apply a gamma correction by reducing the encoding (darken) pre-resize at a factor of `1/gamma`
 * then increasing the encoding (brighten) post-resize at a factor of `gamma`.
 * This can improve the perceived brightness of a resized image in non-linear colour spaces.
 * JPEG and WebP input images will not take advantage of the shrink-on-load performance optimisation
 * when applying a gamma correction.
 *
 * Supply a second argument to use a different output gamma value, otherwise the first value is used in both cases.
 *
 * @param {number} [gamma=2.2] value between 1.0 and 3.0.
 * @param {number} [gammaOut] value between 1.0 and 3.0. (optional, defaults to same as `gamma`)
 * @returns {Sharp}
 * @throws {Error} Invalid parameters
 */ function gamma(gamma, gammaOut) {
    if (!is.defined(gamma)) {
        // Default gamma correction of 2.2 (sRGB)
        this.options.gamma = 2.2;
    } else if (is.number(gamma) && is.inRange(gamma, 1, 3)) {
        this.options.gamma = gamma;
    } else {
        throw is.invalidParameterError('gamma', 'number between 1.0 and 3.0', gamma);
    }
    if (!is.defined(gammaOut)) {
        // Default gamma correction for output is same as input
        this.options.gammaOut = this.options.gamma;
    } else if (is.number(gammaOut) && is.inRange(gammaOut, 1, 3)) {
        this.options.gammaOut = gammaOut;
    } else {
        throw is.invalidParameterError('gammaOut', 'number between 1.0 and 3.0', gammaOut);
    }
    return this;
}
/**
 * Produce the "negative" of the image.
 *
 * @example
 * const output = await sharp(input)
 *   .negate()
 *   .toBuffer();
 *
 * @example
 * const output = await sharp(input)
 *   .negate({ alpha: false })
 *   .toBuffer();
 *
 * @param {Object} [options]
 * @param {Boolean} [options.alpha=true] Whether or not to negate any alpha channel
 * @returns {Sharp}
 */ function negate(options) {
    this.options.negate = is.bool(options) ? options : true;
    if (is.plainObject(options) && 'alpha' in options) {
        if (!is.bool(options.alpha)) {
            throw is.invalidParameterError('alpha', 'should be boolean value', options.alpha);
        } else {
            this.options.negateAlpha = options.alpha;
        }
    }
    return this;
}
/**
 * Enhance output image contrast by stretching its luminance to cover a full dynamic range.
 *
 * Uses a histogram-based approach, taking a default range of 1% to 99% to reduce sensitivity to noise at the extremes.
 *
 * Luminance values below the `lower` percentile will be underexposed by clipping to zero.
 * Luminance values above the `upper` percentile will be overexposed by clipping to the max pixel value.
 *
 * @example
 * const output = await sharp(input)
 *   .normalise()
 *   .toBuffer();
 *
 * @example
 * const output = await sharp(input)
 *   .normalise({ lower: 0, upper: 100 })
 *   .toBuffer();
 *
 * @param {Object} [options]
 * @param {number} [options.lower=1] - Percentile below which luminance values will be underexposed.
 * @param {number} [options.upper=99] - Percentile above which luminance values will be overexposed.
 * @returns {Sharp}
 */ function normalise(options) {
    if (is.plainObject(options)) {
        if (is.defined(options.lower)) {
            if (is.number(options.lower) && is.inRange(options.lower, 0, 99)) {
                this.options.normaliseLower = options.lower;
            } else {
                throw is.invalidParameterError('lower', 'number between 0 and 99', options.lower);
            }
        }
        if (is.defined(options.upper)) {
            if (is.number(options.upper) && is.inRange(options.upper, 1, 100)) {
                this.options.normaliseUpper = options.upper;
            } else {
                throw is.invalidParameterError('upper', 'number between 1 and 100', options.upper);
            }
        }
    }
    if (this.options.normaliseLower >= this.options.normaliseUpper) {
        throw is.invalidParameterError('range', 'lower to be less than upper', `${this.options.normaliseLower} >= ${this.options.normaliseUpper}`);
    }
    this.options.normalise = true;
    return this;
}
/**
 * Alternative spelling of normalise.
 *
 * @example
 * const output = await sharp(input)
 *   .normalize()
 *   .toBuffer();
 *
 * @param {Object} [options]
 * @param {number} [options.lower=1] - Percentile below which luminance values will be underexposed.
 * @param {number} [options.upper=99] - Percentile above which luminance values will be overexposed.
 * @returns {Sharp}
 */ function normalize(options) {
    return this.normalise(options);
}
/**
 * Perform contrast limiting adaptive histogram equalization
 * {@link https://en.wikipedia.org/wiki/Adaptive_histogram_equalization#Contrast_Limited_AHE CLAHE}.
 *
 * This will, in general, enhance the clarity of the image by bringing out darker details.
 *
 * @since 0.28.3
 *
 * @example
 * const output = await sharp(input)
 *   .clahe({
 *     width: 3,
 *     height: 3,
 *   })
 *   .toBuffer();
 *
 * @param {Object} options
 * @param {number} options.width - Integral width of the search window, in pixels.
 * @param {number} options.height - Integral height of the search window, in pixels.
 * @param {number} [options.maxSlope=3] - Integral level of brightening, between 0 and 100, where 0 disables contrast limiting.
 * @returns {Sharp}
 * @throws {Error} Invalid parameters
 */ function clahe(options) {
    if (is.plainObject(options)) {
        if (is.integer(options.width) && options.width > 0) {
            this.options.claheWidth = options.width;
        } else {
            throw is.invalidParameterError('width', 'integer greater than zero', options.width);
        }
        if (is.integer(options.height) && options.height > 0) {
            this.options.claheHeight = options.height;
        } else {
            throw is.invalidParameterError('height', 'integer greater than zero', options.height);
        }
        if (is.defined(options.maxSlope)) {
            if (is.integer(options.maxSlope) && is.inRange(options.maxSlope, 0, 100)) {
                this.options.claheMaxSlope = options.maxSlope;
            } else {
                throw is.invalidParameterError('maxSlope', 'integer between 0 and 100', options.maxSlope);
            }
        }
    } else {
        throw is.invalidParameterError('options', 'plain object', options);
    }
    return this;
}
/**
 * Convolve the image with the specified kernel.
 *
 * @example
 * sharp(input)
 *   .convolve({
 *     width: 3,
 *     height: 3,
 *     kernel: [-1, 0, 1, -2, 0, 2, -1, 0, 1]
 *   })
 *   .raw()
 *   .toBuffer(function(err, data, info) {
 *     // data contains the raw pixel data representing the convolution
 *     // of the input image with the horizontal Sobel operator
 *   });
 *
 * @param {Object} kernel
 * @param {number} kernel.width - width of the kernel in pixels.
 * @param {number} kernel.height - height of the kernel in pixels.
 * @param {Array<number>} kernel.kernel - Array of length `width*height` containing the kernel values.
 * @param {number} [kernel.scale=sum] - the scale of the kernel in pixels.
 * @param {number} [kernel.offset=0] - the offset of the kernel in pixels.
 * @returns {Sharp}
 * @throws {Error} Invalid parameters
 */ function convolve(kernel) {
    if (!is.object(kernel) || !Array.isArray(kernel.kernel) || !is.integer(kernel.width) || !is.integer(kernel.height) || !is.inRange(kernel.width, 3, 1001) || !is.inRange(kernel.height, 3, 1001) || kernel.height * kernel.width !== kernel.kernel.length) {
        // must pass in a kernel
        throw new Error('Invalid convolution kernel');
    }
    // Default scale is sum of kernel values
    if (!is.integer(kernel.scale)) {
        kernel.scale = kernel.kernel.reduce((a, b)=>a + b, 0);
    }
    // Clip scale to a minimum value of 1
    if (kernel.scale < 1) {
        kernel.scale = 1;
    }
    if (!is.integer(kernel.offset)) {
        kernel.offset = 0;
    }
    this.options.convKernel = kernel;
    return this;
}
/**
 * Any pixel value greater than or equal to the threshold value will be set to 255, otherwise it will be set to 0.
 * @param {number} [threshold=128] - a value in the range 0-255 representing the level at which the threshold will be applied.
 * @param {Object} [options]
 * @param {Boolean} [options.greyscale=true] - convert to single channel greyscale.
 * @param {Boolean} [options.grayscale=true] - alternative spelling for greyscale.
 * @returns {Sharp}
 * @throws {Error} Invalid parameters
 */ function threshold(threshold, options) {
    if (!is.defined(threshold)) {
        this.options.threshold = 128;
    } else if (is.bool(threshold)) {
        this.options.threshold = threshold ? 128 : 0;
    } else if (is.integer(threshold) && is.inRange(threshold, 0, 255)) {
        this.options.threshold = threshold;
    } else {
        throw is.invalidParameterError('threshold', 'integer between 0 and 255', threshold);
    }
    if (!is.object(options) || options.greyscale === true || options.grayscale === true) {
        this.options.thresholdGrayscale = true;
    } else {
        this.options.thresholdGrayscale = false;
    }
    return this;
}
/**
 * Perform a bitwise boolean operation with operand image.
 *
 * This operation creates an output image where each pixel is the result of
 * the selected bitwise boolean `operation` between the corresponding pixels of the input images.
 *
 * @param {Buffer|string} operand - Buffer containing image data or string containing the path to an image file.
 * @param {string} operator - one of `and`, `or` or `eor` to perform that bitwise operation, like the C logic operators `&`, `|` and `^` respectively.
 * @param {Object} [options]
 * @param {Object} [options.raw] - describes operand when using raw pixel data.
 * @param {number} [options.raw.width]
 * @param {number} [options.raw.height]
 * @param {number} [options.raw.channels]
 * @returns {Sharp}
 * @throws {Error} Invalid parameters
 */ function boolean(operand, operator, options) {
    this.options.boolean = this._createInputDescriptor(operand, options);
    if (is.string(operator) && is.inArray(operator, [
        'and',
        'or',
        'eor'
    ])) {
        this.options.booleanOp = operator;
    } else {
        throw is.invalidParameterError('operator', 'one of: and, or, eor', operator);
    }
    return this;
}
/**
 * Apply the linear formula `a` * input + `b` to the image to adjust image levels.
 *
 * When a single number is provided, it will be used for all image channels.
 * When an array of numbers is provided, the array length must match the number of channels.
 *
 * @example
 * await sharp(input)
 *   .linear(0.5, 2)
 *   .toBuffer();
 *
 * @example
 * await sharp(rgbInput)
 *   .linear(
 *     [0.25, 0.5, 0.75],
 *     [150, 100, 50]
 *   )
 *   .toBuffer();
 *
 * @param {(number|number[])} [a=[]] multiplier
 * @param {(number|number[])} [b=[]] offset
 * @returns {Sharp}
 * @throws {Error} Invalid parameters
 */ function linear(a, b) {
    if (!is.defined(a) && is.number(b)) {
        a = 1.0;
    } else if (is.number(a) && !is.defined(b)) {
        b = 0.0;
    }
    if (!is.defined(a)) {
        this.options.linearA = [];
    } else if (is.number(a)) {
        this.options.linearA = [
            a
        ];
    } else if (Array.isArray(a) && a.length && a.every(is.number)) {
        this.options.linearA = a;
    } else {
        throw is.invalidParameterError('a', 'number or array of numbers', a);
    }
    if (!is.defined(b)) {
        this.options.linearB = [];
    } else if (is.number(b)) {
        this.options.linearB = [
            b
        ];
    } else if (Array.isArray(b) && b.length && b.every(is.number)) {
        this.options.linearB = b;
    } else {
        throw is.invalidParameterError('b', 'number or array of numbers', b);
    }
    if (this.options.linearA.length !== this.options.linearB.length) {
        throw new Error('Expected a and b to be arrays of the same length');
    }
    return this;
}
/**
 * Recombine the image with the specified matrix.
 *
 * @since 0.21.1
 *
 * @example
 * sharp(input)
 *   .recomb([
 *    [0.3588, 0.7044, 0.1368],
 *    [0.2990, 0.5870, 0.1140],
 *    [0.2392, 0.4696, 0.0912],
 *   ])
 *   .raw()
 *   .toBuffer(function(err, data, info) {
 *     // data contains the raw pixel data after applying the matrix
 *     // With this example input, a sepia filter has been applied
 *   });
 *
 * @param {Array<Array<number>>} inputMatrix - 3x3 or 4x4 Recombination matrix
 * @returns {Sharp}
 * @throws {Error} Invalid parameters
 */ function recomb(inputMatrix) {
    if (!Array.isArray(inputMatrix)) {
        throw is.invalidParameterError('inputMatrix', 'array', inputMatrix);
    }
    if (inputMatrix.length !== 3 && inputMatrix.length !== 4) {
        throw is.invalidParameterError('inputMatrix', '3x3 or 4x4 array', inputMatrix.length);
    }
    const recombMatrix = inputMatrix.flat().map(Number);
    if (recombMatrix.length !== 9 && recombMatrix.length !== 16) {
        throw is.invalidParameterError('inputMatrix', 'cardinality of 9 or 16', recombMatrix.length);
    }
    this.options.recombMatrix = recombMatrix;
    return this;
}
/**
 * Transforms the image using brightness, saturation, hue rotation, and lightness.
 * Brightness and lightness both operate on luminance, with the difference being that
 * brightness is multiplicative whereas lightness is additive.
 *
 * @since 0.22.1
 *
 * @example
 * // increase brightness by a factor of 2
 * const output = await sharp(input)
 *   .modulate({
 *     brightness: 2
 *   })
 *   .toBuffer();
 *
 * @example
 * // hue-rotate by 180 degrees
 * const output = await sharp(input)
 *   .modulate({
 *     hue: 180
 *   })
 *   .toBuffer();
 *
 * @example
 * // increase lightness by +50
 * const output = await sharp(input)
 *   .modulate({
 *     lightness: 50
 *   })
 *   .toBuffer();
 *
 * @example
 * // decrease brightness and saturation while also hue-rotating by 90 degrees
 * const output = await sharp(input)
 *   .modulate({
 *     brightness: 0.5,
 *     saturation: 0.5,
 *     hue: 90,
 *   })
 *   .toBuffer();
 *
 * @param {Object} [options]
 * @param {number} [options.brightness] Brightness multiplier
 * @param {number} [options.saturation] Saturation multiplier
 * @param {number} [options.hue] Degrees for hue rotation
 * @param {number} [options.lightness] Lightness addend
 * @returns {Sharp}
 */ function modulate(options) {
    if (!is.plainObject(options)) {
        throw is.invalidParameterError('options', 'plain object', options);
    }
    if ('brightness' in options) {
        if (is.number(options.brightness) && options.brightness >= 0) {
            this.options.brightness = options.brightness;
        } else {
            throw is.invalidParameterError('brightness', 'number above zero', options.brightness);
        }
    }
    if ('saturation' in options) {
        if (is.number(options.saturation) && options.saturation >= 0) {
            this.options.saturation = options.saturation;
        } else {
            throw is.invalidParameterError('saturation', 'number above zero', options.saturation);
        }
    }
    if ('hue' in options) {
        if (is.integer(options.hue)) {
            this.options.hue = options.hue % 360;
        } else {
            throw is.invalidParameterError('hue', 'number', options.hue);
        }
    }
    if ('lightness' in options) {
        if (is.number(options.lightness)) {
            this.options.lightness = options.lightness;
        } else {
            throw is.invalidParameterError('lightness', 'number', options.lightness);
        }
    }
    return this;
}
/**
 * Decorate the Sharp prototype with operation-related functions.
 * @module Sharp
 * @private
 */ module.exports = (Sharp)=>{
    Object.assign(Sharp.prototype, {
        autoOrient,
        rotate,
        flip,
        flop,
        affine,
        sharpen,
        erode,
        dilate,
        median,
        blur,
        flatten,
        unflatten,
        gamma,
        negate,
        normalise,
        normalize,
        clahe,
        convolve,
        threshold,
        boolean,
        linear,
        recomb,
        modulate
    });
};
}),
"[project]/node_modules/@img/colour/color.cjs [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all)=>{
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __copyProps = (to, from, except, desc)=>{
    if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
            get: ()=>from[key],
            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
        });
    }
    return to;
};
var __toCommonJS = (mod)=>__copyProps(__defProp({}, "__esModule", {
        value: true
    }), mod);
// node_modules/color/index.js
var index_exports = {};
__export(index_exports, {
    default: ()=>index_default
});
module.exports = __toCommonJS(index_exports);
// node_modules/color-name/index.js
var color_name_default = {
    aliceblue: [
        240,
        248,
        255
    ],
    antiquewhite: [
        250,
        235,
        215
    ],
    aqua: [
        0,
        255,
        255
    ],
    aquamarine: [
        127,
        255,
        212
    ],
    azure: [
        240,
        255,
        255
    ],
    beige: [
        245,
        245,
        220
    ],
    bisque: [
        255,
        228,
        196
    ],
    black: [
        0,
        0,
        0
    ],
    blanchedalmond: [
        255,
        235,
        205
    ],
    blue: [
        0,
        0,
        255
    ],
    blueviolet: [
        138,
        43,
        226
    ],
    brown: [
        165,
        42,
        42
    ],
    burlywood: [
        222,
        184,
        135
    ],
    cadetblue: [
        95,
        158,
        160
    ],
    chartreuse: [
        127,
        255,
        0
    ],
    chocolate: [
        210,
        105,
        30
    ],
    coral: [
        255,
        127,
        80
    ],
    cornflowerblue: [
        100,
        149,
        237
    ],
    cornsilk: [
        255,
        248,
        220
    ],
    crimson: [
        220,
        20,
        60
    ],
    cyan: [
        0,
        255,
        255
    ],
    darkblue: [
        0,
        0,
        139
    ],
    darkcyan: [
        0,
        139,
        139
    ],
    darkgoldenrod: [
        184,
        134,
        11
    ],
    darkgray: [
        169,
        169,
        169
    ],
    darkgreen: [
        0,
        100,
        0
    ],
    darkgrey: [
        169,
        169,
        169
    ],
    darkkhaki: [
        189,
        183,
        107
    ],
    darkmagenta: [
        139,
        0,
        139
    ],
    darkolivegreen: [
        85,
        107,
        47
    ],
    darkorange: [
        255,
        140,
        0
    ],
    darkorchid: [
        153,
        50,
        204
    ],
    darkred: [
        139,
        0,
        0
    ],
    darksalmon: [
        233,
        150,
        122
    ],
    darkseagreen: [
        143,
        188,
        143
    ],
    darkslateblue: [
        72,
        61,
        139
    ],
    darkslategray: [
        47,
        79,
        79
    ],
    darkslategrey: [
        47,
        79,
        79
    ],
    darkturquoise: [
        0,
        206,
        209
    ],
    darkviolet: [
        148,
        0,
        211
    ],
    deeppink: [
        255,
        20,
        147
    ],
    deepskyblue: [
        0,
        191,
        255
    ],
    dimgray: [
        105,
        105,
        105
    ],
    dimgrey: [
        105,
        105,
        105
    ],
    dodgerblue: [
        30,
        144,
        255
    ],
    firebrick: [
        178,
        34,
        34
    ],
    floralwhite: [
        255,
        250,
        240
    ],
    forestgreen: [
        34,
        139,
        34
    ],
    fuchsia: [
        255,
        0,
        255
    ],
    gainsboro: [
        220,
        220,
        220
    ],
    ghostwhite: [
        248,
        248,
        255
    ],
    gold: [
        255,
        215,
        0
    ],
    goldenrod: [
        218,
        165,
        32
    ],
    gray: [
        128,
        128,
        128
    ],
    green: [
        0,
        128,
        0
    ],
    greenyellow: [
        173,
        255,
        47
    ],
    grey: [
        128,
        128,
        128
    ],
    honeydew: [
        240,
        255,
        240
    ],
    hotpink: [
        255,
        105,
        180
    ],
    indianred: [
        205,
        92,
        92
    ],
    indigo: [
        75,
        0,
        130
    ],
    ivory: [
        255,
        255,
        240
    ],
    khaki: [
        240,
        230,
        140
    ],
    lavender: [
        230,
        230,
        250
    ],
    lavenderblush: [
        255,
        240,
        245
    ],
    lawngreen: [
        124,
        252,
        0
    ],
    lemonchiffon: [
        255,
        250,
        205
    ],
    lightblue: [
        173,
        216,
        230
    ],
    lightcoral: [
        240,
        128,
        128
    ],
    lightcyan: [
        224,
        255,
        255
    ],
    lightgoldenrodyellow: [
        250,
        250,
        210
    ],
    lightgray: [
        211,
        211,
        211
    ],
    lightgreen: [
        144,
        238,
        144
    ],
    lightgrey: [
        211,
        211,
        211
    ],
    lightpink: [
        255,
        182,
        193
    ],
    lightsalmon: [
        255,
        160,
        122
    ],
    lightseagreen: [
        32,
        178,
        170
    ],
    lightskyblue: [
        135,
        206,
        250
    ],
    lightslategray: [
        119,
        136,
        153
    ],
    lightslategrey: [
        119,
        136,
        153
    ],
    lightsteelblue: [
        176,
        196,
        222
    ],
    lightyellow: [
        255,
        255,
        224
    ],
    lime: [
        0,
        255,
        0
    ],
    limegreen: [
        50,
        205,
        50
    ],
    linen: [
        250,
        240,
        230
    ],
    magenta: [
        255,
        0,
        255
    ],
    maroon: [
        128,
        0,
        0
    ],
    mediumaquamarine: [
        102,
        205,
        170
    ],
    mediumblue: [
        0,
        0,
        205
    ],
    mediumorchid: [
        186,
        85,
        211
    ],
    mediumpurple: [
        147,
        112,
        219
    ],
    mediumseagreen: [
        60,
        179,
        113
    ],
    mediumslateblue: [
        123,
        104,
        238
    ],
    mediumspringgreen: [
        0,
        250,
        154
    ],
    mediumturquoise: [
        72,
        209,
        204
    ],
    mediumvioletred: [
        199,
        21,
        133
    ],
    midnightblue: [
        25,
        25,
        112
    ],
    mintcream: [
        245,
        255,
        250
    ],
    mistyrose: [
        255,
        228,
        225
    ],
    moccasin: [
        255,
        228,
        181
    ],
    navajowhite: [
        255,
        222,
        173
    ],
    navy: [
        0,
        0,
        128
    ],
    oldlace: [
        253,
        245,
        230
    ],
    olive: [
        128,
        128,
        0
    ],
    olivedrab: [
        107,
        142,
        35
    ],
    orange: [
        255,
        165,
        0
    ],
    orangered: [
        255,
        69,
        0
    ],
    orchid: [
        218,
        112,
        214
    ],
    palegoldenrod: [
        238,
        232,
        170
    ],
    palegreen: [
        152,
        251,
        152
    ],
    paleturquoise: [
        175,
        238,
        238
    ],
    palevioletred: [
        219,
        112,
        147
    ],
    papayawhip: [
        255,
        239,
        213
    ],
    peachpuff: [
        255,
        218,
        185
    ],
    peru: [
        205,
        133,
        63
    ],
    pink: [
        255,
        192,
        203
    ],
    plum: [
        221,
        160,
        221
    ],
    powderblue: [
        176,
        224,
        230
    ],
    purple: [
        128,
        0,
        128
    ],
    rebeccapurple: [
        102,
        51,
        153
    ],
    red: [
        255,
        0,
        0
    ],
    rosybrown: [
        188,
        143,
        143
    ],
    royalblue: [
        65,
        105,
        225
    ],
    saddlebrown: [
        139,
        69,
        19
    ],
    salmon: [
        250,
        128,
        114
    ],
    sandybrown: [
        244,
        164,
        96
    ],
    seagreen: [
        46,
        139,
        87
    ],
    seashell: [
        255,
        245,
        238
    ],
    sienna: [
        160,
        82,
        45
    ],
    silver: [
        192,
        192,
        192
    ],
    skyblue: [
        135,
        206,
        235
    ],
    slateblue: [
        106,
        90,
        205
    ],
    slategray: [
        112,
        128,
        144
    ],
    slategrey: [
        112,
        128,
        144
    ],
    snow: [
        255,
        250,
        250
    ],
    springgreen: [
        0,
        255,
        127
    ],
    steelblue: [
        70,
        130,
        180
    ],
    tan: [
        210,
        180,
        140
    ],
    teal: [
        0,
        128,
        128
    ],
    thistle: [
        216,
        191,
        216
    ],
    tomato: [
        255,
        99,
        71
    ],
    turquoise: [
        64,
        224,
        208
    ],
    violet: [
        238,
        130,
        238
    ],
    wheat: [
        245,
        222,
        179
    ],
    white: [
        255,
        255,
        255
    ],
    whitesmoke: [
        245,
        245,
        245
    ],
    yellow: [
        255,
        255,
        0
    ],
    yellowgreen: [
        154,
        205,
        50
    ]
};
// node_modules/color-string/index.js
var reverseNames = /* @__PURE__ */ Object.create(null);
for(const name in color_name_default){
    if (Object.hasOwn(color_name_default, name)) {
        reverseNames[color_name_default[name]] = name;
    }
}
var cs = {
    to: {},
    get: {}
};
cs.get = function(string) {
    const prefix = string.slice(0, 3).toLowerCase();
    let value;
    let model;
    switch(prefix){
        case "hsl":
            {
                value = cs.get.hsl(string);
                model = "hsl";
                break;
            }
        case "hwb":
            {
                value = cs.get.hwb(string);
                model = "hwb";
                break;
            }
        default:
            {
                value = cs.get.rgb(string);
                model = "rgb";
                break;
            }
    }
    if (!value) {
        return null;
    }
    return {
        model,
        value
    };
};
cs.get.rgb = function(string) {
    if (!string) {
        return null;
    }
    const abbr = /^#([a-f\d]{3,4})$/i;
    const hex = /^#([a-f\d]{6})([a-f\d]{2})?$/i;
    const rgba = /^rgba?\(\s*([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)\s*(?:[\s,|/]\s*([+-]?[\d.]+)(%?)\s*)?\)$/;
    const per = /^rgba?\(\s*([+-]?[\d.]+)%\s*,?\s*([+-]?[\d.]+)%\s*,?\s*([+-]?[\d.]+)%\s*(?:[\s,|/]\s*([+-]?[\d.]+)(%?)\s*)?\)$/;
    const keyword = /^(\w+)$/;
    let rgb = [
        0,
        0,
        0,
        1
    ];
    let match;
    let i;
    let hexAlpha;
    if (match = string.match(hex)) {
        hexAlpha = match[2];
        match = match[1];
        for(i = 0; i < 3; i++){
            const i2 = i * 2;
            rgb[i] = Number.parseInt(match.slice(i2, i2 + 2), 16);
        }
        if (hexAlpha) {
            rgb[3] = Number.parseInt(hexAlpha, 16) / 255;
        }
    } else if (match = string.match(abbr)) {
        match = match[1];
        hexAlpha = match[3];
        for(i = 0; i < 3; i++){
            rgb[i] = Number.parseInt(match[i] + match[i], 16);
        }
        if (hexAlpha) {
            rgb[3] = Number.parseInt(hexAlpha + hexAlpha, 16) / 255;
        }
    } else if (match = string.match(rgba)) {
        for(i = 0; i < 3; i++){
            rgb[i] = Number.parseInt(match[i + 1], 10);
        }
        if (match[4]) {
            rgb[3] = match[5] ? Number.parseFloat(match[4]) * 0.01 : Number.parseFloat(match[4]);
        }
    } else if (match = string.match(per)) {
        for(i = 0; i < 3; i++){
            rgb[i] = Math.round(Number.parseFloat(match[i + 1]) * 2.55);
        }
        if (match[4]) {
            rgb[3] = match[5] ? Number.parseFloat(match[4]) * 0.01 : Number.parseFloat(match[4]);
        }
    } else if (match = string.match(keyword)) {
        if (match[1] === "transparent") {
            return [
                0,
                0,
                0,
                0
            ];
        }
        if (!Object.hasOwn(color_name_default, match[1])) {
            return null;
        }
        rgb = color_name_default[match[1]];
        rgb[3] = 1;
        return rgb;
    } else {
        return null;
    }
    for(i = 0; i < 3; i++){
        rgb[i] = clamp(rgb[i], 0, 255);
    }
    rgb[3] = clamp(rgb[3], 0, 1);
    return rgb;
};
cs.get.hsl = function(string) {
    if (!string) {
        return null;
    }
    const hsl = /^hsla?\(\s*([+-]?(?:\d{0,3}\.)?\d+)(?:deg)?\s*,?\s*([+-]?[\d.]+)%\s*,?\s*([+-]?[\d.]+)%\s*(?:[,|/]\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
    const match = string.match(hsl);
    if (match) {
        const alpha = Number.parseFloat(match[4]);
        const h = (Number.parseFloat(match[1]) % 360 + 360) % 360;
        const s = clamp(Number.parseFloat(match[2]), 0, 100);
        const l = clamp(Number.parseFloat(match[3]), 0, 100);
        const a = clamp(Number.isNaN(alpha) ? 1 : alpha, 0, 1);
        return [
            h,
            s,
            l,
            a
        ];
    }
    return null;
};
cs.get.hwb = function(string) {
    if (!string) {
        return null;
    }
    const hwb = /^hwb\(\s*([+-]?\d{0,3}(?:\.\d+)?)(?:deg)?\s*[\s,]\s*([+-]?[\d.]+)%\s*[\s,]\s*([+-]?[\d.]+)%\s*(?:[\s,]\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
    const match = string.match(hwb);
    if (match) {
        const alpha = Number.parseFloat(match[4]);
        const h = (Number.parseFloat(match[1]) % 360 + 360) % 360;
        const w = clamp(Number.parseFloat(match[2]), 0, 100);
        const b = clamp(Number.parseFloat(match[3]), 0, 100);
        const a = clamp(Number.isNaN(alpha) ? 1 : alpha, 0, 1);
        return [
            h,
            w,
            b,
            a
        ];
    }
    return null;
};
cs.to.hex = function(...rgba) {
    return "#" + hexDouble(rgba[0]) + hexDouble(rgba[1]) + hexDouble(rgba[2]) + (rgba[3] < 1 ? hexDouble(Math.round(rgba[3] * 255)) : "");
};
cs.to.rgb = function(...rgba) {
    return rgba.length < 4 || rgba[3] === 1 ? "rgb(" + Math.round(rgba[0]) + ", " + Math.round(rgba[1]) + ", " + Math.round(rgba[2]) + ")" : "rgba(" + Math.round(rgba[0]) + ", " + Math.round(rgba[1]) + ", " + Math.round(rgba[2]) + ", " + rgba[3] + ")";
};
cs.to.rgb.percent = function(...rgba) {
    const r = Math.round(rgba[0] / 255 * 100);
    const g = Math.round(rgba[1] / 255 * 100);
    const b = Math.round(rgba[2] / 255 * 100);
    return rgba.length < 4 || rgba[3] === 1 ? "rgb(" + r + "%, " + g + "%, " + b + "%)" : "rgba(" + r + "%, " + g + "%, " + b + "%, " + rgba[3] + ")";
};
cs.to.hsl = function(...hsla) {
    return hsla.length < 4 || hsla[3] === 1 ? "hsl(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%)" : "hsla(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%, " + hsla[3] + ")";
};
cs.to.hwb = function(...hwba) {
    let a = "";
    if (hwba.length >= 4 && hwba[3] !== 1) {
        a = ", " + hwba[3];
    }
    return "hwb(" + hwba[0] + ", " + hwba[1] + "%, " + hwba[2] + "%" + a + ")";
};
cs.to.keyword = function(...rgb) {
    return reverseNames[rgb.slice(0, 3)];
};
function clamp(number_, min, max) {
    return Math.min(Math.max(min, number_), max);
}
function hexDouble(number_) {
    const string_ = Math.round(number_).toString(16).toUpperCase();
    return string_.length < 2 ? "0" + string_ : string_;
}
var color_string_default = cs;
// node_modules/color-convert/conversions.js
var reverseKeywords = {};
for (const key of Object.keys(color_name_default)){
    reverseKeywords[color_name_default[key]] = key;
}
var convert = {
    rgb: {
        channels: 3,
        labels: "rgb"
    },
    hsl: {
        channels: 3,
        labels: "hsl"
    },
    hsv: {
        channels: 3,
        labels: "hsv"
    },
    hwb: {
        channels: 3,
        labels: "hwb"
    },
    cmyk: {
        channels: 4,
        labels: "cmyk"
    },
    xyz: {
        channels: 3,
        labels: "xyz"
    },
    lab: {
        channels: 3,
        labels: "lab"
    },
    oklab: {
        channels: 3,
        labels: [
            "okl",
            "oka",
            "okb"
        ]
    },
    lch: {
        channels: 3,
        labels: "lch"
    },
    oklch: {
        channels: 3,
        labels: [
            "okl",
            "okc",
            "okh"
        ]
    },
    hex: {
        channels: 1,
        labels: [
            "hex"
        ]
    },
    keyword: {
        channels: 1,
        labels: [
            "keyword"
        ]
    },
    ansi16: {
        channels: 1,
        labels: [
            "ansi16"
        ]
    },
    ansi256: {
        channels: 1,
        labels: [
            "ansi256"
        ]
    },
    hcg: {
        channels: 3,
        labels: [
            "h",
            "c",
            "g"
        ]
    },
    apple: {
        channels: 3,
        labels: [
            "r16",
            "g16",
            "b16"
        ]
    },
    gray: {
        channels: 1,
        labels: [
            "gray"
        ]
    }
};
var conversions_default = convert;
var LAB_FT = (6 / 29) ** 3;
function srgbNonlinearTransform(c) {
    const cc = c > 31308e-7 ? 1.055 * c ** (1 / 2.4) - 0.055 : c * 12.92;
    return Math.min(Math.max(0, cc), 1);
}
function srgbNonlinearTransformInv(c) {
    return c > 0.04045 ? ((c + 0.055) / 1.055) ** 2.4 : c / 12.92;
}
for (const model of Object.keys(convert)){
    if (!("channels" in convert[model])) {
        throw new Error("missing channels property: " + model);
    }
    if (!("labels" in convert[model])) {
        throw new Error("missing channel labels property: " + model);
    }
    if (convert[model].labels.length !== convert[model].channels) {
        throw new Error("channel and label counts mismatch: " + model);
    }
    const { channels, labels } = convert[model];
    delete convert[model].channels;
    delete convert[model].labels;
    Object.defineProperty(convert[model], "channels", {
        value: channels
    });
    Object.defineProperty(convert[model], "labels", {
        value: labels
    });
}
convert.rgb.hsl = function(rgb) {
    const r = rgb[0] / 255;
    const g = rgb[1] / 255;
    const b = rgb[2] / 255;
    const min = Math.min(r, g, b);
    const max = Math.max(r, g, b);
    const delta = max - min;
    let h;
    let s;
    switch(max){
        case min:
            {
                h = 0;
                break;
            }
        case r:
            {
                h = (g - b) / delta;
                break;
            }
        case g:
            {
                h = 2 + (b - r) / delta;
                break;
            }
        case b:
            {
                h = 4 + (r - g) / delta;
                break;
            }
    }
    h = Math.min(h * 60, 360);
    if (h < 0) {
        h += 360;
    }
    const l = (min + max) / 2;
    if (max === min) {
        s = 0;
    } else if (l <= 0.5) {
        s = delta / (max + min);
    } else {
        s = delta / (2 - max - min);
    }
    return [
        h,
        s * 100,
        l * 100
    ];
};
convert.rgb.hsv = function(rgb) {
    let rdif;
    let gdif;
    let bdif;
    let h;
    let s;
    const r = rgb[0] / 255;
    const g = rgb[1] / 255;
    const b = rgb[2] / 255;
    const v = Math.max(r, g, b);
    const diff = v - Math.min(r, g, b);
    const diffc = function(c) {
        return (v - c) / 6 / diff + 1 / 2;
    };
    if (diff === 0) {
        h = 0;
        s = 0;
    } else {
        s = diff / v;
        rdif = diffc(r);
        gdif = diffc(g);
        bdif = diffc(b);
        switch(v){
            case r:
                {
                    h = bdif - gdif;
                    break;
                }
            case g:
                {
                    h = 1 / 3 + rdif - bdif;
                    break;
                }
            case b:
                {
                    h = 2 / 3 + gdif - rdif;
                    break;
                }
        }
        if (h < 0) {
            h += 1;
        } else if (h > 1) {
            h -= 1;
        }
    }
    return [
        h * 360,
        s * 100,
        v * 100
    ];
};
convert.rgb.hwb = function(rgb) {
    const r = rgb[0];
    const g = rgb[1];
    let b = rgb[2];
    const h = convert.rgb.hsl(rgb)[0];
    const w = 1 / 255 * Math.min(r, Math.min(g, b));
    b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
    return [
        h,
        w * 100,
        b * 100
    ];
};
convert.rgb.oklab = function(rgb) {
    const r = srgbNonlinearTransformInv(rgb[0] / 255);
    const g = srgbNonlinearTransformInv(rgb[1] / 255);
    const b = srgbNonlinearTransformInv(rgb[2] / 255);
    const lp = Math.cbrt(0.4122214708 * r + 0.5363325363 * g + 0.0514459929 * b);
    const mp = Math.cbrt(0.2119034982 * r + 0.6806995451 * g + 0.1073969566 * b);
    const sp = Math.cbrt(0.0883024619 * r + 0.2817188376 * g + 0.6299787005 * b);
    const l = 0.2104542553 * lp + 0.793617785 * mp - 0.0040720468 * sp;
    const aa = 1.9779984951 * lp - 2.428592205 * mp + 0.4505937099 * sp;
    const bb = 0.0259040371 * lp + 0.7827717662 * mp - 0.808675766 * sp;
    return [
        l * 100,
        aa * 100,
        bb * 100
    ];
};
convert.rgb.cmyk = function(rgb) {
    const r = rgb[0] / 255;
    const g = rgb[1] / 255;
    const b = rgb[2] / 255;
    const k = Math.min(1 - r, 1 - g, 1 - b);
    const c = (1 - r - k) / (1 - k) || 0;
    const m = (1 - g - k) / (1 - k) || 0;
    const y = (1 - b - k) / (1 - k) || 0;
    return [
        c * 100,
        m * 100,
        y * 100,
        k * 100
    ];
};
function comparativeDistance(x, y) {
    return (x[0] - y[0]) ** 2 + (x[1] - y[1]) ** 2 + (x[2] - y[2]) ** 2;
}
convert.rgb.keyword = function(rgb) {
    const reversed = reverseKeywords[rgb];
    if (reversed) {
        return reversed;
    }
    let currentClosestDistance = Number.POSITIVE_INFINITY;
    let currentClosestKeyword;
    for (const keyword of Object.keys(color_name_default)){
        const value = color_name_default[keyword];
        const distance = comparativeDistance(rgb, value);
        if (distance < currentClosestDistance) {
            currentClosestDistance = distance;
            currentClosestKeyword = keyword;
        }
    }
    return currentClosestKeyword;
};
convert.keyword.rgb = function(keyword) {
    return color_name_default[keyword];
};
convert.rgb.xyz = function(rgb) {
    const r = srgbNonlinearTransformInv(rgb[0] / 255);
    const g = srgbNonlinearTransformInv(rgb[1] / 255);
    const b = srgbNonlinearTransformInv(rgb[2] / 255);
    const x = r * 0.4124564 + g * 0.3575761 + b * 0.1804375;
    const y = r * 0.2126729 + g * 0.7151522 + b * 0.072175;
    const z = r * 0.0193339 + g * 0.119192 + b * 0.9503041;
    return [
        x * 100,
        y * 100,
        z * 100
    ];
};
convert.rgb.lab = function(rgb) {
    const xyz = convert.rgb.xyz(rgb);
    let x = xyz[0];
    let y = xyz[1];
    let z = xyz[2];
    x /= 95.047;
    y /= 100;
    z /= 108.883;
    x = x > LAB_FT ? x ** (1 / 3) : 7.787 * x + 16 / 116;
    y = y > LAB_FT ? y ** (1 / 3) : 7.787 * y + 16 / 116;
    z = z > LAB_FT ? z ** (1 / 3) : 7.787 * z + 16 / 116;
    const l = 116 * y - 16;
    const a = 500 * (x - y);
    const b = 200 * (y - z);
    return [
        l,
        a,
        b
    ];
};
convert.hsl.rgb = function(hsl) {
    const h = hsl[0] / 360;
    const s = hsl[1] / 100;
    const l = hsl[2] / 100;
    let t3;
    let value;
    if (s === 0) {
        value = l * 255;
        return [
            value,
            value,
            value
        ];
    }
    const t2 = l < 0.5 ? l * (1 + s) : l + s - l * s;
    const t1 = 2 * l - t2;
    const rgb = [
        0,
        0,
        0
    ];
    for(let i = 0; i < 3; i++){
        t3 = h + 1 / 3 * -(i - 1);
        if (t3 < 0) {
            t3++;
        }
        if (t3 > 1) {
            t3--;
        }
        if (6 * t3 < 1) {
            value = t1 + (t2 - t1) * 6 * t3;
        } else if (2 * t3 < 1) {
            value = t2;
        } else if (3 * t3 < 2) {
            value = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
        } else {
            value = t1;
        }
        rgb[i] = value * 255;
    }
    return rgb;
};
convert.hsl.hsv = function(hsl) {
    const h = hsl[0];
    let s = hsl[1] / 100;
    let l = hsl[2] / 100;
    let smin = s;
    const lmin = Math.max(l, 0.01);
    l *= 2;
    s *= l <= 1 ? l : 2 - l;
    smin *= lmin <= 1 ? lmin : 2 - lmin;
    const v = (l + s) / 2;
    const sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
    return [
        h,
        sv * 100,
        v * 100
    ];
};
convert.hsv.rgb = function(hsv) {
    const h = hsv[0] / 60;
    const s = hsv[1] / 100;
    let v = hsv[2] / 100;
    const hi = Math.floor(h) % 6;
    const f = h - Math.floor(h);
    const p = 255 * v * (1 - s);
    const q = 255 * v * (1 - s * f);
    const t = 255 * v * (1 - s * (1 - f));
    v *= 255;
    switch(hi){
        case 0:
            {
                return [
                    v,
                    t,
                    p
                ];
            }
        case 1:
            {
                return [
                    q,
                    v,
                    p
                ];
            }
        case 2:
            {
                return [
                    p,
                    v,
                    t
                ];
            }
        case 3:
            {
                return [
                    p,
                    q,
                    v
                ];
            }
        case 4:
            {
                return [
                    t,
                    p,
                    v
                ];
            }
        case 5:
            {
                return [
                    v,
                    p,
                    q
                ];
            }
    }
};
convert.hsv.hsl = function(hsv) {
    const h = hsv[0];
    const s = hsv[1] / 100;
    const v = hsv[2] / 100;
    const vmin = Math.max(v, 0.01);
    let sl;
    let l;
    l = (2 - s) * v;
    const lmin = (2 - s) * vmin;
    sl = s * vmin;
    sl /= lmin <= 1 ? lmin : 2 - lmin;
    sl = sl || 0;
    l /= 2;
    return [
        h,
        sl * 100,
        l * 100
    ];
};
convert.hwb.rgb = function(hwb) {
    const h = hwb[0] / 360;
    let wh = hwb[1] / 100;
    let bl = hwb[2] / 100;
    const ratio = wh + bl;
    let f;
    if (ratio > 1) {
        wh /= ratio;
        bl /= ratio;
    }
    const i = Math.floor(6 * h);
    const v = 1 - bl;
    f = 6 * h - i;
    if ((i & 1) !== 0) {
        f = 1 - f;
    }
    const n = wh + f * (v - wh);
    let r;
    let g;
    let b;
    switch(i){
        default:
        case 6:
        case 0:
            {
                r = v;
                g = n;
                b = wh;
                break;
            }
        case 1:
            {
                r = n;
                g = v;
                b = wh;
                break;
            }
        case 2:
            {
                r = wh;
                g = v;
                b = n;
                break;
            }
        case 3:
            {
                r = wh;
                g = n;
                b = v;
                break;
            }
        case 4:
            {
                r = n;
                g = wh;
                b = v;
                break;
            }
        case 5:
            {
                r = v;
                g = wh;
                b = n;
                break;
            }
    }
    return [
        r * 255,
        g * 255,
        b * 255
    ];
};
convert.cmyk.rgb = function(cmyk) {
    const c = cmyk[0] / 100;
    const m = cmyk[1] / 100;
    const y = cmyk[2] / 100;
    const k = cmyk[3] / 100;
    const r = 1 - Math.min(1, c * (1 - k) + k);
    const g = 1 - Math.min(1, m * (1 - k) + k);
    const b = 1 - Math.min(1, y * (1 - k) + k);
    return [
        r * 255,
        g * 255,
        b * 255
    ];
};
convert.xyz.rgb = function(xyz) {
    const x = xyz[0] / 100;
    const y = xyz[1] / 100;
    const z = xyz[2] / 100;
    let r;
    let g;
    let b;
    r = x * 3.2404542 + y * -1.5371385 + z * -0.4985314;
    g = x * -0.969266 + y * 1.8760108 + z * 0.041556;
    b = x * 0.0556434 + y * -0.2040259 + z * 1.0572252;
    r = srgbNonlinearTransform(r);
    g = srgbNonlinearTransform(g);
    b = srgbNonlinearTransform(b);
    return [
        r * 255,
        g * 255,
        b * 255
    ];
};
convert.xyz.lab = function(xyz) {
    let x = xyz[0];
    let y = xyz[1];
    let z = xyz[2];
    x /= 95.047;
    y /= 100;
    z /= 108.883;
    x = x > LAB_FT ? x ** (1 / 3) : 7.787 * x + 16 / 116;
    y = y > LAB_FT ? y ** (1 / 3) : 7.787 * y + 16 / 116;
    z = z > LAB_FT ? z ** (1 / 3) : 7.787 * z + 16 / 116;
    const l = 116 * y - 16;
    const a = 500 * (x - y);
    const b = 200 * (y - z);
    return [
        l,
        a,
        b
    ];
};
convert.xyz.oklab = function(xyz) {
    const x = xyz[0] / 100;
    const y = xyz[1] / 100;
    const z = xyz[2] / 100;
    const lp = Math.cbrt(0.8189330101 * x + 0.3618667424 * y - 0.1288597137 * z);
    const mp = Math.cbrt(0.0329845436 * x + 0.9293118715 * y + 0.0361456387 * z);
    const sp = Math.cbrt(0.0482003018 * x + 0.2643662691 * y + 0.633851707 * z);
    const l = 0.2104542553 * lp + 0.793617785 * mp - 0.0040720468 * sp;
    const a = 1.9779984951 * lp - 2.428592205 * mp + 0.4505937099 * sp;
    const b = 0.0259040371 * lp + 0.7827717662 * mp - 0.808675766 * sp;
    return [
        l * 100,
        a * 100,
        b * 100
    ];
};
convert.oklab.oklch = function(oklab) {
    return convert.lab.lch(oklab);
};
convert.oklab.xyz = function(oklab) {
    const ll = oklab[0] / 100;
    const a = oklab[1] / 100;
    const b = oklab[2] / 100;
    const l = (0.999999998 * ll + 0.396337792 * a + 0.215803758 * b) ** 3;
    const m = (1.000000008 * ll - 0.105561342 * a - 0.063854175 * b) ** 3;
    const s = (1.000000055 * ll - 0.089484182 * a - 1.291485538 * b) ** 3;
    const x = 1.227013851 * l - 0.55779998 * m + 0.281256149 * s;
    const y = -0.040580178 * l + 1.11225687 * m - 0.071676679 * s;
    const z = -0.076381285 * l - 0.421481978 * m + 1.58616322 * s;
    return [
        x * 100,
        y * 100,
        z * 100
    ];
};
convert.oklab.rgb = function(oklab) {
    const ll = oklab[0] / 100;
    const aa = oklab[1] / 100;
    const bb = oklab[2] / 100;
    const l = (ll + 0.3963377774 * aa + 0.2158037573 * bb) ** 3;
    const m = (ll - 0.1055613458 * aa - 0.0638541728 * bb) ** 3;
    const s = (ll - 0.0894841775 * aa - 1.291485548 * bb) ** 3;
    const r = srgbNonlinearTransform(4.0767416621 * l - 3.3077115913 * m + 0.2309699292 * s);
    const g = srgbNonlinearTransform(-1.2684380046 * l + 2.6097574011 * m - 0.3413193965 * s);
    const b = srgbNonlinearTransform(-0.0041960863 * l - 0.7034186147 * m + 1.707614701 * s);
    return [
        r * 255,
        g * 255,
        b * 255
    ];
};
convert.oklch.oklab = function(oklch) {
    return convert.lch.lab(oklch);
};
convert.lab.xyz = function(lab) {
    const l = lab[0];
    const a = lab[1];
    const b = lab[2];
    let x;
    let y;
    let z;
    y = (l + 16) / 116;
    x = a / 500 + y;
    z = y - b / 200;
    const y2 = y ** 3;
    const x2 = x ** 3;
    const z2 = z ** 3;
    y = y2 > LAB_FT ? y2 : (y - 16 / 116) / 7.787;
    x = x2 > LAB_FT ? x2 : (x - 16 / 116) / 7.787;
    z = z2 > LAB_FT ? z2 : (z - 16 / 116) / 7.787;
    x *= 95.047;
    y *= 100;
    z *= 108.883;
    return [
        x,
        y,
        z
    ];
};
convert.lab.lch = function(lab) {
    const l = lab[0];
    const a = lab[1];
    const b = lab[2];
    let h;
    const hr = Math.atan2(b, a);
    h = hr * 360 / 2 / Math.PI;
    if (h < 0) {
        h += 360;
    }
    const c = Math.sqrt(a * a + b * b);
    return [
        l,
        c,
        h
    ];
};
convert.lch.lab = function(lch) {
    const l = lch[0];
    const c = lch[1];
    const h = lch[2];
    const hr = h / 360 * 2 * Math.PI;
    const a = c * Math.cos(hr);
    const b = c * Math.sin(hr);
    return [
        l,
        a,
        b
    ];
};
convert.rgb.ansi16 = function(args, saturation = null) {
    const [r, g, b] = args;
    let value = saturation === null ? convert.rgb.hsv(args)[2] : saturation;
    value = Math.round(value / 50);
    if (value === 0) {
        return 30;
    }
    let ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
    if (value === 2) {
        ansi += 60;
    }
    return ansi;
};
convert.hsv.ansi16 = function(args) {
    return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
};
convert.rgb.ansi256 = function(args) {
    const r = args[0];
    const g = args[1];
    const b = args[2];
    if (r >> 4 === g >> 4 && g >> 4 === b >> 4) {
        if (r < 8) {
            return 16;
        }
        if (r > 248) {
            return 231;
        }
        return Math.round((r - 8) / 247 * 24) + 232;
    }
    const ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
    return ansi;
};
convert.ansi16.rgb = function(args) {
    args = args[0];
    let color = args % 10;
    if (color === 0 || color === 7) {
        if (args > 50) {
            color += 3.5;
        }
        color = color / 10.5 * 255;
        return [
            color,
            color,
            color
        ];
    }
    const mult = (Math.trunc(args > 50) + 1) * 0.5;
    const r = (color & 1) * mult * 255;
    const g = (color >> 1 & 1) * mult * 255;
    const b = (color >> 2 & 1) * mult * 255;
    return [
        r,
        g,
        b
    ];
};
convert.ansi256.rgb = function(args) {
    args = args[0];
    if (args >= 232) {
        const c = (args - 232) * 10 + 8;
        return [
            c,
            c,
            c
        ];
    }
    args -= 16;
    let rem;
    const r = Math.floor(args / 36) / 5 * 255;
    const g = Math.floor((rem = args % 36) / 6) / 5 * 255;
    const b = rem % 6 / 5 * 255;
    return [
        r,
        g,
        b
    ];
};
convert.rgb.hex = function(args) {
    const integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
    const string = integer.toString(16).toUpperCase();
    return "000000".slice(string.length) + string;
};
convert.hex.rgb = function(args) {
    const match = args.toString(16).match(/[a-f\d]{6}|[a-f\d]{3}/i);
    if (!match) {
        return [
            0,
            0,
            0
        ];
    }
    let colorString = match[0];
    if (match[0].length === 3) {
        colorString = [
            ...colorString
        ].map((char)=>char + char).join("");
    }
    const integer = Number.parseInt(colorString, 16);
    const r = integer >> 16 & 255;
    const g = integer >> 8 & 255;
    const b = integer & 255;
    return [
        r,
        g,
        b
    ];
};
convert.rgb.hcg = function(rgb) {
    const r = rgb[0] / 255;
    const g = rgb[1] / 255;
    const b = rgb[2] / 255;
    const max = Math.max(Math.max(r, g), b);
    const min = Math.min(Math.min(r, g), b);
    const chroma = max - min;
    let hue;
    const grayscale = chroma < 1 ? min / (1 - chroma) : 0;
    if (chroma <= 0) {
        hue = 0;
    } else if (max === r) {
        hue = (g - b) / chroma % 6;
    } else if (max === g) {
        hue = 2 + (b - r) / chroma;
    } else {
        hue = 4 + (r - g) / chroma;
    }
    hue /= 6;
    hue %= 1;
    return [
        hue * 360,
        chroma * 100,
        grayscale * 100
    ];
};
convert.hsl.hcg = function(hsl) {
    const s = hsl[1] / 100;
    const l = hsl[2] / 100;
    const c = l < 0.5 ? 2 * s * l : 2 * s * (1 - l);
    let f = 0;
    if (c < 1) {
        f = (l - 0.5 * c) / (1 - c);
    }
    return [
        hsl[0],
        c * 100,
        f * 100
    ];
};
convert.hsv.hcg = function(hsv) {
    const s = hsv[1] / 100;
    const v = hsv[2] / 100;
    const c = s * v;
    let f = 0;
    if (c < 1) {
        f = (v - c) / (1 - c);
    }
    return [
        hsv[0],
        c * 100,
        f * 100
    ];
};
convert.hcg.rgb = function(hcg) {
    const h = hcg[0] / 360;
    const c = hcg[1] / 100;
    const g = hcg[2] / 100;
    if (c === 0) {
        return [
            g * 255,
            g * 255,
            g * 255
        ];
    }
    const pure = [
        0,
        0,
        0
    ];
    const hi = h % 1 * 6;
    const v = hi % 1;
    const w = 1 - v;
    let mg = 0;
    switch(Math.floor(hi)){
        case 0:
            {
                pure[0] = 1;
                pure[1] = v;
                pure[2] = 0;
                break;
            }
        case 1:
            {
                pure[0] = w;
                pure[1] = 1;
                pure[2] = 0;
                break;
            }
        case 2:
            {
                pure[0] = 0;
                pure[1] = 1;
                pure[2] = v;
                break;
            }
        case 3:
            {
                pure[0] = 0;
                pure[1] = w;
                pure[2] = 1;
                break;
            }
        case 4:
            {
                pure[0] = v;
                pure[1] = 0;
                pure[2] = 1;
                break;
            }
        default:
            {
                pure[0] = 1;
                pure[1] = 0;
                pure[2] = w;
            }
    }
    mg = (1 - c) * g;
    return [
        (c * pure[0] + mg) * 255,
        (c * pure[1] + mg) * 255,
        (c * pure[2] + mg) * 255
    ];
};
convert.hcg.hsv = function(hcg) {
    const c = hcg[1] / 100;
    const g = hcg[2] / 100;
    const v = c + g * (1 - c);
    let f = 0;
    if (v > 0) {
        f = c / v;
    }
    return [
        hcg[0],
        f * 100,
        v * 100
    ];
};
convert.hcg.hsl = function(hcg) {
    const c = hcg[1] / 100;
    const g = hcg[2] / 100;
    const l = g * (1 - c) + 0.5 * c;
    let s = 0;
    if (l > 0 && l < 0.5) {
        s = c / (2 * l);
    } else if (l >= 0.5 && l < 1) {
        s = c / (2 * (1 - l));
    }
    return [
        hcg[0],
        s * 100,
        l * 100
    ];
};
convert.hcg.hwb = function(hcg) {
    const c = hcg[1] / 100;
    const g = hcg[2] / 100;
    const v = c + g * (1 - c);
    return [
        hcg[0],
        (v - c) * 100,
        (1 - v) * 100
    ];
};
convert.hwb.hcg = function(hwb) {
    const w = hwb[1] / 100;
    const b = hwb[2] / 100;
    const v = 1 - b;
    const c = v - w;
    let g = 0;
    if (c < 1) {
        g = (v - c) / (1 - c);
    }
    return [
        hwb[0],
        c * 100,
        g * 100
    ];
};
convert.apple.rgb = function(apple) {
    return [
        apple[0] / 65535 * 255,
        apple[1] / 65535 * 255,
        apple[2] / 65535 * 255
    ];
};
convert.rgb.apple = function(rgb) {
    return [
        rgb[0] / 255 * 65535,
        rgb[1] / 255 * 65535,
        rgb[2] / 255 * 65535
    ];
};
convert.gray.rgb = function(args) {
    return [
        args[0] / 100 * 255,
        args[0] / 100 * 255,
        args[0] / 100 * 255
    ];
};
convert.gray.hsl = function(args) {
    return [
        0,
        0,
        args[0]
    ];
};
convert.gray.hsv = convert.gray.hsl;
convert.gray.hwb = function(gray) {
    return [
        0,
        100,
        gray[0]
    ];
};
convert.gray.cmyk = function(gray) {
    return [
        0,
        0,
        0,
        gray[0]
    ];
};
convert.gray.lab = function(gray) {
    return [
        gray[0],
        0,
        0
    ];
};
convert.gray.hex = function(gray) {
    const value = Math.round(gray[0] / 100 * 255) & 255;
    const integer = (value << 16) + (value << 8) + value;
    const string = integer.toString(16).toUpperCase();
    return "000000".slice(string.length) + string;
};
convert.rgb.gray = function(rgb) {
    const value = (rgb[0] + rgb[1] + rgb[2]) / 3;
    return [
        value / 255 * 100
    ];
};
// node_modules/color-convert/route.js
function buildGraph() {
    const graph = {};
    const models2 = Object.keys(conversions_default);
    for(let { length } = models2, i = 0; i < length; i++){
        graph[models2[i]] = {
            // http://jsperf.com/1-vs-infinity
            // micro-opt, but this is simple.
            distance: -1,
            parent: null
        };
    }
    return graph;
}
function deriveBFS(fromModel) {
    const graph = buildGraph();
    const queue = [
        fromModel
    ];
    graph[fromModel].distance = 0;
    while(queue.length > 0){
        const current = queue.pop();
        const adjacents = Object.keys(conversions_default[current]);
        for(let { length } = adjacents, i = 0; i < length; i++){
            const adjacent = adjacents[i];
            const node = graph[adjacent];
            if (node.distance === -1) {
                node.distance = graph[current].distance + 1;
                node.parent = current;
                queue.unshift(adjacent);
            }
        }
    }
    return graph;
}
function link(from, to) {
    return function(args) {
        return to(from(args));
    };
}
function wrapConversion(toModel, graph) {
    const path = [
        graph[toModel].parent,
        toModel
    ];
    let fn = conversions_default[graph[toModel].parent][toModel];
    let cur = graph[toModel].parent;
    while(graph[cur].parent){
        path.unshift(graph[cur].parent);
        fn = link(conversions_default[graph[cur].parent][cur], fn);
        cur = graph[cur].parent;
    }
    fn.conversion = path;
    return fn;
}
function route(fromModel) {
    const graph = deriveBFS(fromModel);
    const conversion = {};
    const models2 = Object.keys(graph);
    for(let { length } = models2, i = 0; i < length; i++){
        const toModel = models2[i];
        const node = graph[toModel];
        if (node.parent === null) {
            continue;
        }
        conversion[toModel] = wrapConversion(toModel, graph);
    }
    return conversion;
}
var route_default = route;
// node_modules/color-convert/index.js
var convert2 = {};
var models = Object.keys(conversions_default);
function wrapRaw(fn) {
    const wrappedFn = function(...args) {
        const arg0 = args[0];
        if (arg0 === void 0 || arg0 === null) {
            return arg0;
        }
        if (arg0.length > 1) {
            args = arg0;
        }
        return fn(args);
    };
    if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
    }
    return wrappedFn;
}
function wrapRounded(fn) {
    const wrappedFn = function(...args) {
        const arg0 = args[0];
        if (arg0 === void 0 || arg0 === null) {
            return arg0;
        }
        if (arg0.length > 1) {
            args = arg0;
        }
        const result = fn(args);
        if (typeof result === "object") {
            for(let { length } = result, i = 0; i < length; i++){
                result[i] = Math.round(result[i]);
            }
        }
        return result;
    };
    if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
    }
    return wrappedFn;
}
for (const fromModel of models){
    convert2[fromModel] = {};
    Object.defineProperty(convert2[fromModel], "channels", {
        value: conversions_default[fromModel].channels
    });
    Object.defineProperty(convert2[fromModel], "labels", {
        value: conversions_default[fromModel].labels
    });
    const routes = route_default(fromModel);
    const routeModels = Object.keys(routes);
    for (const toModel of routeModels){
        const fn = routes[toModel];
        convert2[fromModel][toModel] = wrapRounded(fn);
        convert2[fromModel][toModel].raw = wrapRaw(fn);
    }
}
var color_convert_default = convert2;
// node_modules/color/index.js
var skippedModels = [
    // To be honest, I don't really feel like keyword belongs in color convert, but eh.
    "keyword",
    // Gray conflicts with some method names, and has its own method defined.
    "gray",
    // Shouldn't really be in color-convert either...
    "hex"
];
var hashedModelKeys = {};
for (const model of Object.keys(color_convert_default)){
    hashedModelKeys[[
        ...color_convert_default[model].labels
    ].sort().join("")] = model;
}
var limiters = {};
function Color(object, model) {
    if (!(this instanceof Color)) {
        return new Color(object, model);
    }
    if (model && model in skippedModels) {
        model = null;
    }
    if (model && !(model in color_convert_default)) {
        throw new Error("Unknown model: " + model);
    }
    let i;
    let channels;
    if (object == null) {
        this.model = "rgb";
        this.color = [
            0,
            0,
            0
        ];
        this.valpha = 1;
    } else if (object instanceof Color) {
        this.model = object.model;
        this.color = [
            ...object.color
        ];
        this.valpha = object.valpha;
    } else if (typeof object === "string") {
        const result = color_string_default.get(object);
        if (result === null) {
            throw new Error("Unable to parse color from string: " + object);
        }
        this.model = result.model;
        channels = color_convert_default[this.model].channels;
        this.color = result.value.slice(0, channels);
        this.valpha = typeof result.value[channels] === "number" ? result.value[channels] : 1;
    } else if (object.length > 0) {
        this.model = model || "rgb";
        channels = color_convert_default[this.model].channels;
        const newArray = Array.prototype.slice.call(object, 0, channels);
        this.color = zeroArray(newArray, channels);
        this.valpha = typeof object[channels] === "number" ? object[channels] : 1;
    } else if (typeof object === "number") {
        this.model = "rgb";
        this.color = [
            object >> 16 & 255,
            object >> 8 & 255,
            object & 255
        ];
        this.valpha = 1;
    } else {
        this.valpha = 1;
        const keys = Object.keys(object);
        if ("alpha" in object) {
            keys.splice(keys.indexOf("alpha"), 1);
            this.valpha = typeof object.alpha === "number" ? object.alpha : 0;
        }
        const hashedKeys = keys.sort().join("");
        if (!(hashedKeys in hashedModelKeys)) {
            throw new Error("Unable to parse color from object: " + JSON.stringify(object));
        }
        this.model = hashedModelKeys[hashedKeys];
        const { labels } = color_convert_default[this.model];
        const color = [];
        for(i = 0; i < labels.length; i++){
            color.push(object[labels[i]]);
        }
        this.color = zeroArray(color);
    }
    if (limiters[this.model]) {
        channels = color_convert_default[this.model].channels;
        for(i = 0; i < channels; i++){
            const limit = limiters[this.model][i];
            if (limit) {
                this.color[i] = limit(this.color[i]);
            }
        }
    }
    this.valpha = Math.max(0, Math.min(1, this.valpha));
    if (Object.freeze) {
        Object.freeze(this);
    }
}
Color.prototype = {
    toString () {
        return this.string();
    },
    toJSON () {
        return this[this.model]();
    },
    string (places) {
        let self = this.model in color_string_default.to ? this : this.rgb();
        self = self.round(typeof places === "number" ? places : 1);
        const arguments_ = self.valpha === 1 ? self.color : [
            ...self.color,
            this.valpha
        ];
        return color_string_default.to[self.model](...arguments_);
    },
    percentString (places) {
        const self = this.rgb().round(typeof places === "number" ? places : 1);
        const arguments_ = self.valpha === 1 ? self.color : [
            ...self.color,
            this.valpha
        ];
        return color_string_default.to.rgb.percent(...arguments_);
    },
    array () {
        return this.valpha === 1 ? [
            ...this.color
        ] : [
            ...this.color,
            this.valpha
        ];
    },
    object () {
        const result = {};
        const { channels } = color_convert_default[this.model];
        const { labels } = color_convert_default[this.model];
        for(let i = 0; i < channels; i++){
            result[labels[i]] = this.color[i];
        }
        if (this.valpha !== 1) {
            result.alpha = this.valpha;
        }
        return result;
    },
    unitArray () {
        const rgb = this.rgb().color;
        rgb[0] /= 255;
        rgb[1] /= 255;
        rgb[2] /= 255;
        if (this.valpha !== 1) {
            rgb.push(this.valpha);
        }
        return rgb;
    },
    unitObject () {
        const rgb = this.rgb().object();
        rgb.r /= 255;
        rgb.g /= 255;
        rgb.b /= 255;
        if (this.valpha !== 1) {
            rgb.alpha = this.valpha;
        }
        return rgb;
    },
    round (places) {
        places = Math.max(places || 0, 0);
        return new Color([
            ...this.color.map(roundToPlace(places)),
            this.valpha
        ], this.model);
    },
    alpha (value) {
        if (value !== void 0) {
            return new Color([
                ...this.color,
                Math.max(0, Math.min(1, value))
            ], this.model);
        }
        return this.valpha;
    },
    // Rgb
    red: getset("rgb", 0, maxfn(255)),
    green: getset("rgb", 1, maxfn(255)),
    blue: getset("rgb", 2, maxfn(255)),
    hue: getset([
        "hsl",
        "hsv",
        "hsl",
        "hwb",
        "hcg"
    ], 0, (value)=>(value % 360 + 360) % 360),
    saturationl: getset("hsl", 1, maxfn(100)),
    lightness: getset("hsl", 2, maxfn(100)),
    saturationv: getset("hsv", 1, maxfn(100)),
    value: getset("hsv", 2, maxfn(100)),
    chroma: getset("hcg", 1, maxfn(100)),
    gray: getset("hcg", 2, maxfn(100)),
    white: getset("hwb", 1, maxfn(100)),
    wblack: getset("hwb", 2, maxfn(100)),
    cyan: getset("cmyk", 0, maxfn(100)),
    magenta: getset("cmyk", 1, maxfn(100)),
    yellow: getset("cmyk", 2, maxfn(100)),
    black: getset("cmyk", 3, maxfn(100)),
    x: getset("xyz", 0, maxfn(95.047)),
    y: getset("xyz", 1, maxfn(100)),
    z: getset("xyz", 2, maxfn(108.833)),
    l: getset("lab", 0, maxfn(100)),
    a: getset("lab", 1),
    b: getset("lab", 2),
    keyword (value) {
        if (value !== void 0) {
            return new Color(value);
        }
        return color_convert_default[this.model].keyword(this.color);
    },
    hex (value) {
        if (value !== void 0) {
            return new Color(value);
        }
        return color_string_default.to.hex(...this.rgb().round().color);
    },
    hexa (value) {
        if (value !== void 0) {
            return new Color(value);
        }
        const rgbArray = this.rgb().round().color;
        let alphaHex = Math.round(this.valpha * 255).toString(16).toUpperCase();
        if (alphaHex.length === 1) {
            alphaHex = "0" + alphaHex;
        }
        return color_string_default.to.hex(...rgbArray) + alphaHex;
    },
    rgbNumber () {
        const rgb = this.rgb().color;
        return (rgb[0] & 255) << 16 | (rgb[1] & 255) << 8 | rgb[2] & 255;
    },
    luminosity () {
        const rgb = this.rgb().color;
        const lum = [];
        for (const [i, element] of rgb.entries()){
            const chan = element / 255;
            lum[i] = chan <= 0.04045 ? chan / 12.92 : ((chan + 0.055) / 1.055) ** 2.4;
        }
        return 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];
    },
    contrast (color2) {
        const lum1 = this.luminosity();
        const lum2 = color2.luminosity();
        if (lum1 > lum2) {
            return (lum1 + 0.05) / (lum2 + 0.05);
        }
        return (lum2 + 0.05) / (lum1 + 0.05);
    },
    level (color2) {
        const contrastRatio = this.contrast(color2);
        if (contrastRatio >= 7) {
            return "AAA";
        }
        return contrastRatio >= 4.5 ? "AA" : "";
    },
    isDark () {
        const rgb = this.rgb().color;
        const yiq = (rgb[0] * 2126 + rgb[1] * 7152 + rgb[2] * 722) / 1e4;
        return yiq < 128;
    },
    isLight () {
        return !this.isDark();
    },
    negate () {
        const rgb = this.rgb();
        for(let i = 0; i < 3; i++){
            rgb.color[i] = 255 - rgb.color[i];
        }
        return rgb;
    },
    lighten (ratio) {
        const hsl = this.hsl();
        hsl.color[2] += hsl.color[2] * ratio;
        return hsl;
    },
    darken (ratio) {
        const hsl = this.hsl();
        hsl.color[2] -= hsl.color[2] * ratio;
        return hsl;
    },
    saturate (ratio) {
        const hsl = this.hsl();
        hsl.color[1] += hsl.color[1] * ratio;
        return hsl;
    },
    desaturate (ratio) {
        const hsl = this.hsl();
        hsl.color[1] -= hsl.color[1] * ratio;
        return hsl;
    },
    whiten (ratio) {
        const hwb = this.hwb();
        hwb.color[1] += hwb.color[1] * ratio;
        return hwb;
    },
    blacken (ratio) {
        const hwb = this.hwb();
        hwb.color[2] += hwb.color[2] * ratio;
        return hwb;
    },
    grayscale () {
        const rgb = this.rgb().color;
        const value = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;
        return Color.rgb(value, value, value);
    },
    fade (ratio) {
        return this.alpha(this.valpha - this.valpha * ratio);
    },
    opaquer (ratio) {
        return this.alpha(this.valpha + this.valpha * ratio);
    },
    rotate (degrees) {
        const hsl = this.hsl();
        let hue = hsl.color[0];
        hue = (hue + degrees) % 360;
        hue = hue < 0 ? 360 + hue : hue;
        hsl.color[0] = hue;
        return hsl;
    },
    mix (mixinColor, weight) {
        if (!mixinColor || !mixinColor.rgb) {
            throw new Error('Argument to "mix" was not a Color instance, but rather an instance of ' + typeof mixinColor);
        }
        const color1 = mixinColor.rgb();
        const color2 = this.rgb();
        const p = weight === void 0 ? 0.5 : weight;
        const w = 2 * p - 1;
        const a = color1.alpha() - color2.alpha();
        const w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2;
        const w2 = 1 - w1;
        return Color.rgb(w1 * color1.red() + w2 * color2.red(), w1 * color1.green() + w2 * color2.green(), w1 * color1.blue() + w2 * color2.blue(), color1.alpha() * p + color2.alpha() * (1 - p));
    }
};
for (const model of Object.keys(color_convert_default)){
    if (skippedModels.includes(model)) {
        continue;
    }
    const { channels } = color_convert_default[model];
    Color.prototype[model] = function(...arguments_) {
        if (this.model === model) {
            return new Color(this);
        }
        if (arguments_.length > 0) {
            return new Color(arguments_, model);
        }
        return new Color([
            ...assertArray(color_convert_default[this.model][model].raw(this.color)),
            this.valpha
        ], model);
    };
    Color[model] = function(...arguments_) {
        let color = arguments_[0];
        if (typeof color === "number") {
            color = zeroArray(arguments_, channels);
        }
        return new Color(color, model);
    };
}
function roundTo(number, places) {
    return Number(number.toFixed(places));
}
function roundToPlace(places) {
    return function(number) {
        return roundTo(number, places);
    };
}
function getset(model, channel, modifier) {
    model = Array.isArray(model) ? model : [
        model
    ];
    for (const m of model){
        (limiters[m] ||= [])[channel] = modifier;
    }
    model = model[0];
    return function(value) {
        let result;
        if (value !== void 0) {
            if (modifier) {
                value = modifier(value);
            }
            result = this[model]();
            result.color[channel] = value;
            return result;
        }
        result = this[model]().color[channel];
        if (modifier) {
            result = modifier(result);
        }
        return result;
    };
}
function maxfn(max) {
    return function(v) {
        return Math.max(0, Math.min(max, v));
    };
}
function assertArray(value) {
    return Array.isArray(value) ? value : [
        value
    ];
}
function zeroArray(array, length) {
    for(let i = 0; i < length; i++){
        if (typeof array[i] !== "number") {
            array[i] = 0;
        }
    }
    return array;
}
var index_default = Color;
}),
"[project]/node_modules/@img/colour/index.cjs [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

module.exports = __turbopack_context__.r("[project]/node_modules/@img/colour/color.cjs [app-client] (ecmascript)").default;
}),
"[project]/node_modules/sharp/lib/colour.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

/*!
  Copyright 2013 Lovell Fuller and others.
  SPDX-License-Identifier: Apache-2.0
*/ const color = __turbopack_context__.r("[project]/node_modules/@img/colour/index.cjs [app-client] (ecmascript)");
const is = __turbopack_context__.r("[project]/node_modules/sharp/lib/is.js [app-client] (ecmascript)");
/**
 * Colourspaces.
 * @private
 */ const colourspace = {
    multiband: 'multiband',
    'b-w': 'b-w',
    bw: 'b-w',
    cmyk: 'cmyk',
    srgb: 'srgb'
};
/**
 * Tint the image using the provided colour.
 * An alpha channel may be present and will be unchanged by the operation.
 *
 * @example
 * const output = await sharp(input)
 *   .tint({ r: 255, g: 240, b: 16 })
 *   .toBuffer();
 *
 * @param {string|Object} tint - Parsed by the [color](https://www.npmjs.org/package/color) module.
 * @returns {Sharp}
 * @throws {Error} Invalid parameter
 */ function tint(tint) {
    this._setBackgroundColourOption('tint', tint);
    return this;
}
/**
 * Convert to 8-bit greyscale; 256 shades of grey.
 * This is a linear operation. If the input image is in a non-linear colour space such as sRGB, use `gamma()` with `greyscale()` for the best results.
 * By default the output image will be web-friendly sRGB and contain three (identical) colour channels.
 * This may be overridden by other sharp operations such as `toColourspace('b-w')`,
 * which will produce an output image containing one colour channel.
 * An alpha channel may be present, and will be unchanged by the operation.
 *
 * @example
 * const output = await sharp(input).greyscale().toBuffer();
 *
 * @param {Boolean} [greyscale=true]
 * @returns {Sharp}
 */ function greyscale(greyscale) {
    this.options.greyscale = is.bool(greyscale) ? greyscale : true;
    return this;
}
/**
 * Alternative spelling of `greyscale`.
 * @param {Boolean} [grayscale=true]
 * @returns {Sharp}
 */ function grayscale(grayscale) {
    return this.greyscale(grayscale);
}
/**
 * Set the pipeline colourspace.
 *
 * The input image will be converted to the provided colourspace at the start of the pipeline.
 * All operations will use this colourspace before converting to the output colourspace,
 * as defined by {@link #tocolourspace toColourspace}.
 *
 * @since 0.29.0
 *
 * @example
 * // Run pipeline in 16 bits per channel RGB while converting final result to 8 bits per channel sRGB.
 * await sharp(input)
 *  .pipelineColourspace('rgb16')
 *  .toColourspace('srgb')
 *  .toFile('16bpc-pipeline-to-8bpc-output.png')
 *
 * @param {string} [colourspace] - pipeline colourspace e.g. `rgb16`, `scrgb`, `lab`, `grey16` [...](https://www.libvips.org/API/current/enum.Interpretation.html)
 * @returns {Sharp}
 * @throws {Error} Invalid parameters
 */ function pipelineColourspace(colourspace) {
    if (!is.string(colourspace)) {
        throw is.invalidParameterError('colourspace', 'string', colourspace);
    }
    this.options.colourspacePipeline = colourspace;
    return this;
}
/**
 * Alternative spelling of `pipelineColourspace`.
 * @param {string} [colorspace] - pipeline colorspace.
 * @returns {Sharp}
 * @throws {Error} Invalid parameters
 */ function pipelineColorspace(colorspace) {
    return this.pipelineColourspace(colorspace);
}
/**
 * Set the output colourspace.
 * By default output image will be web-friendly sRGB, with additional channels interpreted as alpha channels.
 *
 * @example
 * // Output 16 bits per pixel RGB
 * await sharp(input)
 *  .toColourspace('rgb16')
 *  .toFile('16-bpp.png')
 *
 * @param {string} [colourspace] - output colourspace e.g. `srgb`, `rgb`, `cmyk`, `lab`, `b-w` [...](https://www.libvips.org/API/current/enum.Interpretation.html)
 * @returns {Sharp}
 * @throws {Error} Invalid parameters
 */ function toColourspace(colourspace) {
    if (!is.string(colourspace)) {
        throw is.invalidParameterError('colourspace', 'string', colourspace);
    }
    this.options.colourspace = colourspace;
    return this;
}
/**
 * Alternative spelling of `toColourspace`.
 * @param {string} [colorspace] - output colorspace.
 * @returns {Sharp}
 * @throws {Error} Invalid parameters
 */ function toColorspace(colorspace) {
    return this.toColourspace(colorspace);
}
/**
 * Create a RGBA colour array from a given value.
 * @private
 * @param {string|Object} value
 * @throws {Error} Invalid value
 */ function _getBackgroundColourOption(value) {
    if (is.object(value) || is.string(value) && value.length >= 3 && value.length <= 200) {
        const colour = color(value);
        return [
            colour.red(),
            colour.green(),
            colour.blue(),
            Math.round(colour.alpha() * 255)
        ];
    } else {
        throw is.invalidParameterError('background', 'object or string', value);
    }
}
/**
 * Update a colour attribute of the this.options Object.
 * @private
 * @param {string} key
 * @param {string|Object} value
 * @throws {Error} Invalid value
 */ function _setBackgroundColourOption(key, value) {
    if (is.defined(value)) {
        this.options[key] = _getBackgroundColourOption(value);
    }
}
/**
 * Decorate the Sharp prototype with colour-related functions.
 * @module Sharp
 * @private
 */ module.exports = (Sharp)=>{
    Object.assign(Sharp.prototype, {
        // Public
        tint,
        greyscale,
        grayscale,
        pipelineColourspace,
        pipelineColorspace,
        toColourspace,
        toColorspace,
        // Private
        _getBackgroundColourOption,
        _setBackgroundColourOption
    });
    // Class attributes
    Sharp.colourspace = colourspace;
    Sharp.colorspace = colourspace;
};
}),
"[project]/node_modules/sharp/lib/channel.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

/*!
  Copyright 2013 Lovell Fuller and others.
  SPDX-License-Identifier: Apache-2.0
*/ const is = __turbopack_context__.r("[project]/node_modules/sharp/lib/is.js [app-client] (ecmascript)");
/**
 * Boolean operations for bandbool.
 * @private
 */ const bool = {
    and: 'and',
    or: 'or',
    eor: 'eor'
};
/**
 * Remove alpha channels, if any. This is a no-op if the image does not have an alpha channel.
 *
 * See also {@link /api-operation/#flatten flatten}.
 *
 * @example
 * sharp('rgba.png')
 *   .removeAlpha()
 *   .toFile('rgb.png', function(err, info) {
 *     // rgb.png is a 3 channel image without an alpha channel
 *   });
 *
 * @returns {Sharp}
 */ function removeAlpha() {
    this.options.removeAlpha = true;
    return this;
}
/**
 * Ensure the output image has an alpha transparency channel.
 * If missing, the added alpha channel will have the specified
 * transparency level, defaulting to fully-opaque (1).
 * This is a no-op if the image already has an alpha channel.
 *
 * @since 0.21.2
 *
 * @example
 * // rgba.png will be a 4 channel image with a fully-opaque alpha channel
 * await sharp('rgb.jpg')
 *   .ensureAlpha()
 *   .toFile('rgba.png')
 *
 * @example
 * // rgba is a 4 channel image with a fully-transparent alpha channel
 * const rgba = await sharp(rgb)
 *   .ensureAlpha(0)
 *   .toBuffer();
 *
 * @param {number} [alpha=1] - alpha transparency level (0=fully-transparent, 1=fully-opaque)
 * @returns {Sharp}
 * @throws {Error} Invalid alpha transparency level
 */ function ensureAlpha(alpha) {
    if (is.defined(alpha)) {
        if (is.number(alpha) && is.inRange(alpha, 0, 1)) {
            this.options.ensureAlpha = alpha;
        } else {
            throw is.invalidParameterError('alpha', 'number between 0 and 1', alpha);
        }
    } else {
        this.options.ensureAlpha = 1;
    }
    return this;
}
/**
 * Extract a single channel from a multi-channel image.
 *
 * The output colourspace will be either `b-w` (8-bit) or `grey16` (16-bit).
 *
 * @example
 * // green.jpg is a greyscale image containing the green channel of the input
 * await sharp(input)
 *   .extractChannel('green')
 *   .toFile('green.jpg');
 *
 * @example
 * // red1 is the red value of the first pixel, red2 the second pixel etc.
 * const [red1, red2, ...] = await sharp(input)
 *   .extractChannel(0)
 *   .raw()
 *   .toBuffer();
 *
 * @param {number|string} channel - zero-indexed channel/band number to extract, or `red`, `green`, `blue` or `alpha`.
 * @returns {Sharp}
 * @throws {Error} Invalid channel
 */ function extractChannel(channel) {
    const channelMap = {
        red: 0,
        green: 1,
        blue: 2,
        alpha: 3
    };
    if (Object.keys(channelMap).includes(channel)) {
        channel = channelMap[channel];
    }
    if (is.integer(channel) && is.inRange(channel, 0, 4)) {
        this.options.extractChannel = channel;
    } else {
        throw is.invalidParameterError('channel', 'integer or one of: red, green, blue, alpha', channel);
    }
    return this;
}
/**
 * Join one or more channels to the image.
 * The meaning of the added channels depends on the output colourspace, set with `toColourspace()`.
 * By default the output image will be web-friendly sRGB, with additional channels interpreted as alpha channels.
 * Channel ordering follows vips convention:
 * - sRGB: 0: Red, 1: Green, 2: Blue, 3: Alpha.
 * - CMYK: 0: Magenta, 1: Cyan, 2: Yellow, 3: Black, 4: Alpha.
 *
 * Buffers may be any of the image formats supported by sharp.
 * For raw pixel input, the `options` object should contain a `raw` attribute, which follows the format of the attribute of the same name in the `sharp()` constructor.
 *
 * @param {Array<string|Buffer>|string|Buffer} images - one or more images (file paths, Buffers).
 * @param {Object} options - image options, see `sharp()` constructor.
 * @returns {Sharp}
 * @throws {Error} Invalid parameters
 */ function joinChannel(images, options) {
    if (Array.isArray(images)) {
        images.forEach(function(image) {
            this.options.joinChannelIn.push(this._createInputDescriptor(image, options));
        }, this);
    } else {
        this.options.joinChannelIn.push(this._createInputDescriptor(images, options));
    }
    return this;
}
/**
 * Perform a bitwise boolean operation on all input image channels (bands) to produce a single channel output image.
 *
 * @example
 * sharp('3-channel-rgb-input.png')
 *   .bandbool(sharp.bool.and)
 *   .toFile('1-channel-output.png', function (err, info) {
 *     // The output will be a single channel image where each pixel `P = R & G & B`.
 *     // If `I(1,1) = [247, 170, 14] = [0b11110111, 0b10101010, 0b00001111]`
 *     // then `O(1,1) = 0b11110111 & 0b10101010 & 0b00001111 = 0b00000010 = 2`.
 *   });
 *
 * @param {string} boolOp - one of `and`, `or` or `eor` to perform that bitwise operation, like the C logic operators `&`, `|` and `^` respectively.
 * @returns {Sharp}
 * @throws {Error} Invalid parameters
 */ function bandbool(boolOp) {
    if (is.string(boolOp) && is.inArray(boolOp, [
        'and',
        'or',
        'eor'
    ])) {
        this.options.bandBoolOp = boolOp;
    } else {
        throw is.invalidParameterError('boolOp', 'one of: and, or, eor', boolOp);
    }
    return this;
}
/**
 * Decorate the Sharp prototype with channel-related functions.
 * @module Sharp
 * @private
 */ module.exports = (Sharp)=>{
    Object.assign(Sharp.prototype, {
        // Public instance functions
        removeAlpha,
        ensureAlpha,
        extractChannel,
        joinChannel,
        bandbool
    });
    // Class attributes
    Sharp.bool = bool;
};
}),
"[project]/node_modules/next/dist/compiled/path-browserify/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

(function() {
    "use strict";
    var e = {
        114: function(e) {
            function assertPath(e) {
                if (typeof e !== "string") {
                    throw new TypeError("Path must be a string. Received " + JSON.stringify(e));
                }
            }
            function normalizeStringPosix(e, r) {
                var t = "";
                var i = 0;
                var n = -1;
                var a = 0;
                var f;
                for(var l = 0; l <= e.length; ++l){
                    if (l < e.length) f = e.charCodeAt(l);
                    else if (f === 47) break;
                    else f = 47;
                    if (f === 47) {
                        if (n === l - 1 || a === 1) {} else if (n !== l - 1 && a === 2) {
                            if (t.length < 2 || i !== 2 || t.charCodeAt(t.length - 1) !== 46 || t.charCodeAt(t.length - 2) !== 46) {
                                if (t.length > 2) {
                                    var s = t.lastIndexOf("/");
                                    if (s !== t.length - 1) {
                                        if (s === -1) {
                                            t = "";
                                            i = 0;
                                        } else {
                                            t = t.slice(0, s);
                                            i = t.length - 1 - t.lastIndexOf("/");
                                        }
                                        n = l;
                                        a = 0;
                                        continue;
                                    }
                                } else if (t.length === 2 || t.length === 1) {
                                    t = "";
                                    i = 0;
                                    n = l;
                                    a = 0;
                                    continue;
                                }
                            }
                            if (r) {
                                if (t.length > 0) t += "/..";
                                else t = "..";
                                i = 2;
                            }
                        } else {
                            if (t.length > 0) t += "/" + e.slice(n + 1, l);
                            else t = e.slice(n + 1, l);
                            i = l - n - 1;
                        }
                        n = l;
                        a = 0;
                    } else if (f === 46 && a !== -1) {
                        ++a;
                    } else {
                        a = -1;
                    }
                }
                return t;
            }
            function _format(e, r) {
                var t = r.dir || r.root;
                var i = r.base || (r.name || "") + (r.ext || "");
                if (!t) {
                    return i;
                }
                if (t === r.root) {
                    return t + i;
                }
                return t + e + i;
            }
            var r = {
                resolve: function resolve() {
                    var e = "";
                    var r = false;
                    var t;
                    for(var i = arguments.length - 1; i >= -1 && !r; i--){
                        var n;
                        if (i >= 0) n = arguments[i];
                        else {
                            if (t === undefined) t = "";
                            n = t;
                        }
                        assertPath(n);
                        if (n.length === 0) {
                            continue;
                        }
                        e = n + "/" + e;
                        r = n.charCodeAt(0) === 47;
                    }
                    e = normalizeStringPosix(e, !r);
                    if (r) {
                        if (e.length > 0) return "/" + e;
                        else return "/";
                    } else if (e.length > 0) {
                        return e;
                    } else {
                        return ".";
                    }
                },
                normalize: function normalize(e) {
                    assertPath(e);
                    if (e.length === 0) return ".";
                    var r = e.charCodeAt(0) === 47;
                    var t = e.charCodeAt(e.length - 1) === 47;
                    e = normalizeStringPosix(e, !r);
                    if (e.length === 0 && !r) e = ".";
                    if (e.length > 0 && t) e += "/";
                    if (r) return "/" + e;
                    return e;
                },
                isAbsolute: function isAbsolute(e) {
                    assertPath(e);
                    return e.length > 0 && e.charCodeAt(0) === 47;
                },
                join: function join() {
                    if (arguments.length === 0) return ".";
                    var e;
                    for(var t = 0; t < arguments.length; ++t){
                        var i = arguments[t];
                        assertPath(i);
                        if (i.length > 0) {
                            if (e === undefined) e = i;
                            else e += "/" + i;
                        }
                    }
                    if (e === undefined) return ".";
                    return r.normalize(e);
                },
                relative: function relative(e, t) {
                    assertPath(e);
                    assertPath(t);
                    if (e === t) return "";
                    e = r.resolve(e);
                    t = r.resolve(t);
                    if (e === t) return "";
                    var i = 1;
                    for(; i < e.length; ++i){
                        if (e.charCodeAt(i) !== 47) break;
                    }
                    var n = e.length;
                    var a = n - i;
                    var f = 1;
                    for(; f < t.length; ++f){
                        if (t.charCodeAt(f) !== 47) break;
                    }
                    var l = t.length;
                    var s = l - f;
                    var o = a < s ? a : s;
                    var u = -1;
                    var h = 0;
                    for(; h <= o; ++h){
                        if (h === o) {
                            if (s > o) {
                                if (t.charCodeAt(f + h) === 47) {
                                    return t.slice(f + h + 1);
                                } else if (h === 0) {
                                    return t.slice(f + h);
                                }
                            } else if (a > o) {
                                if (e.charCodeAt(i + h) === 47) {
                                    u = h;
                                } else if (h === 0) {
                                    u = 0;
                                }
                            }
                            break;
                        }
                        var c = e.charCodeAt(i + h);
                        var v = t.charCodeAt(f + h);
                        if (c !== v) break;
                        else if (c === 47) u = h;
                    }
                    var g = "";
                    for(h = i + u + 1; h <= n; ++h){
                        if (h === n || e.charCodeAt(h) === 47) {
                            if (g.length === 0) g += "..";
                            else g += "/..";
                        }
                    }
                    if (g.length > 0) return g + t.slice(f + u);
                    else {
                        f += u;
                        if (t.charCodeAt(f) === 47) ++f;
                        return t.slice(f);
                    }
                },
                _makeLong: function _makeLong(e) {
                    return e;
                },
                dirname: function dirname(e) {
                    assertPath(e);
                    if (e.length === 0) return ".";
                    var r = e.charCodeAt(0);
                    var t = r === 47;
                    var i = -1;
                    var n = true;
                    for(var a = e.length - 1; a >= 1; --a){
                        r = e.charCodeAt(a);
                        if (r === 47) {
                            if (!n) {
                                i = a;
                                break;
                            }
                        } else {
                            n = false;
                        }
                    }
                    if (i === -1) return t ? "/" : ".";
                    if (t && i === 1) return "//";
                    return e.slice(0, i);
                },
                basename: function basename(e, r) {
                    if (r !== undefined && typeof r !== "string") throw new TypeError('"ext" argument must be a string');
                    assertPath(e);
                    var t = 0;
                    var i = -1;
                    var n = true;
                    var a;
                    if (r !== undefined && r.length > 0 && r.length <= e.length) {
                        if (r.length === e.length && r === e) return "";
                        var f = r.length - 1;
                        var l = -1;
                        for(a = e.length - 1; a >= 0; --a){
                            var s = e.charCodeAt(a);
                            if (s === 47) {
                                if (!n) {
                                    t = a + 1;
                                    break;
                                }
                            } else {
                                if (l === -1) {
                                    n = false;
                                    l = a + 1;
                                }
                                if (f >= 0) {
                                    if (s === r.charCodeAt(f)) {
                                        if (--f === -1) {
                                            i = a;
                                        }
                                    } else {
                                        f = -1;
                                        i = l;
                                    }
                                }
                            }
                        }
                        if (t === i) i = l;
                        else if (i === -1) i = e.length;
                        return e.slice(t, i);
                    } else {
                        for(a = e.length - 1; a >= 0; --a){
                            if (e.charCodeAt(a) === 47) {
                                if (!n) {
                                    t = a + 1;
                                    break;
                                }
                            } else if (i === -1) {
                                n = false;
                                i = a + 1;
                            }
                        }
                        if (i === -1) return "";
                        return e.slice(t, i);
                    }
                },
                extname: function extname(e) {
                    assertPath(e);
                    var r = -1;
                    var t = 0;
                    var i = -1;
                    var n = true;
                    var a = 0;
                    for(var f = e.length - 1; f >= 0; --f){
                        var l = e.charCodeAt(f);
                        if (l === 47) {
                            if (!n) {
                                t = f + 1;
                                break;
                            }
                            continue;
                        }
                        if (i === -1) {
                            n = false;
                            i = f + 1;
                        }
                        if (l === 46) {
                            if (r === -1) r = f;
                            else if (a !== 1) a = 1;
                        } else if (r !== -1) {
                            a = -1;
                        }
                    }
                    if (r === -1 || i === -1 || a === 0 || a === 1 && r === i - 1 && r === t + 1) {
                        return "";
                    }
                    return e.slice(r, i);
                },
                format: function format(e) {
                    if (e === null || typeof e !== "object") {
                        throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof e);
                    }
                    return _format("/", e);
                },
                parse: function parse(e) {
                    assertPath(e);
                    var r = {
                        root: "",
                        dir: "",
                        base: "",
                        ext: "",
                        name: ""
                    };
                    if (e.length === 0) return r;
                    var t = e.charCodeAt(0);
                    var i = t === 47;
                    var n;
                    if (i) {
                        r.root = "/";
                        n = 1;
                    } else {
                        n = 0;
                    }
                    var a = -1;
                    var f = 0;
                    var l = -1;
                    var s = true;
                    var o = e.length - 1;
                    var u = 0;
                    for(; o >= n; --o){
                        t = e.charCodeAt(o);
                        if (t === 47) {
                            if (!s) {
                                f = o + 1;
                                break;
                            }
                            continue;
                        }
                        if (l === -1) {
                            s = false;
                            l = o + 1;
                        }
                        if (t === 46) {
                            if (a === -1) a = o;
                            else if (u !== 1) u = 1;
                        } else if (a !== -1) {
                            u = -1;
                        }
                    }
                    if (a === -1 || l === -1 || u === 0 || u === 1 && a === l - 1 && a === f + 1) {
                        if (l !== -1) {
                            if (f === 0 && i) r.base = r.name = e.slice(1, l);
                            else r.base = r.name = e.slice(f, l);
                        }
                    } else {
                        if (f === 0 && i) {
                            r.name = e.slice(1, a);
                            r.base = e.slice(1, l);
                        } else {
                            r.name = e.slice(f, a);
                            r.base = e.slice(f, l);
                        }
                        r.ext = e.slice(a, l);
                    }
                    if (f > 0) r.dir = e.slice(0, f - 1);
                    else if (i) r.dir = "/";
                    return r;
                },
                sep: "/",
                delimiter: ":",
                win32: null,
                posix: null
            };
            r.posix = r;
            e.exports = r;
        }
    };
    var r = {};
    function __nccwpck_require__(t) {
        var i = r[t];
        if (i !== undefined) {
            return i.exports;
        }
        var n = r[t] = {
            exports: {}
        };
        var a = true;
        try {
            e[t](n, n.exports, __nccwpck_require__);
            a = false;
        } finally{
            if (a) delete r[t];
        }
        return n.exports;
    }
    if (typeof __nccwpck_require__ !== "undefined") __nccwpck_require__.ab = ("TURBOPACK compile-time value", "/ROOT/node_modules/next/dist/compiled/path-browserify") + "/";
    var t = __nccwpck_require__(114);
    module.exports = t;
})();
}),
"[project]/node_modules/sharp/lib/output.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

/*!
  Copyright 2013 Lovell Fuller and others.
  SPDX-License-Identifier: Apache-2.0
*/ const path = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/path-browserify/index.js [app-client] (ecmascript)");
const is = __turbopack_context__.r("[project]/node_modules/sharp/lib/is.js [app-client] (ecmascript)");
const sharp = __turbopack_context__.r("[project]/node_modules/sharp/lib/sharp.js [app-client] (ecmascript)");
const formats = new Map([
    [
        'heic',
        'heif'
    ],
    [
        'heif',
        'heif'
    ],
    [
        'avif',
        'avif'
    ],
    [
        'jpeg',
        'jpeg'
    ],
    [
        'jpg',
        'jpeg'
    ],
    [
        'jpe',
        'jpeg'
    ],
    [
        'tile',
        'tile'
    ],
    [
        'dz',
        'tile'
    ],
    [
        'png',
        'png'
    ],
    [
        'raw',
        'raw'
    ],
    [
        'tiff',
        'tiff'
    ],
    [
        'tif',
        'tiff'
    ],
    [
        'webp',
        'webp'
    ],
    [
        'gif',
        'gif'
    ],
    [
        'jp2',
        'jp2'
    ],
    [
        'jpx',
        'jp2'
    ],
    [
        'j2k',
        'jp2'
    ],
    [
        'j2c',
        'jp2'
    ],
    [
        'jxl',
        'jxl'
    ]
]);
const jp2Regex = /\.(jp[2x]|j2[kc])$/i;
const errJp2Save = ()=>new Error('JP2 output requires libvips with support for OpenJPEG');
const bitdepthFromColourCount = (colours)=>1 << 31 - Math.clz32(Math.ceil(Math.log2(colours)));
/**
 * Write output image data to a file.
 *
 * If an explicit output format is not selected, it will be inferred from the extension,
 * with JPEG, PNG, WebP, AVIF, TIFF, GIF, DZI, and libvips' V format supported.
 * Note that raw pixel data is only supported for buffer output.
 *
 * By default all metadata will be removed, which includes EXIF-based orientation.
 * See {@link #withmetadata withMetadata} for control over this.
 *
 * The caller is responsible for ensuring directory structures and permissions exist.
 *
 * A `Promise` is returned when `callback` is not provided.
 *
 * @example
 * sharp(input)
 *   .toFile('output.png', (err, info) => { ... });
 *
 * @example
 * sharp(input)
 *   .toFile('output.png')
 *   .then(info => { ... })
 *   .catch(err => { ... });
 *
 * @param {string} fileOut - the path to write the image data to.
 * @param {Function} [callback] - called on completion with two arguments `(err, info)`.
 * `info` contains the output image `format`, `size` (bytes), `width`, `height`,
 * `channels` and `premultiplied` (indicating if premultiplication was used).
 * When using a crop strategy also contains `cropOffsetLeft` and `cropOffsetTop`.
 * When using the attention crop strategy also contains `attentionX` and `attentionY`, the focal point of the cropped region.
 * Animated output will also contain `pageHeight` and `pages`.
 * May also contain `textAutofitDpi` (dpi the font was rendered at) if image was created from text.
 * @returns {Promise<Object>} - when no callback is provided
 * @throws {Error} Invalid parameters
 */ function toFile(fileOut, callback) {
    let err;
    if (!is.string(fileOut)) {
        err = new Error('Missing output file path');
    } else if (is.string(this.options.input.file) && path.resolve(this.options.input.file) === path.resolve(fileOut)) {
        err = new Error('Cannot use same file for input and output');
    } else if (jp2Regex.test(path.extname(fileOut)) && !this.constructor.format.jp2k.output.file) {
        err = errJp2Save();
    }
    if (err) {
        if (is.fn(callback)) {
            callback(err);
        } else {
            return Promise.reject(err);
        }
    } else {
        this.options.fileOut = fileOut;
        const stack = Error();
        return this._pipeline(callback, stack);
    }
    return this;
}
/**
 * Write output to a Buffer.
 * JPEG, PNG, WebP, AVIF, TIFF, GIF and raw pixel data output are supported.
 *
 * Use {@link #toformat toFormat} or one of the format-specific functions such as {@link #jpeg jpeg}, {@link #png png} etc. to set the output format.
 *
 * If no explicit format is set, the output format will match the input image, except SVG input which becomes PNG output.
 *
 * By default all metadata will be removed, which includes EXIF-based orientation.
 * See {@link #withmetadata withMetadata} for control over this.
 *
 * `callback`, if present, gets three arguments `(err, data, info)` where:
 * - `err` is an error, if any.
 * - `data` is the output image data.
 * - `info` contains the output image `format`, `size` (bytes), `width`, `height`,
 * `channels` and `premultiplied` (indicating if premultiplication was used).
 * When using a crop strategy also contains `cropOffsetLeft` and `cropOffsetTop`.
 * Animated output will also contain `pageHeight` and `pages`.
 * May also contain `textAutofitDpi` (dpi the font was rendered at) if image was created from text.
 *
 * A `Promise` is returned when `callback` is not provided.
 *
 * @example
 * sharp(input)
 *   .toBuffer((err, data, info) => { ... });
 *
 * @example
 * sharp(input)
 *   .toBuffer()
 *   .then(data => { ... })
 *   .catch(err => { ... });
 *
 * @example
 * sharp(input)
 *   .png()
 *   .toBuffer({ resolveWithObject: true })
 *   .then(({ data, info }) => { ... })
 *   .catch(err => { ... });
 *
 * @example
 * const { data, info } = await sharp('my-image.jpg')
 *   // output the raw pixels
 *   .raw()
 *   .toBuffer({ resolveWithObject: true });
 *
 * // create a more type safe way to work with the raw pixel data
 * // this will not copy the data, instead it will change `data`s underlying ArrayBuffer
 * // so `data` and `pixelArray` point to the same memory location
 * const pixelArray = new Uint8ClampedArray(data.buffer);
 *
 * // When you are done changing the pixelArray, sharp takes the `pixelArray` as an input
 * const { width, height, channels } = info;
 * await sharp(pixelArray, { raw: { width, height, channels } })
 *   .toFile('my-changed-image.jpg');
 *
 * @param {Object} [options]
 * @param {boolean} [options.resolveWithObject] Resolve the Promise with an Object containing `data` and `info` properties instead of resolving only with `data`.
 * @param {Function} [callback]
 * @returns {Promise<Buffer>} - when no callback is provided
 */ function toBuffer(options, callback) {
    if (is.object(options)) {
        this._setBooleanOption('resolveWithObject', options.resolveWithObject);
    } else if (this.options.resolveWithObject) {
        this.options.resolveWithObject = false;
    }
    this.options.fileOut = '';
    const stack = Error();
    return this._pipeline(is.fn(options) ? options : callback, stack);
}
/**
 * Keep all EXIF metadata from the input image in the output image.
 *
 * EXIF metadata is unsupported for TIFF output.
 *
 * @since 0.33.0
 *
 * @example
 * const outputWithExif = await sharp(inputWithExif)
 *   .keepExif()
 *   .toBuffer();
 *
 * @returns {Sharp}
 */ function keepExif() {
    this.options.keepMetadata |= 0b00001;
    return this;
}
/**
 * Set EXIF metadata in the output image, ignoring any EXIF in the input image.
 *
 * @since 0.33.0
 *
 * @example
 * const dataWithExif = await sharp(input)
 *   .withExif({
 *     IFD0: {
 *       Copyright: 'The National Gallery'
 *     },
 *     IFD3: {
 *       GPSLatitudeRef: 'N',
 *       GPSLatitude: '51/1 30/1 3230/100',
 *       GPSLongitudeRef: 'W',
 *       GPSLongitude: '0/1 7/1 4366/100'
 *     }
 *   })
 *   .toBuffer();
 *
 * @param {Object<string, Object<string, string>>} exif Object keyed by IFD0, IFD1 etc. of key/value string pairs to write as EXIF data.
 * @returns {Sharp}
 * @throws {Error} Invalid parameters
 */ function withExif(exif) {
    if (is.object(exif)) {
        for (const [ifd, entries] of Object.entries(exif)){
            if (is.object(entries)) {
                for (const [k, v] of Object.entries(entries)){
                    if (is.string(v)) {
                        this.options.withExif[`exif-${ifd.toLowerCase()}-${k}`] = v;
                    } else {
                        throw is.invalidParameterError(`${ifd}.${k}`, 'string', v);
                    }
                }
            } else {
                throw is.invalidParameterError(ifd, 'object', entries);
            }
        }
    } else {
        throw is.invalidParameterError('exif', 'object', exif);
    }
    this.options.withExifMerge = false;
    return this.keepExif();
}
/**
 * Update EXIF metadata from the input image in the output image.
 *
 * @since 0.33.0
 *
 * @example
 * const dataWithMergedExif = await sharp(inputWithExif)
 *   .withExifMerge({
 *     IFD0: {
 *       Copyright: 'The National Gallery'
 *     }
 *   })
 *   .toBuffer();
 *
 * @param {Object<string, Object<string, string>>} exif Object keyed by IFD0, IFD1 etc. of key/value string pairs to write as EXIF data.
 * @returns {Sharp}
 * @throws {Error} Invalid parameters
 */ function withExifMerge(exif) {
    this.withExif(exif);
    this.options.withExifMerge = true;
    return this;
}
/**
 * Keep ICC profile from the input image in the output image.
 *
 * When input and output colour spaces differ, use with {@link /api-colour/#tocolourspace toColourspace} and optionally {@link /api-colour/#pipelinecolourspace pipelineColourspace}.
 *
 * @since 0.33.0
 *
 * @example
 * const outputWithIccProfile = await sharp(inputWithIccProfile)
 *   .keepIccProfile()
 *   .toBuffer();
 *
 * @example
 * const cmykOutputWithIccProfile = await sharp(cmykInputWithIccProfile)
 *   .pipelineColourspace('cmyk')
 *   .toColourspace('cmyk')
 *   .keepIccProfile()
 *   .toBuffer();
 *
 * @returns {Sharp}
 */ function keepIccProfile() {
    this.options.keepMetadata |= 0b01000;
    return this;
}
/**
 * Transform using an ICC profile and attach to the output image.
 *
 * This can either be an absolute filesystem path or
 * built-in profile name (`srgb`, `p3`, `cmyk`).
 *
 * @since 0.33.0
 *
 * @example
 * const outputWithP3 = await sharp(input)
 *   .withIccProfile('p3')
 *   .toBuffer();
 *
 * @param {string} icc - Absolute filesystem path to output ICC profile or built-in profile name (srgb, p3, cmyk).
 * @param {Object} [options]
 * @param {number} [options.attach=true] Should the ICC profile be included in the output image metadata?
 * @returns {Sharp}
 * @throws {Error} Invalid parameters
 */ function withIccProfile(icc, options) {
    if (is.string(icc)) {
        this.options.withIccProfile = icc;
    } else {
        throw is.invalidParameterError('icc', 'string', icc);
    }
    this.keepIccProfile();
    if (is.object(options)) {
        if (is.defined(options.attach)) {
            if (is.bool(options.attach)) {
                if (!options.attach) {
                    this.options.keepMetadata &= ~0b01000;
                }
            } else {
                throw is.invalidParameterError('attach', 'boolean', options.attach);
            }
        }
    }
    return this;
}
/**
 * Keep XMP metadata from the input image in the output image.
 *
 * @since 0.34.3
 *
 * @example
 * const outputWithXmp = await sharp(inputWithXmp)
 *   .keepXmp()
 *   .toBuffer();
 *
 * @returns {Sharp}
 */ function keepXmp() {
    this.options.keepMetadata |= 0b00010;
    return this;
}
/**
 * Set XMP metadata in the output image.
 *
 * Supported by PNG, JPEG, WebP, and TIFF output.
 *
 * @since 0.34.3
 *
 * @example
 * const xmpString = `
 *   <?xml version="1.0"?>
 *   <x:xmpmeta xmlns:x="adobe:ns:meta/">
 *     <rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">
 *       <rdf:Description rdf:about="" xmlns:dc="http://purl.org/dc/elements/1.1/">
 *         <dc:creator><rdf:Seq><rdf:li>John Doe</rdf:li></rdf:Seq></dc:creator>
 *       </rdf:Description>
 *     </rdf:RDF>
 *   </x:xmpmeta>`;
 *
 * const data = await sharp(input)
 *   .withXmp(xmpString)
 *   .toBuffer();
 *
 * @param {string} xmp String containing XMP metadata to be embedded in the output image.
 * @returns {Sharp}
 * @throws {Error} Invalid parameters
 */ function withXmp(xmp) {
    if (is.string(xmp) && xmp.length > 0) {
        this.options.withXmp = xmp;
        this.options.keepMetadata |= 0b00010;
    } else {
        throw is.invalidParameterError('xmp', 'non-empty string', xmp);
    }
    return this;
}
/**
 * Keep all metadata (EXIF, ICC, XMP, IPTC) from the input image in the output image.
 *
 * The default behaviour, when `keepMetadata` is not used, is to convert to the device-independent
 * sRGB colour space and strip all metadata, including the removal of any ICC profile.
 *
 * @since 0.33.0
 *
 * @example
 * const outputWithMetadata = await sharp(inputWithMetadata)
 *   .keepMetadata()
 *   .toBuffer();
 *
 * @returns {Sharp}
 */ function keepMetadata() {
    this.options.keepMetadata = 0b11111;
    return this;
}
/**
 * Keep most metadata (EXIF, XMP, IPTC) from the input image in the output image.
 *
 * This will also convert to and add a web-friendly sRGB ICC profile if appropriate.
 *
 * Allows orientation and density to be set or updated.
 *
 * @example
 * const outputSrgbWithMetadata = await sharp(inputRgbWithMetadata)
 *   .withMetadata()
 *   .toBuffer();
 *
 * @example
 * // Set output metadata to 96 DPI
 * const data = await sharp(input)
 *   .withMetadata({ density: 96 })
 *   .toBuffer();
 *
 * @param {Object} [options]
 * @param {number} [options.orientation] Used to update the EXIF `Orientation` tag, integer between 1 and 8.
 * @param {number} [options.density] Number of pixels per inch (DPI).
 * @returns {Sharp}
 * @throws {Error} Invalid parameters
 */ function withMetadata(options) {
    this.keepMetadata();
    this.withIccProfile('srgb');
    if (is.object(options)) {
        if (is.defined(options.orientation)) {
            if (is.integer(options.orientation) && is.inRange(options.orientation, 1, 8)) {
                this.options.withMetadataOrientation = options.orientation;
            } else {
                throw is.invalidParameterError('orientation', 'integer between 1 and 8', options.orientation);
            }
        }
        if (is.defined(options.density)) {
            if (is.number(options.density) && options.density > 0) {
                this.options.withMetadataDensity = options.density;
            } else {
                throw is.invalidParameterError('density', 'positive number', options.density);
            }
        }
        if (is.defined(options.icc)) {
            this.withIccProfile(options.icc);
        }
        if (is.defined(options.exif)) {
            this.withExifMerge(options.exif);
        }
    }
    return this;
}
/**
 * Force output to a given format.
 *
 * @example
 * // Convert any input to PNG output
 * const data = await sharp(input)
 *   .toFormat('png')
 *   .toBuffer();
 *
 * @param {(string|Object)} format - as a string or an Object with an 'id' attribute
 * @param {Object} options - output options
 * @returns {Sharp}
 * @throws {Error} unsupported format or options
 */ function toFormat(format, options) {
    const actualFormat = formats.get((is.object(format) && is.string(format.id) ? format.id : format).toLowerCase());
    if (!actualFormat) {
        throw is.invalidParameterError('format', `one of: ${[
            ...formats.keys()
        ].join(', ')}`, format);
    }
    return this[actualFormat](options);
}
/**
 * Use these JPEG options for output image.
 *
 * @example
 * // Convert any input to very high quality JPEG output
 * const data = await sharp(input)
 *   .jpeg({
 *     quality: 100,
 *     chromaSubsampling: '4:4:4'
 *   })
 *   .toBuffer();
 *
 * @example
 * // Use mozjpeg to reduce output JPEG file size (slower)
 * const data = await sharp(input)
 *   .jpeg({ mozjpeg: true })
 *   .toBuffer();
 *
 * @param {Object} [options] - output options
 * @param {number} [options.quality=80] - quality, integer 1-100
 * @param {boolean} [options.progressive=false] - use progressive (interlace) scan
 * @param {string} [options.chromaSubsampling='4:2:0'] - set to '4:4:4' to prevent chroma subsampling otherwise defaults to '4:2:0' chroma subsampling
 * @param {boolean} [options.optimiseCoding=true] - optimise Huffman coding tables
 * @param {boolean} [options.optimizeCoding=true] - alternative spelling of optimiseCoding
 * @param {boolean} [options.mozjpeg=false] - use mozjpeg defaults, equivalent to `{ trellisQuantisation: true, overshootDeringing: true, optimiseScans: true, quantisationTable: 3 }`
 * @param {boolean} [options.trellisQuantisation=false] - apply trellis quantisation
 * @param {boolean} [options.overshootDeringing=false] - apply overshoot deringing
 * @param {boolean} [options.optimiseScans=false] - optimise progressive scans, forces progressive
 * @param {boolean} [options.optimizeScans=false] - alternative spelling of optimiseScans
 * @param {number} [options.quantisationTable=0] - quantization table to use, integer 0-8
 * @param {number} [options.quantizationTable=0] - alternative spelling of quantisationTable
 * @param {boolean} [options.force=true] - force JPEG output, otherwise attempt to use input format
 * @returns {Sharp}
 * @throws {Error} Invalid options
 */ function jpeg(options) {
    if (is.object(options)) {
        if (is.defined(options.quality)) {
            if (is.integer(options.quality) && is.inRange(options.quality, 1, 100)) {
                this.options.jpegQuality = options.quality;
            } else {
                throw is.invalidParameterError('quality', 'integer between 1 and 100', options.quality);
            }
        }
        if (is.defined(options.progressive)) {
            this._setBooleanOption('jpegProgressive', options.progressive);
        }
        if (is.defined(options.chromaSubsampling)) {
            if (is.string(options.chromaSubsampling) && is.inArray(options.chromaSubsampling, [
                '4:2:0',
                '4:4:4'
            ])) {
                this.options.jpegChromaSubsampling = options.chromaSubsampling;
            } else {
                throw is.invalidParameterError('chromaSubsampling', 'one of: 4:2:0, 4:4:4', options.chromaSubsampling);
            }
        }
        const optimiseCoding = is.bool(options.optimizeCoding) ? options.optimizeCoding : options.optimiseCoding;
        if (is.defined(optimiseCoding)) {
            this._setBooleanOption('jpegOptimiseCoding', optimiseCoding);
        }
        if (is.defined(options.mozjpeg)) {
            if (is.bool(options.mozjpeg)) {
                if (options.mozjpeg) {
                    this.options.jpegTrellisQuantisation = true;
                    this.options.jpegOvershootDeringing = true;
                    this.options.jpegOptimiseScans = true;
                    this.options.jpegProgressive = true;
                    this.options.jpegQuantisationTable = 3;
                }
            } else {
                throw is.invalidParameterError('mozjpeg', 'boolean', options.mozjpeg);
            }
        }
        const trellisQuantisation = is.bool(options.trellisQuantization) ? options.trellisQuantization : options.trellisQuantisation;
        if (is.defined(trellisQuantisation)) {
            this._setBooleanOption('jpegTrellisQuantisation', trellisQuantisation);
        }
        if (is.defined(options.overshootDeringing)) {
            this._setBooleanOption('jpegOvershootDeringing', options.overshootDeringing);
        }
        const optimiseScans = is.bool(options.optimizeScans) ? options.optimizeScans : options.optimiseScans;
        if (is.defined(optimiseScans)) {
            this._setBooleanOption('jpegOptimiseScans', optimiseScans);
            if (optimiseScans) {
                this.options.jpegProgressive = true;
            }
        }
        const quantisationTable = is.number(options.quantizationTable) ? options.quantizationTable : options.quantisationTable;
        if (is.defined(quantisationTable)) {
            if (is.integer(quantisationTable) && is.inRange(quantisationTable, 0, 8)) {
                this.options.jpegQuantisationTable = quantisationTable;
            } else {
                throw is.invalidParameterError('quantisationTable', 'integer between 0 and 8', quantisationTable);
            }
        }
    }
    return this._updateFormatOut('jpeg', options);
}
/**
 * Use these PNG options for output image.
 *
 * By default, PNG output is full colour at 8 bits per pixel.
 *
 * Indexed PNG input at 1, 2 or 4 bits per pixel is converted to 8 bits per pixel.
 * Set `palette` to `true` for slower, indexed PNG output.
 *
 * For 16 bits per pixel output, convert to `rgb16` via
 * {@link /api-colour/#tocolourspace toColourspace}.
 *
 * @example
 * // Convert any input to full colour PNG output
 * const data = await sharp(input)
 *   .png()
 *   .toBuffer();
 *
 * @example
 * // Convert any input to indexed PNG output (slower)
 * const data = await sharp(input)
 *   .png({ palette: true })
 *   .toBuffer();
 *
 * @example
 * // Output 16 bits per pixel RGB(A)
 * const data = await sharp(input)
 *  .toColourspace('rgb16')
 *  .png()
 *  .toBuffer();
 *
 * @param {Object} [options]
 * @param {boolean} [options.progressive=false] - use progressive (interlace) scan
 * @param {number} [options.compressionLevel=6] - zlib compression level, 0 (fastest, largest) to 9 (slowest, smallest)
 * @param {boolean} [options.adaptiveFiltering=false] - use adaptive row filtering
 * @param {boolean} [options.palette=false] - quantise to a palette-based image with alpha transparency support
 * @param {number} [options.quality=100] - use the lowest number of colours needed to achieve given quality, sets `palette` to `true`
 * @param {number} [options.effort=7] - CPU effort, between 1 (fastest) and 10 (slowest), sets `palette` to `true`
 * @param {number} [options.colours=256] - maximum number of palette entries, sets `palette` to `true`
 * @param {number} [options.colors=256] - alternative spelling of `options.colours`, sets `palette` to `true`
 * @param {number} [options.dither=1.0] - level of Floyd-Steinberg error diffusion, sets `palette` to `true`
 * @param {boolean} [options.force=true] - force PNG output, otherwise attempt to use input format
 * @returns {Sharp}
 * @throws {Error} Invalid options
 */ function png(options) {
    if (is.object(options)) {
        if (is.defined(options.progressive)) {
            this._setBooleanOption('pngProgressive', options.progressive);
        }
        if (is.defined(options.compressionLevel)) {
            if (is.integer(options.compressionLevel) && is.inRange(options.compressionLevel, 0, 9)) {
                this.options.pngCompressionLevel = options.compressionLevel;
            } else {
                throw is.invalidParameterError('compressionLevel', 'integer between 0 and 9', options.compressionLevel);
            }
        }
        if (is.defined(options.adaptiveFiltering)) {
            this._setBooleanOption('pngAdaptiveFiltering', options.adaptiveFiltering);
        }
        const colours = options.colours || options.colors;
        if (is.defined(colours)) {
            if (is.integer(colours) && is.inRange(colours, 2, 256)) {
                this.options.pngBitdepth = bitdepthFromColourCount(colours);
            } else {
                throw is.invalidParameterError('colours', 'integer between 2 and 256', colours);
            }
        }
        if (is.defined(options.palette)) {
            this._setBooleanOption('pngPalette', options.palette);
        } else if ([
            options.quality,
            options.effort,
            options.colours,
            options.colors,
            options.dither
        ].some(is.defined)) {
            this._setBooleanOption('pngPalette', true);
        }
        if (this.options.pngPalette) {
            if (is.defined(options.quality)) {
                if (is.integer(options.quality) && is.inRange(options.quality, 0, 100)) {
                    this.options.pngQuality = options.quality;
                } else {
                    throw is.invalidParameterError('quality', 'integer between 0 and 100', options.quality);
                }
            }
            if (is.defined(options.effort)) {
                if (is.integer(options.effort) && is.inRange(options.effort, 1, 10)) {
                    this.options.pngEffort = options.effort;
                } else {
                    throw is.invalidParameterError('effort', 'integer between 1 and 10', options.effort);
                }
            }
            if (is.defined(options.dither)) {
                if (is.number(options.dither) && is.inRange(options.dither, 0, 1)) {
                    this.options.pngDither = options.dither;
                } else {
                    throw is.invalidParameterError('dither', 'number between 0.0 and 1.0', options.dither);
                }
            }
        }
    }
    return this._updateFormatOut('png', options);
}
/**
 * Use these WebP options for output image.
 *
 * @example
 * // Convert any input to lossless WebP output
 * const data = await sharp(input)
 *   .webp({ lossless: true })
 *   .toBuffer();
 *
 * @example
 * // Optimise the file size of an animated WebP
 * const outputWebp = await sharp(inputWebp, { animated: true })
 *   .webp({ effort: 6 })
 *   .toBuffer();
 *
 * @param {Object} [options] - output options
 * @param {number} [options.quality=80] - quality, integer 1-100
 * @param {number} [options.alphaQuality=100] - quality of alpha layer, integer 0-100
 * @param {boolean} [options.lossless=false] - use lossless compression mode
 * @param {boolean} [options.nearLossless=false] - use near_lossless compression mode
 * @param {boolean} [options.smartSubsample=false] - use high quality chroma subsampling
 * @param {boolean} [options.smartDeblock=false] - auto-adjust the deblocking filter, can improve low contrast edges (slow)
 * @param {string} [options.preset='default'] - named preset for preprocessing/filtering, one of: default, photo, picture, drawing, icon, text
 * @param {number} [options.effort=4] - CPU effort, between 0 (fastest) and 6 (slowest)
 * @param {number} [options.loop=0] - number of animation iterations, use 0 for infinite animation
 * @param {number|number[]} [options.delay] - delay(s) between animation frames (in milliseconds)
 * @param {boolean} [options.minSize=false] - prevent use of animation key frames to minimise file size (slow)
 * @param {boolean} [options.mixed=false] - allow mixture of lossy and lossless animation frames (slow)
 * @param {boolean} [options.force=true] - force WebP output, otherwise attempt to use input format
 * @returns {Sharp}
 * @throws {Error} Invalid options
 */ function webp(options) {
    if (is.object(options)) {
        if (is.defined(options.quality)) {
            if (is.integer(options.quality) && is.inRange(options.quality, 1, 100)) {
                this.options.webpQuality = options.quality;
            } else {
                throw is.invalidParameterError('quality', 'integer between 1 and 100', options.quality);
            }
        }
        if (is.defined(options.alphaQuality)) {
            if (is.integer(options.alphaQuality) && is.inRange(options.alphaQuality, 0, 100)) {
                this.options.webpAlphaQuality = options.alphaQuality;
            } else {
                throw is.invalidParameterError('alphaQuality', 'integer between 0 and 100', options.alphaQuality);
            }
        }
        if (is.defined(options.lossless)) {
            this._setBooleanOption('webpLossless', options.lossless);
        }
        if (is.defined(options.nearLossless)) {
            this._setBooleanOption('webpNearLossless', options.nearLossless);
        }
        if (is.defined(options.smartSubsample)) {
            this._setBooleanOption('webpSmartSubsample', options.smartSubsample);
        }
        if (is.defined(options.smartDeblock)) {
            this._setBooleanOption('webpSmartDeblock', options.smartDeblock);
        }
        if (is.defined(options.preset)) {
            if (is.string(options.preset) && is.inArray(options.preset, [
                'default',
                'photo',
                'picture',
                'drawing',
                'icon',
                'text'
            ])) {
                this.options.webpPreset = options.preset;
            } else {
                throw is.invalidParameterError('preset', 'one of: default, photo, picture, drawing, icon, text', options.preset);
            }
        }
        if (is.defined(options.effort)) {
            if (is.integer(options.effort) && is.inRange(options.effort, 0, 6)) {
                this.options.webpEffort = options.effort;
            } else {
                throw is.invalidParameterError('effort', 'integer between 0 and 6', options.effort);
            }
        }
        if (is.defined(options.minSize)) {
            this._setBooleanOption('webpMinSize', options.minSize);
        }
        if (is.defined(options.mixed)) {
            this._setBooleanOption('webpMixed', options.mixed);
        }
    }
    trySetAnimationOptions(options, this.options);
    return this._updateFormatOut('webp', options);
}
/**
 * Use these GIF options for the output image.
 *
 * The first entry in the palette is reserved for transparency.
 *
 * The palette of the input image will be re-used if possible.
 *
 * @since 0.30.0
 *
 * @example
 * // Convert PNG to GIF
 * await sharp(pngBuffer)
 *   .gif()
 *   .toBuffer();
 *
 * @example
 * // Convert animated WebP to animated GIF
 * await sharp('animated.webp', { animated: true })
 *   .toFile('animated.gif');
 *
 * @example
 * // Create a 128x128, cropped, non-dithered, animated thumbnail of an animated GIF
 * const out = await sharp('in.gif', { animated: true })
 *   .resize({ width: 128, height: 128 })
 *   .gif({ dither: 0 })
 *   .toBuffer();
 *
 * @example
 * // Lossy file size reduction of animated GIF
 * await sharp('in.gif', { animated: true })
 *   .gif({ interFrameMaxError: 8 })
 *   .toFile('optim.gif');
 *
 * @param {Object} [options] - output options
 * @param {boolean} [options.reuse=true] - re-use existing palette, otherwise generate new (slow)
 * @param {boolean} [options.progressive=false] - use progressive (interlace) scan
 * @param {number} [options.colours=256] - maximum number of palette entries, including transparency, between 2 and 256
 * @param {number} [options.colors=256] - alternative spelling of `options.colours`
 * @param {number} [options.effort=7] - CPU effort, between 1 (fastest) and 10 (slowest)
 * @param {number} [options.dither=1.0] - level of Floyd-Steinberg error diffusion, between 0 (least) and 1 (most)
 * @param {number} [options.interFrameMaxError=0] - maximum inter-frame error for transparency, between 0 (lossless) and 32
 * @param {number} [options.interPaletteMaxError=3] - maximum inter-palette error for palette reuse, between 0 and 256
 * @param {boolean} [options.keepDuplicateFrames=false] - keep duplicate frames in the output instead of combining them
 * @param {number} [options.loop=0] - number of animation iterations, use 0 for infinite animation
 * @param {number|number[]} [options.delay] - delay(s) between animation frames (in milliseconds)
 * @param {boolean} [options.force=true] - force GIF output, otherwise attempt to use input format
 * @returns {Sharp}
 * @throws {Error} Invalid options
 */ function gif(options) {
    if (is.object(options)) {
        if (is.defined(options.reuse)) {
            this._setBooleanOption('gifReuse', options.reuse);
        }
        if (is.defined(options.progressive)) {
            this._setBooleanOption('gifProgressive', options.progressive);
        }
        const colours = options.colours || options.colors;
        if (is.defined(colours)) {
            if (is.integer(colours) && is.inRange(colours, 2, 256)) {
                this.options.gifBitdepth = bitdepthFromColourCount(colours);
            } else {
                throw is.invalidParameterError('colours', 'integer between 2 and 256', colours);
            }
        }
        if (is.defined(options.effort)) {
            if (is.number(options.effort) && is.inRange(options.effort, 1, 10)) {
                this.options.gifEffort = options.effort;
            } else {
                throw is.invalidParameterError('effort', 'integer between 1 and 10', options.effort);
            }
        }
        if (is.defined(options.dither)) {
            if (is.number(options.dither) && is.inRange(options.dither, 0, 1)) {
                this.options.gifDither = options.dither;
            } else {
                throw is.invalidParameterError('dither', 'number between 0.0 and 1.0', options.dither);
            }
        }
        if (is.defined(options.interFrameMaxError)) {
            if (is.number(options.interFrameMaxError) && is.inRange(options.interFrameMaxError, 0, 32)) {
                this.options.gifInterFrameMaxError = options.interFrameMaxError;
            } else {
                throw is.invalidParameterError('interFrameMaxError', 'number between 0.0 and 32.0', options.interFrameMaxError);
            }
        }
        if (is.defined(options.interPaletteMaxError)) {
            if (is.number(options.interPaletteMaxError) && is.inRange(options.interPaletteMaxError, 0, 256)) {
                this.options.gifInterPaletteMaxError = options.interPaletteMaxError;
            } else {
                throw is.invalidParameterError('interPaletteMaxError', 'number between 0.0 and 256.0', options.interPaletteMaxError);
            }
        }
        if (is.defined(options.keepDuplicateFrames)) {
            if (is.bool(options.keepDuplicateFrames)) {
                this._setBooleanOption('gifKeepDuplicateFrames', options.keepDuplicateFrames);
            } else {
                throw is.invalidParameterError('keepDuplicateFrames', 'boolean', options.keepDuplicateFrames);
            }
        }
    }
    trySetAnimationOptions(options, this.options);
    return this._updateFormatOut('gif', options);
}
/**
 * Use these JP2 options for output image.
 *
 * Requires libvips compiled with support for OpenJPEG.
 * The prebuilt binaries do not include this - see
 * {@link /install#custom-libvips installing a custom libvips}.
 *
 * @example
 * // Convert any input to lossless JP2 output
 * const data = await sharp(input)
 *   .jp2({ lossless: true })
 *   .toBuffer();
 *
 * @example
 * // Convert any input to very high quality JP2 output
 * const data = await sharp(input)
 *   .jp2({
 *     quality: 100,
 *     chromaSubsampling: '4:4:4'
 *   })
 *   .toBuffer();
 *
 * @since 0.29.1
 *
 * @param {Object} [options] - output options
 * @param {number} [options.quality=80] - quality, integer 1-100
 * @param {boolean} [options.lossless=false] - use lossless compression mode
 * @param {number} [options.tileWidth=512] - horizontal tile size
 * @param {number} [options.tileHeight=512] - vertical tile size
 * @param {string} [options.chromaSubsampling='4:4:4'] - set to '4:2:0' to use chroma subsampling
 * @returns {Sharp}
 * @throws {Error} Invalid options
 */ function jp2(options) {
    /* node:coverage ignore next 41 */ if (!this.constructor.format.jp2k.output.buffer) {
        throw errJp2Save();
    }
    if (is.object(options)) {
        if (is.defined(options.quality)) {
            if (is.integer(options.quality) && is.inRange(options.quality, 1, 100)) {
                this.options.jp2Quality = options.quality;
            } else {
                throw is.invalidParameterError('quality', 'integer between 1 and 100', options.quality);
            }
        }
        if (is.defined(options.lossless)) {
            if (is.bool(options.lossless)) {
                this.options.jp2Lossless = options.lossless;
            } else {
                throw is.invalidParameterError('lossless', 'boolean', options.lossless);
            }
        }
        if (is.defined(options.tileWidth)) {
            if (is.integer(options.tileWidth) && is.inRange(options.tileWidth, 1, 32768)) {
                this.options.jp2TileWidth = options.tileWidth;
            } else {
                throw is.invalidParameterError('tileWidth', 'integer between 1 and 32768', options.tileWidth);
            }
        }
        if (is.defined(options.tileHeight)) {
            if (is.integer(options.tileHeight) && is.inRange(options.tileHeight, 1, 32768)) {
                this.options.jp2TileHeight = options.tileHeight;
            } else {
                throw is.invalidParameterError('tileHeight', 'integer between 1 and 32768', options.tileHeight);
            }
        }
        if (is.defined(options.chromaSubsampling)) {
            if (is.string(options.chromaSubsampling) && is.inArray(options.chromaSubsampling, [
                '4:2:0',
                '4:4:4'
            ])) {
                this.options.jp2ChromaSubsampling = options.chromaSubsampling;
            } else {
                throw is.invalidParameterError('chromaSubsampling', 'one of: 4:2:0, 4:4:4', options.chromaSubsampling);
            }
        }
    }
    return this._updateFormatOut('jp2', options);
}
/**
 * Set animation options if available.
 * @private
 *
 * @param {Object} [source] - output options
 * @param {number} [source.loop=0] - number of animation iterations, use 0 for infinite animation
 * @param {number[]} [source.delay] - list of delays between animation frames (in milliseconds)
 * @param {Object} [target] - target object for valid options
 * @throws {Error} Invalid options
 */ function trySetAnimationOptions(source, target) {
    if (is.object(source) && is.defined(source.loop)) {
        if (is.integer(source.loop) && is.inRange(source.loop, 0, 65535)) {
            target.loop = source.loop;
        } else {
            throw is.invalidParameterError('loop', 'integer between 0 and 65535', source.loop);
        }
    }
    if (is.object(source) && is.defined(source.delay)) {
        // We allow singular values as well
        if (is.integer(source.delay) && is.inRange(source.delay, 0, 65535)) {
            target.delay = [
                source.delay
            ];
        } else if (Array.isArray(source.delay) && source.delay.every(is.integer) && source.delay.every((v)=>is.inRange(v, 0, 65535))) {
            target.delay = source.delay;
        } else {
            throw is.invalidParameterError('delay', 'integer or an array of integers between 0 and 65535', source.delay);
        }
    }
}
/**
 * Use these TIFF options for output image.
 *
 * The `density` can be set in pixels/inch via {@link #withmetadata withMetadata}
 * instead of providing `xres` and `yres` in pixels/mm.
 *
 * @example
 * // Convert SVG input to LZW-compressed, 1 bit per pixel TIFF output
 * sharp('input.svg')
 *   .tiff({
 *     compression: 'lzw',
 *     bitdepth: 1
 *   })
 *   .toFile('1-bpp-output.tiff')
 *   .then(info => { ... });
 *
 * @param {Object} [options] - output options
 * @param {number} [options.quality=80] - quality, integer 1-100
 * @param {boolean} [options.force=true] - force TIFF output, otherwise attempt to use input format
 * @param {string} [options.compression='jpeg'] - compression options: none, jpeg, deflate, packbits, ccittfax4, lzw, webp, zstd, jp2k
 * @param {boolean} [options.bigtiff=false] - use BigTIFF variant (has no effect when compression is none)
 * @param {string} [options.predictor='horizontal'] - compression predictor options: none, horizontal, float
 * @param {boolean} [options.pyramid=false] - write an image pyramid
 * @param {boolean} [options.tile=false] - write a tiled tiff
 * @param {number} [options.tileWidth=256] - horizontal tile size
 * @param {number} [options.tileHeight=256] - vertical tile size
 * @param {number} [options.xres=1.0] - horizontal resolution in pixels/mm
 * @param {number} [options.yres=1.0] - vertical resolution in pixels/mm
 * @param {string} [options.resolutionUnit='inch'] - resolution unit options: inch, cm
 * @param {number} [options.bitdepth=8] - reduce bitdepth to 1, 2 or 4 bit
 * @param {boolean} [options.miniswhite=false] - write 1-bit images as miniswhite
 * @returns {Sharp}
 * @throws {Error} Invalid options
 */ function tiff(options) {
    if (is.object(options)) {
        if (is.defined(options.quality)) {
            if (is.integer(options.quality) && is.inRange(options.quality, 1, 100)) {
                this.options.tiffQuality = options.quality;
            } else {
                throw is.invalidParameterError('quality', 'integer between 1 and 100', options.quality);
            }
        }
        if (is.defined(options.bitdepth)) {
            if (is.integer(options.bitdepth) && is.inArray(options.bitdepth, [
                1,
                2,
                4,
                8
            ])) {
                this.options.tiffBitdepth = options.bitdepth;
            } else {
                throw is.invalidParameterError('bitdepth', '1, 2, 4 or 8', options.bitdepth);
            }
        }
        // tiling
        if (is.defined(options.tile)) {
            this._setBooleanOption('tiffTile', options.tile);
        }
        if (is.defined(options.tileWidth)) {
            if (is.integer(options.tileWidth) && options.tileWidth > 0) {
                this.options.tiffTileWidth = options.tileWidth;
            } else {
                throw is.invalidParameterError('tileWidth', 'integer greater than zero', options.tileWidth);
            }
        }
        if (is.defined(options.tileHeight)) {
            if (is.integer(options.tileHeight) && options.tileHeight > 0) {
                this.options.tiffTileHeight = options.tileHeight;
            } else {
                throw is.invalidParameterError('tileHeight', 'integer greater than zero', options.tileHeight);
            }
        }
        // miniswhite
        if (is.defined(options.miniswhite)) {
            this._setBooleanOption('tiffMiniswhite', options.miniswhite);
        }
        // pyramid
        if (is.defined(options.pyramid)) {
            this._setBooleanOption('tiffPyramid', options.pyramid);
        }
        // resolution
        if (is.defined(options.xres)) {
            if (is.number(options.xres) && options.xres > 0) {
                this.options.tiffXres = options.xres;
            } else {
                throw is.invalidParameterError('xres', 'number greater than zero', options.xres);
            }
        }
        if (is.defined(options.yres)) {
            if (is.number(options.yres) && options.yres > 0) {
                this.options.tiffYres = options.yres;
            } else {
                throw is.invalidParameterError('yres', 'number greater than zero', options.yres);
            }
        }
        // compression
        if (is.defined(options.compression)) {
            if (is.string(options.compression) && is.inArray(options.compression, [
                'none',
                'jpeg',
                'deflate',
                'packbits',
                'ccittfax4',
                'lzw',
                'webp',
                'zstd',
                'jp2k'
            ])) {
                this.options.tiffCompression = options.compression;
            } else {
                throw is.invalidParameterError('compression', 'one of: none, jpeg, deflate, packbits, ccittfax4, lzw, webp, zstd, jp2k', options.compression);
            }
        }
        // bigtiff
        if (is.defined(options.bigtiff)) {
            this._setBooleanOption('tiffBigtiff', options.bigtiff);
        }
        // predictor
        if (is.defined(options.predictor)) {
            if (is.string(options.predictor) && is.inArray(options.predictor, [
                'none',
                'horizontal',
                'float'
            ])) {
                this.options.tiffPredictor = options.predictor;
            } else {
                throw is.invalidParameterError('predictor', 'one of: none, horizontal, float', options.predictor);
            }
        }
        // resolutionUnit
        if (is.defined(options.resolutionUnit)) {
            if (is.string(options.resolutionUnit) && is.inArray(options.resolutionUnit, [
                'inch',
                'cm'
            ])) {
                this.options.tiffResolutionUnit = options.resolutionUnit;
            } else {
                throw is.invalidParameterError('resolutionUnit', 'one of: inch, cm', options.resolutionUnit);
            }
        }
    }
    return this._updateFormatOut('tiff', options);
}
/**
 * Use these AVIF options for output image.
 *
 * AVIF image sequences are not supported.
 * Prebuilt binaries support a bitdepth of 8 only.
 *
 * This feature is experimental on the Windows ARM64 platform
 * and requires a CPU with ARM64v8.4 or later.
 *
 * @example
 * const data = await sharp(input)
 *   .avif({ effort: 2 })
 *   .toBuffer();
 *
 * @example
 * const data = await sharp(input)
 *   .avif({ lossless: true })
 *   .toBuffer();
 *
 * @since 0.27.0
 *
 * @param {Object} [options] - output options
 * @param {number} [options.quality=50] - quality, integer 1-100
 * @param {boolean} [options.lossless=false] - use lossless compression
 * @param {number} [options.effort=4] - CPU effort, between 0 (fastest) and 9 (slowest)
 * @param {string} [options.chromaSubsampling='4:4:4'] - set to '4:2:0' to use chroma subsampling
 * @param {number} [options.bitdepth=8] - set bitdepth to 8, 10 or 12 bit
 * @returns {Sharp}
 * @throws {Error} Invalid options
 */ function avif(options) {
    return this.heif({
        ...options,
        compression: 'av1'
    });
}
/**
 * Use these HEIF options for output image.
 *
 * Support for patent-encumbered HEIC images using `hevc` compression requires the use of a
 * globally-installed libvips compiled with support for libheif, libde265 and x265.
 *
 * @example
 * const data = await sharp(input)
 *   .heif({ compression: 'hevc' })
 *   .toBuffer();
 *
 * @since 0.23.0
 *
 * @param {Object} options - output options
 * @param {string} options.compression - compression format: av1, hevc
 * @param {number} [options.quality=50] - quality, integer 1-100
 * @param {boolean} [options.lossless=false] - use lossless compression
 * @param {number} [options.effort=4] - CPU effort, between 0 (fastest) and 9 (slowest)
 * @param {string} [options.chromaSubsampling='4:4:4'] - set to '4:2:0' to use chroma subsampling
 * @param {number} [options.bitdepth=8] - set bitdepth to 8, 10 or 12 bit
 * @returns {Sharp}
 * @throws {Error} Invalid options
 */ function heif(options) {
    if (is.object(options)) {
        if (is.string(options.compression) && is.inArray(options.compression, [
            'av1',
            'hevc'
        ])) {
            this.options.heifCompression = options.compression;
        } else {
            throw is.invalidParameterError('compression', 'one of: av1, hevc', options.compression);
        }
        if (is.defined(options.quality)) {
            if (is.integer(options.quality) && is.inRange(options.quality, 1, 100)) {
                this.options.heifQuality = options.quality;
            } else {
                throw is.invalidParameterError('quality', 'integer between 1 and 100', options.quality);
            }
        }
        if (is.defined(options.lossless)) {
            if (is.bool(options.lossless)) {
                this.options.heifLossless = options.lossless;
            } else {
                throw is.invalidParameterError('lossless', 'boolean', options.lossless);
            }
        }
        if (is.defined(options.effort)) {
            if (is.integer(options.effort) && is.inRange(options.effort, 0, 9)) {
                this.options.heifEffort = options.effort;
            } else {
                throw is.invalidParameterError('effort', 'integer between 0 and 9', options.effort);
            }
        }
        if (is.defined(options.chromaSubsampling)) {
            if (is.string(options.chromaSubsampling) && is.inArray(options.chromaSubsampling, [
                '4:2:0',
                '4:4:4'
            ])) {
                this.options.heifChromaSubsampling = options.chromaSubsampling;
            } else {
                throw is.invalidParameterError('chromaSubsampling', 'one of: 4:2:0, 4:4:4', options.chromaSubsampling);
            }
        }
        if (is.defined(options.bitdepth)) {
            if (is.integer(options.bitdepth) && is.inArray(options.bitdepth, [
                8,
                10,
                12
            ])) {
                if (options.bitdepth !== 8 && this.constructor.versions.heif) {
                    throw is.invalidParameterError('bitdepth when using prebuilt binaries', 8, options.bitdepth);
                }
                this.options.heifBitdepth = options.bitdepth;
            } else {
                throw is.invalidParameterError('bitdepth', '8, 10 or 12', options.bitdepth);
            }
        }
    } else {
        throw is.invalidParameterError('options', 'Object', options);
    }
    return this._updateFormatOut('heif', options);
}
/**
 * Use these JPEG-XL (JXL) options for output image.
 *
 * This feature is experimental, please do not use in production systems.
 *
 * Requires libvips compiled with support for libjxl.
 * The prebuilt binaries do not include this - see
 * {@link /install/#custom-libvips installing a custom libvips}.
 *
 * @since 0.31.3
 *
 * @param {Object} [options] - output options
 * @param {number} [options.distance=1.0] - maximum encoding error, between 0 (highest quality) and 15 (lowest quality)
 * @param {number} [options.quality] - calculate `distance` based on JPEG-like quality, between 1 and 100, overrides distance if specified
 * @param {number} [options.decodingTier=0] - target decode speed tier, between 0 (highest quality) and 4 (lowest quality)
 * @param {boolean} [options.lossless=false] - use lossless compression
 * @param {number} [options.effort=7] - CPU effort, between 1 (fastest) and 9 (slowest)
 * @param {number} [options.loop=0] - number of animation iterations, use 0 for infinite animation
 * @param {number|number[]} [options.delay] - delay(s) between animation frames (in milliseconds)
 * @returns {Sharp}
 * @throws {Error} Invalid options
 */ function jxl(options) {
    if (is.object(options)) {
        if (is.defined(options.quality)) {
            if (is.integer(options.quality) && is.inRange(options.quality, 1, 100)) {
                // https://github.com/libjxl/libjxl/blob/0aeea7f180bafd6893c1db8072dcb67d2aa5b03d/tools/cjxl_main.cc#L640-L644
                this.options.jxlDistance = options.quality >= 30 ? 0.1 + (100 - options.quality) * 0.09 : 53 / 3000 * options.quality * options.quality - 23 / 20 * options.quality + 25;
            } else {
                throw is.invalidParameterError('quality', 'integer between 1 and 100', options.quality);
            }
        } else if (is.defined(options.distance)) {
            if (is.number(options.distance) && is.inRange(options.distance, 0, 15)) {
                this.options.jxlDistance = options.distance;
            } else {
                throw is.invalidParameterError('distance', 'number between 0.0 and 15.0', options.distance);
            }
        }
        if (is.defined(options.decodingTier)) {
            if (is.integer(options.decodingTier) && is.inRange(options.decodingTier, 0, 4)) {
                this.options.jxlDecodingTier = options.decodingTier;
            } else {
                throw is.invalidParameterError('decodingTier', 'integer between 0 and 4', options.decodingTier);
            }
        }
        if (is.defined(options.lossless)) {
            if (is.bool(options.lossless)) {
                this.options.jxlLossless = options.lossless;
            } else {
                throw is.invalidParameterError('lossless', 'boolean', options.lossless);
            }
        }
        if (is.defined(options.effort)) {
            if (is.integer(options.effort) && is.inRange(options.effort, 1, 9)) {
                this.options.jxlEffort = options.effort;
            } else {
                throw is.invalidParameterError('effort', 'integer between 1 and 9', options.effort);
            }
        }
    }
    trySetAnimationOptions(options, this.options);
    return this._updateFormatOut('jxl', options);
}
/**
 * Force output to be raw, uncompressed pixel data.
 * Pixel ordering is left-to-right, top-to-bottom, without padding.
 * Channel ordering will be RGB or RGBA for non-greyscale colourspaces.
 *
 * @example
 * // Extract raw, unsigned 8-bit RGB pixel data from JPEG input
 * const { data, info } = await sharp('input.jpg')
 *   .raw()
 *   .toBuffer({ resolveWithObject: true });
 *
 * @example
 * // Extract alpha channel as raw, unsigned 16-bit pixel data from PNG input
 * const data = await sharp('input.png')
 *   .ensureAlpha()
 *   .extractChannel(3)
 *   .toColourspace('b-w')
 *   .raw({ depth: 'ushort' })
 *   .toBuffer();
 *
 * @param {Object} [options] - output options
 * @param {string} [options.depth='uchar'] - bit depth, one of: char, uchar (default), short, ushort, int, uint, float, complex, double, dpcomplex
 * @returns {Sharp}
 * @throws {Error} Invalid options
 */ function raw(options) {
    if (is.object(options)) {
        if (is.defined(options.depth)) {
            if (is.string(options.depth) && is.inArray(options.depth, [
                'char',
                'uchar',
                'short',
                'ushort',
                'int',
                'uint',
                'float',
                'complex',
                'double',
                'dpcomplex'
            ])) {
                this.options.rawDepth = options.depth;
            } else {
                throw is.invalidParameterError('depth', 'one of: char, uchar, short, ushort, int, uint, float, complex, double, dpcomplex', options.depth);
            }
        }
    }
    return this._updateFormatOut('raw');
}
/**
 * Use tile-based deep zoom (image pyramid) output.
 *
 * Set the format and options for tile images via the `toFormat`, `jpeg`, `png` or `webp` functions.
 * Use a `.zip` or `.szi` file extension with `toFile` to write to a compressed archive file format.
 *
 * The container will be set to `zip` when the output is a Buffer or Stream, otherwise it will default to `fs`.
 *
 * @example
 *  sharp('input.tiff')
 *   .png()
 *   .tile({
 *     size: 512
 *   })
 *   .toFile('output.dz', function(err, info) {
 *     // output.dzi is the Deep Zoom XML definition
 *     // output_files contains 512x512 tiles grouped by zoom level
 *   });
 *
 * @example
 * const zipFileWithTiles = await sharp(input)
 *   .tile({ basename: "tiles" })
 *   .toBuffer();
 *
 * @example
 * const iiififier = sharp().tile({ layout: "iiif" });
 * readableStream
 *   .pipe(iiififier)
 *   .pipe(writeableStream);
 *
 * @param {Object} [options]
 * @param {number} [options.size=256] tile size in pixels, a value between 1 and 8192.
 * @param {number} [options.overlap=0] tile overlap in pixels, a value between 0 and 8192.
 * @param {number} [options.angle=0] tile angle of rotation, must be a multiple of 90.
 * @param {string|Object} [options.background={r: 255, g: 255, b: 255, alpha: 1}] - background colour, parsed by the [color](https://www.npmjs.org/package/color) module, defaults to white without transparency.
 * @param {string} [options.depth] how deep to make the pyramid, possible values are `onepixel`, `onetile` or `one`, default based on layout.
 * @param {number} [options.skipBlanks=-1] Threshold to skip tile generation. Range is 0-255 for 8-bit images, 0-65535 for 16-bit images. Default is 5 for `google` layout, -1 (no skip) otherwise.
 * @param {string} [options.container='fs'] tile container, with value `fs` (filesystem) or `zip` (compressed file).
 * @param {string} [options.layout='dz'] filesystem layout, possible values are `dz`, `iiif`, `iiif3`, `zoomify` or `google`.
 * @param {boolean} [options.centre=false] centre image in tile.
 * @param {boolean} [options.center=false] alternative spelling of centre.
 * @param {string} [options.id='https://example.com/iiif'] when `layout` is `iiif`/`iiif3`, sets the `@id`/`id` attribute of `info.json`
 * @param {string} [options.basename] the name of the directory within the zip file when container is `zip`.
 * @returns {Sharp}
 * @throws {Error} Invalid parameters
 */ function tile(options) {
    if (is.object(options)) {
        // Size of square tiles, in pixels
        if (is.defined(options.size)) {
            if (is.integer(options.size) && is.inRange(options.size, 1, 8192)) {
                this.options.tileSize = options.size;
            } else {
                throw is.invalidParameterError('size', 'integer between 1 and 8192', options.size);
            }
        }
        // Overlap of tiles, in pixels
        if (is.defined(options.overlap)) {
            if (is.integer(options.overlap) && is.inRange(options.overlap, 0, 8192)) {
                if (options.overlap > this.options.tileSize) {
                    throw is.invalidParameterError('overlap', `<= size (${this.options.tileSize})`, options.overlap);
                }
                this.options.tileOverlap = options.overlap;
            } else {
                throw is.invalidParameterError('overlap', 'integer between 0 and 8192', options.overlap);
            }
        }
        // Container
        if (is.defined(options.container)) {
            if (is.string(options.container) && is.inArray(options.container, [
                'fs',
                'zip'
            ])) {
                this.options.tileContainer = options.container;
            } else {
                throw is.invalidParameterError('container', 'one of: fs, zip', options.container);
            }
        }
        // Layout
        if (is.defined(options.layout)) {
            if (is.string(options.layout) && is.inArray(options.layout, [
                'dz',
                'google',
                'iiif',
                'iiif3',
                'zoomify'
            ])) {
                this.options.tileLayout = options.layout;
            } else {
                throw is.invalidParameterError('layout', 'one of: dz, google, iiif, iiif3, zoomify', options.layout);
            }
        }
        // Angle of rotation,
        if (is.defined(options.angle)) {
            if (is.integer(options.angle) && !(options.angle % 90)) {
                this.options.tileAngle = options.angle;
            } else {
                throw is.invalidParameterError('angle', 'positive/negative multiple of 90', options.angle);
            }
        }
        // Background colour
        this._setBackgroundColourOption('tileBackground', options.background);
        // Depth of tiles
        if (is.defined(options.depth)) {
            if (is.string(options.depth) && is.inArray(options.depth, [
                'onepixel',
                'onetile',
                'one'
            ])) {
                this.options.tileDepth = options.depth;
            } else {
                throw is.invalidParameterError('depth', 'one of: onepixel, onetile, one', options.depth);
            }
        }
        // Threshold to skip blank tiles
        if (is.defined(options.skipBlanks)) {
            if (is.integer(options.skipBlanks) && is.inRange(options.skipBlanks, -1, 65535)) {
                this.options.tileSkipBlanks = options.skipBlanks;
            } else {
                throw is.invalidParameterError('skipBlanks', 'integer between -1 and 255/65535', options.skipBlanks);
            }
        } else if (is.defined(options.layout) && options.layout === 'google') {
            this.options.tileSkipBlanks = 5;
        }
        // Center image in tile
        const centre = is.bool(options.center) ? options.center : options.centre;
        if (is.defined(centre)) {
            this._setBooleanOption('tileCentre', centre);
        }
        // @id attribute for IIIF layout
        if (is.defined(options.id)) {
            if (is.string(options.id)) {
                this.options.tileId = options.id;
            } else {
                throw is.invalidParameterError('id', 'string', options.id);
            }
        }
        // Basename for zip container
        if (is.defined(options.basename)) {
            if (is.string(options.basename)) {
                this.options.tileBasename = options.basename;
            } else {
                throw is.invalidParameterError('basename', 'string', options.basename);
            }
        }
    }
    // Format
    if (is.inArray(this.options.formatOut, [
        'jpeg',
        'png',
        'webp'
    ])) {
        this.options.tileFormat = this.options.formatOut;
    } else if (this.options.formatOut !== 'input') {
        throw is.invalidParameterError('format', 'one of: jpeg, png, webp', this.options.formatOut);
    }
    return this._updateFormatOut('dz');
}
/**
 * Set a timeout for processing, in seconds.
 * Use a value of zero to continue processing indefinitely, the default behaviour.
 *
 * The clock starts when libvips opens an input image for processing.
 * Time spent waiting for a libuv thread to become available is not included.
 *
 * @example
 * // Ensure processing takes no longer than 3 seconds
 * try {
 *   const data = await sharp(input)
 *     .blur(1000)
 *     .timeout({ seconds: 3 })
 *     .toBuffer();
 * } catch (err) {
 *   if (err.message.includes('timeout')) { ... }
 * }
 *
 * @since 0.29.2
 *
 * @param {Object} options
 * @param {number} options.seconds - Number of seconds after which processing will be stopped
 * @returns {Sharp}
 */ function timeout(options) {
    if (!is.plainObject(options)) {
        throw is.invalidParameterError('options', 'object', options);
    }
    if (is.integer(options.seconds) && is.inRange(options.seconds, 0, 3600)) {
        this.options.timeoutSeconds = options.seconds;
    } else {
        throw is.invalidParameterError('seconds', 'integer between 0 and 3600', options.seconds);
    }
    return this;
}
/**
 * Update the output format unless options.force is false,
 * in which case revert to input format.
 * @private
 * @param {string} formatOut
 * @param {Object} [options]
 * @param {boolean} [options.force=true] - force output format, otherwise attempt to use input format
 * @returns {Sharp}
 */ function _updateFormatOut(formatOut, options) {
    if (!(is.object(options) && options.force === false)) {
        this.options.formatOut = formatOut;
    }
    return this;
}
/**
 * Update a boolean attribute of the this.options Object.
 * @private
 * @param {string} key
 * @param {boolean} val
 * @throws {Error} Invalid key
 */ function _setBooleanOption(key, val) {
    if (is.bool(val)) {
        this.options[key] = val;
    } else {
        throw is.invalidParameterError(key, 'boolean', val);
    }
}
/**
 * Called by a WriteableStream to notify us it is ready for data.
 * @private
 */ function _read() {
    if (!this.options.streamOut) {
        this.options.streamOut = true;
        const stack = Error();
        this._pipeline(undefined, stack);
    }
}
/**
 * Invoke the C++ image processing pipeline
 * Supports callback, stream and promise variants
 * @private
 */ function _pipeline(callback, stack) {
    if (typeof callback === 'function') {
        // output=file/buffer
        if (this._isStreamInput()) {
            // output=file/buffer, input=stream
            this.on('finish', ()=>{
                this._flattenBufferIn();
                sharp.pipeline(this.options, (err, data, info)=>{
                    if (err) {
                        callback(is.nativeError(err, stack));
                    } else {
                        callback(null, data, info);
                    }
                });
            });
        } else {
            // output=file/buffer, input=file/buffer
            sharp.pipeline(this.options, (err, data, info)=>{
                if (err) {
                    callback(is.nativeError(err, stack));
                } else {
                    callback(null, data, info);
                }
            });
        }
        return this;
    } else if (this.options.streamOut) {
        // output=stream
        if (this._isStreamInput()) {
            // output=stream, input=stream
            this.once('finish', ()=>{
                this._flattenBufferIn();
                sharp.pipeline(this.options, (err, data, info)=>{
                    if (err) {
                        this.emit('error', is.nativeError(err, stack));
                    } else {
                        this.emit('info', info);
                        this.push(data);
                    }
                    this.push(null);
                    this.on('end', ()=>this.emit('close'));
                });
            });
            if (this.streamInFinished) {
                this.emit('finish');
            }
        } else {
            // output=stream, input=file/buffer
            sharp.pipeline(this.options, (err, data, info)=>{
                if (err) {
                    this.emit('error', is.nativeError(err, stack));
                } else {
                    this.emit('info', info);
                    this.push(data);
                }
                this.push(null);
                this.on('end', ()=>this.emit('close'));
            });
        }
        return this;
    } else {
        // output=promise
        if (this._isStreamInput()) {
            // output=promise, input=stream
            return new Promise((resolve, reject)=>{
                this.once('finish', ()=>{
                    this._flattenBufferIn();
                    sharp.pipeline(this.options, (err, data, info)=>{
                        if (err) {
                            reject(is.nativeError(err, stack));
                        } else {
                            if (this.options.resolveWithObject) {
                                resolve({
                                    data,
                                    info
                                });
                            } else {
                                resolve(data);
                            }
                        }
                    });
                });
            });
        } else {
            // output=promise, input=file/buffer
            return new Promise((resolve, reject)=>{
                sharp.pipeline(this.options, (err, data, info)=>{
                    if (err) {
                        reject(is.nativeError(err, stack));
                    } else {
                        if (this.options.resolveWithObject) {
                            resolve({
                                data,
                                info
                            });
                        } else {
                            resolve(data);
                        }
                    }
                });
            });
        }
    }
}
/**
 * Decorate the Sharp prototype with output-related functions.
 * @module Sharp
 * @private
 */ module.exports = (Sharp)=>{
    Object.assign(Sharp.prototype, {
        // Public
        toFile,
        toBuffer,
        keepExif,
        withExif,
        withExifMerge,
        keepIccProfile,
        withIccProfile,
        keepXmp,
        withXmp,
        keepMetadata,
        withMetadata,
        toFormat,
        jpeg,
        jp2,
        png,
        webp,
        tiff,
        avif,
        heif,
        jxl,
        gif,
        raw,
        tile,
        timeout,
        // Private
        _updateFormatOut,
        _setBooleanOption,
        _read,
        _pipeline
    });
};
}),
"[project]/node_modules/@img/sharp-win32-x64/versions.json (json)", ((__turbopack_context__) => {

__turbopack_context__.v({"aom":"3.13.1","archive":"3.8.2","cairo":"1.18.4","cgif":"0.5.0","exif":"0.6.25","expat":"2.7.3","ffi":"3.5.2","fontconfig":"2.17.1","freetype":"2.14.1","fribidi":"1.0.16","glib":"2.86.1","harfbuzz":"12.1.0","heif":"1.20.2","highway":"1.3.0","imagequant":"2.4.1","lcms":"2.17","mozjpeg":"0826579","pango":"1.57.0","pixman":"0.46.4","png":"1.6.50","proxy-libintl":"0.5","rsvg":"2.61.2","spng":"0.7.4","tiff":"4.7.1","vips":"8.17.3","webp":"1.6.0","xml2":"2.15.1","zlib-ng":"2.2.5"});}),
"[project]/node_modules/next/dist/compiled/os-browserify/browser.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

(function() {
    if (typeof __nccwpck_require__ !== "undefined") __nccwpck_require__.ab = ("TURBOPACK compile-time value", "/ROOT/node_modules/next/dist/compiled/os-browserify") + "/";
    var n = {};
    !function() {
        var e = n;
        e.endianness = function() {
            return "LE";
        };
        e.hostname = function() {
            if (typeof location !== "undefined") {
                return location.hostname;
            } else return "";
        };
        e.loadavg = function() {
            return [];
        };
        e.uptime = function() {
            return 0;
        };
        e.freemem = function() {
            return Number.MAX_VALUE;
        };
        e.totalmem = function() {
            return Number.MAX_VALUE;
        };
        e.cpus = function() {
            return [];
        };
        e.type = function() {
            return "Browser";
        };
        e.release = function() {
            if (typeof navigator !== "undefined") {
                return navigator.appVersion;
            }
            return "";
        };
        e.networkInterfaces = e.getNetworkInterfaces = function() {
            return {};
        };
        e.arch = function() {
            return "javascript";
        };
        e.platform = function() {
            return "browser";
        };
        e.tmpdir = e.tmpDir = function() {
            return "/tmp";
        };
        e.EOL = "\n";
        e.homedir = function() {
            return "/";
        };
    }();
    module.exports = n;
})();
}),
"[project]/node_modules/sharp/lib/utility.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

/*!
  Copyright 2013 Lovell Fuller and others.
  SPDX-License-Identifier: Apache-2.0
*/ const events = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/events/events.js [app-client] (ecmascript)");
const detectLibc = __turbopack_context__.r("[project]/node_modules/detect-libc/lib/detect-libc.js [app-client] (ecmascript)");
const is = __turbopack_context__.r("[project]/node_modules/sharp/lib/is.js [app-client] (ecmascript)");
const { runtimePlatformArch } = __turbopack_context__.r("[project]/node_modules/sharp/lib/libvips.js [app-client] (ecmascript)");
const sharp = __turbopack_context__.r("[project]/node_modules/sharp/lib/sharp.js [app-client] (ecmascript)");
const runtimePlatform = runtimePlatformArch();
const libvipsVersion = sharp.libvipsVersion();
/**
 * An Object containing nested boolean values representing the available input and output formats/methods.
 * @member
 * @example
 * console.log(sharp.format);
 * @returns {Object}
 */ const format = sharp.format();
format.heif.output.alias = [
    'avif',
    'heic'
];
format.jpeg.output.alias = [
    'jpe',
    'jpg'
];
format.tiff.output.alias = [
    'tif'
];
format.jp2k.output.alias = [
    'j2c',
    'j2k',
    'jp2',
    'jpx'
];
/**
 * An Object containing the available interpolators and their proper values
 * @readonly
 * @enum {string}
 */ const interpolators = {
    /** [Nearest neighbour interpolation](http://en.wikipedia.org/wiki/Nearest-neighbor_interpolation). Suitable for image enlargement only. */ nearest: 'nearest',
    /** [Bilinear interpolation](http://en.wikipedia.org/wiki/Bilinear_interpolation). Faster than bicubic but with less smooth results. */ bilinear: 'bilinear',
    /** [Bicubic interpolation](http://en.wikipedia.org/wiki/Bicubic_interpolation) (the default). */ bicubic: 'bicubic',
    /** [LBB interpolation](https://github.com/libvips/libvips/blob/master/libvips/resample/lbb.cpp#L100). Prevents some "[acutance](http://en.wikipedia.org/wiki/Acutance)" but typically reduces performance by a factor of 2. */ locallyBoundedBicubic: 'lbb',
    /** [Nohalo interpolation](http://eprints.soton.ac.uk/268086/). Prevents acutance but typically reduces performance by a factor of 3. */ nohalo: 'nohalo',
    /** [VSQBS interpolation](https://github.com/libvips/libvips/blob/master/libvips/resample/vsqbs.cpp#L48). Prevents "staircasing" when enlarging. */ vertexSplitQuadraticBasisSpline: 'vsqbs'
};
/**
 * An Object containing the version numbers of sharp, libvips
 * and (when using prebuilt binaries) its dependencies.
 *
 * @member
 * @example
 * console.log(sharp.versions);
 */ let versions = {
    vips: libvipsVersion.semver
};
/* node:coverage ignore next 15 */ if (!libvipsVersion.isGlobal) {
    if (!libvipsVersion.isWasm) {
        try {
            versions = __turbopack_context__.f({
                "@img/sharp-win32-x64/versions": {
                    id: ()=>"[project]/node_modules/@img/sharp-win32-x64/versions.json (json)",
                    module: ()=>__turbopack_context__.r("[project]/node_modules/@img/sharp-win32-x64/versions.json (json)")
                }
            })(`@img/sharp-${runtimePlatform}/versions`);
        } catch (_) {
            try {
                versions = (()=>{
                    const e = new Error("Cannot find module 'unknown'");
                    e.code = 'MODULE_NOT_FOUND';
                    throw e;
                })();
            } catch (_) {}
        }
    } else {
        try {
            versions = (()=>{
                const e = new Error("Cannot find module '@img/sharp-wasm32/versions'");
                e.code = 'MODULE_NOT_FOUND';
                throw e;
            })();
        } catch (_) {}
    }
}
versions.sharp = __turbopack_context__.r("[project]/node_modules/sharp/package.json (json)").version;
/* node:coverage ignore next 5 */ if (versions.heif && format.heif) {
    // Prebuilt binaries provide AV1
    format.heif.input.fileSuffix = [
        '.avif'
    ];
    format.heif.output.alias = [
        'avif'
    ];
}
/**
 * Gets or, when options are provided, sets the limits of _libvips'_ operation cache.
 * Existing entries in the cache will be trimmed after any change in limits.
 * This method always returns cache statistics,
 * useful for determining how much working memory is required for a particular task.
 *
 * @example
 * const stats = sharp.cache();
 * @example
 * sharp.cache( { items: 200 } );
 * sharp.cache( { files: 0 } );
 * sharp.cache(false);
 *
 * @param {Object|boolean} [options=true] - Object with the following attributes, or boolean where true uses default cache settings and false removes all caching
 * @param {number} [options.memory=50] - is the maximum memory in MB to use for this cache
 * @param {number} [options.files=20] - is the maximum number of files to hold open
 * @param {number} [options.items=100] - is the maximum number of operations to cache
 * @returns {Object}
 */ function cache(options) {
    if (is.bool(options)) {
        if (options) {
            // Default cache settings of 50MB, 20 files, 100 items
            return sharp.cache(50, 20, 100);
        } else {
            return sharp.cache(0, 0, 0);
        }
    } else if (is.object(options)) {
        return sharp.cache(options.memory, options.files, options.items);
    } else {
        return sharp.cache();
    }
}
cache(true);
/**
 * Gets or, when a concurrency is provided, sets
 * the maximum number of threads _libvips_ should use to process _each image_.
 * These are from a thread pool managed by glib,
 * which helps avoid the overhead of creating new threads.
 *
 * This method always returns the current concurrency.
 *
 * The default value is the number of CPU cores,
 * except when using glibc-based Linux without jemalloc,
 * where the default is `1` to help reduce memory fragmentation.
 *
 * A value of `0` will reset this to the number of CPU cores.
 *
 * Some image format libraries spawn additional threads,
 * e.g. libaom manages its own 4 threads when encoding AVIF images,
 * and these are independent of the value set here.
 *
 * :::note
 * Further {@link /performance/ control over performance} is available.
 * :::
 *
 * @example
 * const threads = sharp.concurrency(); // 4
 * sharp.concurrency(2); // 2
 * sharp.concurrency(0); // 4
 *
 * @param {number} [concurrency]
 * @returns {number} concurrency
 */ function concurrency(concurrency) {
    return sharp.concurrency(is.integer(concurrency) ? concurrency : null);
}
/* node:coverage ignore next 7 */ if (detectLibc.familySync() === detectLibc.GLIBC && !sharp._isUsingJemalloc()) {
    // Reduce default concurrency to 1 when using glibc memory allocator
    sharp.concurrency(1);
} else if (detectLibc.familySync() === detectLibc.MUSL && sharp.concurrency() === 1024) {
    // Reduce default concurrency when musl thread over-subscription detected
    sharp.concurrency(__turbopack_context__.r("[project]/node_modules/next/dist/compiled/os-browserify/browser.js [app-client] (ecmascript)").availableParallelism());
}
/**
 * An EventEmitter that emits a `change` event when a task is either:
 * - queued, waiting for _libuv_ to provide a worker thread
 * - complete
 * @member
 * @example
 * sharp.queue.on('change', function(queueLength) {
 *   console.log('Queue contains ' + queueLength + ' task(s)');
 * });
 */ const queue = new events.EventEmitter();
/**
 * Provides access to internal task counters.
 * - queue is the number of tasks this module has queued waiting for _libuv_ to provide a worker thread from its pool.
 * - process is the number of resize tasks currently being processed.
 *
 * @example
 * const counters = sharp.counters(); // { queue: 2, process: 4 }
 *
 * @returns {Object}
 */ function counters() {
    return sharp.counters();
}
/**
 * Get and set use of SIMD vector unit instructions.
 * Requires libvips to have been compiled with highway support.
 *
 * Improves the performance of `resize`, `blur` and `sharpen` operations
 * by taking advantage of the SIMD vector unit of the CPU, e.g. Intel SSE and ARM NEON.
 *
 * @example
 * const simd = sharp.simd();
 * // simd is `true` if the runtime use of highway is currently enabled
 * @example
 * const simd = sharp.simd(false);
 * // prevent libvips from using highway at runtime
 *
 * @param {boolean} [simd=true]
 * @returns {boolean}
 */ function simd(simd) {
    return sharp.simd(is.bool(simd) ? simd : null);
}
/**
 * Block libvips operations at runtime.
 *
 * This is in addition to the `VIPS_BLOCK_UNTRUSTED` environment variable,
 * which when set will block all "untrusted" operations.
 *
 * @since 0.32.4
 *
 * @example <caption>Block all TIFF input.</caption>
 * sharp.block({
 *   operation: ['VipsForeignLoadTiff']
 * });
 *
 * @param {Object} options
 * @param {Array<string>} options.operation - List of libvips low-level operation names to block.
 */ function block(options) {
    if (is.object(options)) {
        if (Array.isArray(options.operation) && options.operation.every(is.string)) {
            sharp.block(options.operation, true);
        } else {
            throw is.invalidParameterError('operation', 'Array<string>', options.operation);
        }
    } else {
        throw is.invalidParameterError('options', 'object', options);
    }
}
/**
 * Unblock libvips operations at runtime.
 *
 * This is useful for defining a list of allowed operations.
 *
 * @since 0.32.4
 *
 * @example <caption>Block all input except WebP from the filesystem.</caption>
 * sharp.block({
 *   operation: ['VipsForeignLoad']
 * });
 * sharp.unblock({
 *   operation: ['VipsForeignLoadWebpFile']
 * });
 *
 * @example <caption>Block all input except JPEG and PNG from a Buffer or Stream.</caption>
 * sharp.block({
 *   operation: ['VipsForeignLoad']
 * });
 * sharp.unblock({
 *   operation: ['VipsForeignLoadJpegBuffer', 'VipsForeignLoadPngBuffer']
 * });
 *
 * @param {Object} options
 * @param {Array<string>} options.operation - List of libvips low-level operation names to unblock.
 */ function unblock(options) {
    if (is.object(options)) {
        if (Array.isArray(options.operation) && options.operation.every(is.string)) {
            sharp.block(options.operation, false);
        } else {
            throw is.invalidParameterError('operation', 'Array<string>', options.operation);
        }
    } else {
        throw is.invalidParameterError('options', 'object', options);
    }
}
/**
 * Decorate the Sharp class with utility-related functions.
 * @module Sharp
 * @private
 */ module.exports = (Sharp)=>{
    Sharp.cache = cache;
    Sharp.concurrency = concurrency;
    Sharp.counters = counters;
    Sharp.simd = simd;
    Sharp.format = format;
    Sharp.interpolators = interpolators;
    Sharp.versions = versions;
    Sharp.queue = queue;
    Sharp.block = block;
    Sharp.unblock = unblock;
};
}),
"[project]/node_modules/sharp/lib/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

/*!
  Copyright 2013 Lovell Fuller and others.
  SPDX-License-Identifier: Apache-2.0
*/ const Sharp = __turbopack_context__.r("[project]/node_modules/sharp/lib/constructor.js [app-client] (ecmascript)");
__turbopack_context__.r("[project]/node_modules/sharp/lib/input.js [app-client] (ecmascript)")(Sharp);
__turbopack_context__.r("[project]/node_modules/sharp/lib/resize.js [app-client] (ecmascript)")(Sharp);
__turbopack_context__.r("[project]/node_modules/sharp/lib/composite.js [app-client] (ecmascript)")(Sharp);
__turbopack_context__.r("[project]/node_modules/sharp/lib/operation.js [app-client] (ecmascript)")(Sharp);
__turbopack_context__.r("[project]/node_modules/sharp/lib/colour.js [app-client] (ecmascript)")(Sharp);
__turbopack_context__.r("[project]/node_modules/sharp/lib/channel.js [app-client] (ecmascript)")(Sharp);
__turbopack_context__.r("[project]/node_modules/sharp/lib/output.js [app-client] (ecmascript)")(Sharp);
__turbopack_context__.r("[project]/node_modules/sharp/lib/utility.js [app-client] (ecmascript)")(Sharp);
module.exports = Sharp;
}),
"[project]/node_modules/exifr/dist/full.esm.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Exifr",
    ()=>te,
    "Options",
    ()=>q,
    "allFormatters",
    ()=>X,
    "chunkedProps",
    ()=>G,
    "createDictionary",
    ()=>U,
    "default",
    ()=>__TURBOPACK__default__export__,
    "extendDictionary",
    ()=>F,
    "fetchUrlAsArrayBuffer",
    ()=>M,
    "fileParsers",
    ()=>w,
    "fileReaders",
    ()=>A,
    "gps",
    ()=>Se,
    "gpsOnlyOptions",
    ()=>me,
    "inheritables",
    ()=>K,
    "orientation",
    ()=>Pe,
    "orientationOnlyOptions",
    ()=>Ie,
    "otherSegments",
    ()=>V,
    "parse",
    ()=>ie,
    "readBlobAsArrayBuffer",
    ()=>R,
    "rotateCanvas",
    ()=>we,
    "rotateCss",
    ()=>Te,
    "rotation",
    ()=>Ae,
    "rotations",
    ()=>ke,
    "segmentParsers",
    ()=>T,
    "segments",
    ()=>z,
    "segmentsAndBlocks",
    ()=>j,
    "sidecar",
    ()=>st,
    "tagKeys",
    ()=>E,
    "tagRevivers",
    ()=>N,
    "tagValues",
    ()=>B,
    "thumbnail",
    ()=>ye,
    "thumbnailOnlyOptions",
    ()=>Ce,
    "thumbnailUrl",
    ()=>be,
    "tiffBlocks",
    ()=>H,
    "tiffExtractables",
    ()=>W
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/compiled/buffer/index.js [app-client] (ecmascript)");
var e = "undefined" != typeof self ? self : /*TURBOPACK member replacement*/ __turbopack_context__.g;
const t = "undefined" != typeof navigator, i = t && "undefined" == typeof HTMLImageElement, n = !("undefined" == ("TURBOPACK compile-time value", "object") || "undefined" == typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] || !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].versions || !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].versions.node), s = e.Buffer, r = e.BigInt, a = !!s, o = (e)=>e;
function l(e, t = o) {
    if (n) try {
        return ("TURBOPACK compile-time truthy", 1) ? Promise.resolve(t((()=>{
            const e = new Error("Cannot find module as expression is too dynamic");
            e.code = 'MODULE_NOT_FOUND';
            throw e;
        })())) : "TURBOPACK unreachable";
    } catch (t) {
        console.warn(`Couldn't load ${e}`);
    }
}
let h = e.fetch;
const u = (e)=>h = e;
if (!e.fetch) {
    const e = l("http", (e)=>e), t = l("https", (e)=>e), i = (n, { headers: s } = {})=>new Promise(async (r, a)=>{
            let { port: o, hostname: l, pathname: h, protocol: u, search: c } = new URL(n);
            const f = {
                method: "GET",
                hostname: l,
                path: encodeURI(h) + c,
                headers: s
            };
            "" !== o && (f.port = Number(o));
            const d = ("https:" === u ? await t : await e).request(f, (e)=>{
                if (301 === e.statusCode || 302 === e.statusCode) {
                    let t = new URL(e.headers.location, n).toString();
                    return i(t, {
                        headers: s
                    }).then(r).catch(a);
                }
                r({
                    status: e.statusCode,
                    arrayBuffer: ()=>new Promise((t)=>{
                            let i = [];
                            e.on("data", (e)=>i.push(e)), e.on("end", ()=>t(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].concat(i)));
                        })
                });
            });
            d.on("error", a), d.end();
        });
    u(i);
}
function c(e, t, i) {
    return t in e ? Object.defineProperty(e, t, {
        value: i,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[t] = i, e;
}
const f = (e)=>p(e) ? void 0 : e, d = (e)=>void 0 !== e;
function p(e) {
    return void 0 === e || (e instanceof Map ? 0 === e.size : 0 === Object.values(e).filter(d).length);
}
function g(e) {
    let t = new Error(e);
    throw delete t.stack, t;
}
function m(e) {
    return "" === (e = (function(e) {
        for(; e.endsWith("\0");)e = e.slice(0, -1);
        return e;
    })(e).trim()) ? void 0 : e;
}
function S(e) {
    let t = function(e) {
        let t = 0;
        return e.ifd0.enabled && (t += 1024), e.exif.enabled && (t += 2048), e.makerNote && (t += 2048), e.userComment && (t += 1024), e.gps.enabled && (t += 512), e.interop.enabled && (t += 100), e.ifd1.enabled && (t += 1024), t + 2048;
    }(e);
    return e.jfif.enabled && (t += 50), e.xmp.enabled && (t += 2e4), e.iptc.enabled && (t += 14e3), e.icc.enabled && (t += 6e3), t;
}
const C = (e)=>String.fromCharCode.apply(null, e), y = "undefined" != typeof TextDecoder ? new TextDecoder("utf-8") : void 0;
function b(e) {
    return y ? y.decode(e) : a ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(e).toString("utf8") : decodeURIComponent(escape(C(e)));
}
class I {
    static from(e, t) {
        return e instanceof this && e.le === t ? e : new I(e, void 0, void 0, t);
    }
    constructor(e, t = 0, i, n){
        if ("boolean" == typeof n && (this.le = n), Array.isArray(e) && (e = new Uint8Array(e)), 0 === e) this.byteOffset = 0, this.byteLength = 0;
        else if (e instanceof ArrayBuffer) {
            void 0 === i && (i = e.byteLength - t);
            let n = new DataView(e, t, i);
            this._swapDataView(n);
        } else if (e instanceof Uint8Array || e instanceof DataView || e instanceof I) {
            void 0 === i && (i = e.byteLength - t), (t += e.byteOffset) + i > e.byteOffset + e.byteLength && g("Creating view outside of available memory in ArrayBuffer");
            let n = new DataView(e.buffer, t, i);
            this._swapDataView(n);
        } else if ("number" == typeof e) {
            let t = new DataView(new ArrayBuffer(e));
            this._swapDataView(t);
        } else g("Invalid input argument for BufferView: " + e);
    }
    _swapArrayBuffer(e) {
        this._swapDataView(new DataView(e));
    }
    _swapBuffer(e) {
        this._swapDataView(new DataView(e.buffer, e.byteOffset, e.byteLength));
    }
    _swapDataView(e) {
        this.dataView = e, this.buffer = e.buffer, this.byteOffset = e.byteOffset, this.byteLength = e.byteLength;
    }
    _lengthToEnd(e) {
        return this.byteLength - e;
    }
    set(e, t, i = I) {
        return e instanceof DataView || e instanceof I ? e = new Uint8Array(e.buffer, e.byteOffset, e.byteLength) : e instanceof ArrayBuffer && (e = new Uint8Array(e)), e instanceof Uint8Array || g("BufferView.set(): Invalid data argument."), this.toUint8().set(e, t), new i(this, t, e.byteLength);
    }
    subarray(e, t) {
        return t = t || this._lengthToEnd(e), new I(this, e, t);
    }
    toUint8() {
        return new Uint8Array(this.buffer, this.byteOffset, this.byteLength);
    }
    getUint8Array(e, t) {
        return new Uint8Array(this.buffer, this.byteOffset + e, t);
    }
    getString(e = 0, t = this.byteLength) {
        return b(this.getUint8Array(e, t));
    }
    getLatin1String(e = 0, t = this.byteLength) {
        let i = this.getUint8Array(e, t);
        return C(i);
    }
    getUnicodeString(e = 0, t = this.byteLength) {
        const i = [];
        for(let n = 0; n < t && e + n < this.byteLength; n += 2)i.push(this.getUint16(e + n));
        return C(i);
    }
    getInt8(e) {
        return this.dataView.getInt8(e);
    }
    getUint8(e) {
        return this.dataView.getUint8(e);
    }
    getInt16(e, t = this.le) {
        return this.dataView.getInt16(e, t);
    }
    getInt32(e, t = this.le) {
        return this.dataView.getInt32(e, t);
    }
    getUint16(e, t = this.le) {
        return this.dataView.getUint16(e, t);
    }
    getUint32(e, t = this.le) {
        return this.dataView.getUint32(e, t);
    }
    getFloat32(e, t = this.le) {
        return this.dataView.getFloat32(e, t);
    }
    getFloat64(e, t = this.le) {
        return this.dataView.getFloat64(e, t);
    }
    getFloat(e, t = this.le) {
        return this.dataView.getFloat32(e, t);
    }
    getDouble(e, t = this.le) {
        return this.dataView.getFloat64(e, t);
    }
    getUintBytes(e, t, i) {
        switch(t){
            case 1:
                return this.getUint8(e, i);
            case 2:
                return this.getUint16(e, i);
            case 4:
                return this.getUint32(e, i);
            case 8:
                return this.getUint64 && this.getUint64(e, i);
        }
    }
    getUint(e, t, i) {
        switch(t){
            case 8:
                return this.getUint8(e, i);
            case 16:
                return this.getUint16(e, i);
            case 32:
                return this.getUint32(e, i);
            case 64:
                return this.getUint64 && this.getUint64(e, i);
        }
    }
    toString(e) {
        return this.dataView.toString(e, this.constructor.name);
    }
    ensureChunk() {}
}
function P(e, t) {
    g(`${e} '${t}' was not loaded, try using full build of exifr.`);
}
class k extends Map {
    constructor(e){
        super(), this.kind = e;
    }
    get(e, t) {
        return this.has(e) || P(this.kind, e), t && (e in t || function(e, t) {
            g(`Unknown ${e} '${t}'.`);
        }(this.kind, e), t[e].enabled || P(this.kind, e)), super.get(e);
    }
    keyList() {
        return Array.from(this.keys());
    }
}
var w = new k("file parser"), T = new k("segment parser"), A = new k("file reader");
function D(e, n) {
    return "string" == typeof e ? O(e, n) : t && !i && e instanceof HTMLImageElement ? O(e.src, n) : e instanceof Uint8Array || e instanceof ArrayBuffer || e instanceof DataView ? new I(e) : t && e instanceof Blob ? x(e, n, "blob", R) : void g("Invalid input argument");
}
function O(e, i) {
    return (s = e).startsWith("data:") || s.length > 1e4 ? v(e, i, "base64") : n && e.includes("://") ? x(e, i, "url", M) : n ? v(e, i, "fs") : t ? x(e, i, "url", M) : void g("Invalid input argument");
    //TURBOPACK unreachable
    ;
    var s;
}
async function x(e, t, i, n) {
    return A.has(i) ? v(e, t, i) : n ? async function(e, t) {
        let i = await t(e);
        return new I(i);
    }(e, n) : void g(`Parser ${i} is not loaded`);
}
async function v(e, t, i) {
    let n = new (A.get(i))(e, t);
    return await n.read(), n;
}
const M = (e)=>h(e).then((e)=>e.arrayBuffer()), R = (e)=>new Promise((t, i)=>{
        let n = new FileReader;
        n.onloadend = ()=>t(n.result || new ArrayBuffer), n.onerror = i, n.readAsArrayBuffer(e);
    });
class L extends Map {
    get tagKeys() {
        return this.allKeys || (this.allKeys = Array.from(this.keys())), this.allKeys;
    }
    get tagValues() {
        return this.allValues || (this.allValues = Array.from(this.values())), this.allValues;
    }
}
function U(e, t, i) {
    let n = new L;
    for (let [e, t] of i)n.set(e, t);
    if (Array.isArray(t)) for (let i of t)e.set(i, n);
    else e.set(t, n);
    return n;
}
function F(e, t, i) {
    let n, s = e.get(t);
    for (n of i)s.set(n[0], n[1]);
}
const E = new Map, B = new Map, N = new Map, G = [
    "chunked",
    "firstChunkSize",
    "firstChunkSizeNode",
    "firstChunkSizeBrowser",
    "chunkSize",
    "chunkLimit"
], V = [
    "jfif",
    "xmp",
    "icc",
    "iptc",
    "ihdr"
], z = [
    "tiff",
    ...V
], H = [
    "ifd0",
    "ifd1",
    "exif",
    "gps",
    "interop"
], j = [
    ...z,
    ...H
], W = [
    "makerNote",
    "userComment"
], K = [
    "translateKeys",
    "translateValues",
    "reviveValues",
    "multiSegment"
], X = [
    ...K,
    "sanitize",
    "mergeOutput",
    "silentErrors"
];
class _ {
    get translate() {
        return this.translateKeys || this.translateValues || this.reviveValues;
    }
}
class Y extends _ {
    get needed() {
        return this.enabled || this.deps.size > 0;
    }
    constructor(e, t, i, n){
        if (super(), c(this, "enabled", !1), c(this, "skip", new Set), c(this, "pick", new Set), c(this, "deps", new Set), c(this, "translateKeys", !1), c(this, "translateValues", !1), c(this, "reviveValues", !1), this.key = e, this.enabled = t, this.parse = this.enabled, this.applyInheritables(n), this.canBeFiltered = H.includes(e), this.canBeFiltered && (this.dict = E.get(e)), void 0 !== i) if (Array.isArray(i)) this.parse = this.enabled = !0, this.canBeFiltered && i.length > 0 && this.translateTagSet(i, this.pick);
        else if ("object" == typeof i) {
            if (this.enabled = !0, this.parse = !1 !== i.parse, this.canBeFiltered) {
                let { pick: e, skip: t } = i;
                e && e.length > 0 && this.translateTagSet(e, this.pick), t && t.length > 0 && this.translateTagSet(t, this.skip);
            }
            this.applyInheritables(i);
        } else !0 === i || !1 === i ? this.parse = this.enabled = i : g(`Invalid options argument: ${i}`);
    }
    applyInheritables(e) {
        let t, i;
        for (t of K)i = e[t], void 0 !== i && (this[t] = i);
    }
    translateTagSet(e, t) {
        if (this.dict) {
            let i, n, { tagKeys: s, tagValues: r } = this.dict;
            for (i of e)"string" == typeof i ? (n = r.indexOf(i), -1 === n && (n = s.indexOf(Number(i))), -1 !== n && t.add(Number(s[n]))) : t.add(i);
        } else for (let i of e)t.add(i);
    }
    finalizeFilters() {
        !this.enabled && this.deps.size > 0 ? (this.enabled = !0, ee(this.pick, this.deps)) : this.enabled && this.pick.size > 0 && ee(this.pick, this.deps);
    }
}
var $ = {
    jfif: !1,
    tiff: !0,
    xmp: !1,
    icc: !1,
    iptc: !1,
    ifd0: !0,
    ifd1: !1,
    exif: !0,
    gps: !0,
    interop: !1,
    ihdr: void 0,
    makerNote: !1,
    userComment: !1,
    multiSegment: !1,
    skip: [],
    pick: [],
    translateKeys: !0,
    translateValues: !0,
    reviveValues: !0,
    sanitize: !0,
    mergeOutput: !0,
    silentErrors: !0,
    chunked: !0,
    firstChunkSize: void 0,
    firstChunkSizeNode: 512,
    firstChunkSizeBrowser: 65536,
    chunkSize: 65536,
    chunkLimit: 5
}, J = new Map;
class q extends _ {
    static useCached(e) {
        let t = J.get(e);
        return void 0 !== t || (t = new this(e), J.set(e, t)), t;
    }
    constructor(e){
        super(), !0 === e ? this.setupFromTrue() : void 0 === e ? this.setupFromUndefined() : Array.isArray(e) ? this.setupFromArray(e) : "object" == typeof e ? this.setupFromObject(e) : g(`Invalid options argument ${e}`), void 0 === this.firstChunkSize && (this.firstChunkSize = t ? this.firstChunkSizeBrowser : this.firstChunkSizeNode), this.mergeOutput && (this.ifd1.enabled = !1), this.filterNestedSegmentTags(), this.traverseTiffDependencyTree(), this.checkLoadedPlugins();
    }
    setupFromUndefined() {
        let e;
        for (e of G)this[e] = $[e];
        for (e of X)this[e] = $[e];
        for (e of W)this[e] = $[e];
        for (e of j)this[e] = new Y(e, $[e], void 0, this);
    }
    setupFromTrue() {
        let e;
        for (e of G)this[e] = $[e];
        for (e of X)this[e] = $[e];
        for (e of W)this[e] = !0;
        for (e of j)this[e] = new Y(e, !0, void 0, this);
    }
    setupFromArray(e) {
        let t;
        for (t of G)this[t] = $[t];
        for (t of X)this[t] = $[t];
        for (t of W)this[t] = $[t];
        for (t of j)this[t] = new Y(t, !1, void 0, this);
        this.setupGlobalFilters(e, void 0, H);
    }
    setupFromObject(e) {
        let t;
        for (t of (H.ifd0 = H.ifd0 || H.image, H.ifd1 = H.ifd1 || H.thumbnail, Object.assign(this, e), G))this[t] = Z(e[t], $[t]);
        for (t of X)this[t] = Z(e[t], $[t]);
        for (t of W)this[t] = Z(e[t], $[t]);
        for (t of z)this[t] = new Y(t, $[t], e[t], this);
        for (t of H)this[t] = new Y(t, $[t], e[t], this.tiff);
        this.setupGlobalFilters(e.pick, e.skip, H, j), !0 === e.tiff ? this.batchEnableWithBool(H, !0) : !1 === e.tiff ? this.batchEnableWithUserValue(H, e) : Array.isArray(e.tiff) ? this.setupGlobalFilters(e.tiff, void 0, H) : "object" == typeof e.tiff && this.setupGlobalFilters(e.tiff.pick, e.tiff.skip, H);
    }
    batchEnableWithBool(e, t) {
        for (let i of e)this[i].enabled = t;
    }
    batchEnableWithUserValue(e, t) {
        for (let i of e){
            let e = t[i];
            this[i].enabled = !1 !== e && void 0 !== e;
        }
    }
    setupGlobalFilters(e, t, i, n = i) {
        if (e && e.length) {
            for (let e of n)this[e].enabled = !1;
            let t = Q(e, i);
            for (let [e, i] of t)ee(this[e].pick, i), this[e].enabled = !0;
        } else if (t && t.length) {
            let e = Q(t, i);
            for (let [t, i] of e)ee(this[t].skip, i);
        }
    }
    filterNestedSegmentTags() {
        let { ifd0: e, exif: t, xmp: i, iptc: n, icc: s } = this;
        this.makerNote ? t.deps.add(37500) : t.skip.add(37500), this.userComment ? t.deps.add(37510) : t.skip.add(37510), i.enabled || e.skip.add(700), n.enabled || e.skip.add(33723), s.enabled || e.skip.add(34675);
    }
    traverseTiffDependencyTree() {
        let { ifd0: e, exif: t, gps: i, interop: n } = this;
        n.needed && (t.deps.add(40965), e.deps.add(40965)), t.needed && e.deps.add(34665), i.needed && e.deps.add(34853), this.tiff.enabled = H.some((e)=>!0 === this[e].enabled) || this.makerNote || this.userComment;
        for (let e of H)this[e].finalizeFilters();
    }
    get onlyTiff() {
        return !V.map((e)=>this[e].enabled).some((e)=>!0 === e) && this.tiff.enabled;
    }
    checkLoadedPlugins() {
        for (let e of z)this[e].enabled && !T.has(e) && P("segment parser", e);
    }
}
function Q(e, t) {
    let i, n, s, r, a = [];
    for (s of t){
        for (r of (i = E.get(s), n = [], i))(e.includes(r[0]) || e.includes(r[1])) && n.push(r[0]);
        n.length && a.push([
            s,
            n
        ]);
    }
    return a;
}
function Z(e, t) {
    return void 0 !== e ? e : void 0 !== t ? t : void 0;
}
function ee(e, t) {
    for (let i of t)e.add(i);
}
c(q, "default", $);
class te {
    constructor(e){
        c(this, "parsers", {}), c(this, "output", {}), c(this, "errors", []), c(this, "pushToErrors", (e)=>this.errors.push(e)), this.options = q.useCached(e);
    }
    async read(e) {
        this.file = await D(e, this.options);
    }
    setup() {
        if (this.fileParser) return;
        let { file: e } = this, t = e.getUint16(0);
        for (let [i, n] of w)if (n.canHandle(e, t)) return this.fileParser = new n(this.options, this.file, this.parsers), e[i] = !0;
        this.file.close && this.file.close(), g("Unknown file format");
    }
    async parse() {
        let { output: e, errors: t } = this;
        return this.setup(), this.options.silentErrors ? (await this.executeParsers().catch(this.pushToErrors), t.push(...this.fileParser.errors)) : await this.executeParsers(), this.file.close && this.file.close(), this.options.silentErrors && t.length > 0 && (e.errors = t), f(e);
    }
    async executeParsers() {
        let { output: e } = this;
        await this.fileParser.parse();
        let t = Object.values(this.parsers).map(async (t)=>{
            let i = await t.parse();
            t.assignToOutput(e, i);
        });
        this.options.silentErrors && (t = t.map((e)=>e.catch(this.pushToErrors))), await Promise.all(t);
    }
    async extractThumbnail() {
        this.setup();
        let { options: e, file: t } = this, i = T.get("tiff", e);
        var n;
        if (t.tiff ? n = {
            start: 0,
            type: "tiff"
        } : t.jpeg && (n = await this.fileParser.getOrFindSegment("tiff")), void 0 === n) return;
        let s = await this.fileParser.ensureSegmentChunk(n), r = this.parsers.tiff = new i(s, e, t), a = await r.extractThumbnail();
        return t.close && t.close(), a;
    }
}
async function ie(e, t) {
    let i = new te(t);
    return await i.read(e), i.parse();
}
var ne = Object.freeze({
    __proto__: null,
    parse: ie,
    Exifr: te,
    fileParsers: w,
    segmentParsers: T,
    fileReaders: A,
    tagKeys: E,
    tagValues: B,
    tagRevivers: N,
    createDictionary: U,
    extendDictionary: F,
    fetchUrlAsArrayBuffer: M,
    readBlobAsArrayBuffer: R,
    chunkedProps: G,
    otherSegments: V,
    segments: z,
    tiffBlocks: H,
    segmentsAndBlocks: j,
    tiffExtractables: W,
    inheritables: K,
    allFormatters: X,
    Options: q
});
class se {
    constructor(e, t, i){
        c(this, "errors", []), c(this, "ensureSegmentChunk", async (e)=>{
            let t = e.start, i = e.size || 65536;
            if (this.file.chunked) if (this.file.available(t, i)) e.chunk = this.file.subarray(t, i);
            else try {
                e.chunk = await this.file.readChunk(t, i);
            } catch (t) {
                g(`Couldn't read segment: ${JSON.stringify(e)}. ${t.message}`);
            }
            else this.file.byteLength > t + i ? e.chunk = this.file.subarray(t, i) : void 0 === e.size ? e.chunk = this.file.subarray(t) : g("Segment unreachable: " + JSON.stringify(e));
            return e.chunk;
        }), this.extendOptions && this.extendOptions(e), this.options = e, this.file = t, this.parsers = i;
    }
    injectSegment(e, t) {
        this.options[e].enabled && this.createParser(e, t);
    }
    createParser(e, t) {
        let i = new (T.get(e))(t, this.options, this.file);
        return this.parsers[e] = i;
    }
    createParsers(e) {
        for (let t of e){
            let { type: e, chunk: i } = t, n = this.options[e];
            if (n && n.enabled) {
                let t = this.parsers[e];
                t && t.append || t || this.createParser(e, i);
            }
        }
    }
    async readSegments(e) {
        let t = e.map(this.ensureSegmentChunk);
        await Promise.all(t);
    }
}
class re {
    static findPosition(e, t) {
        let i = e.getUint16(t + 2) + 2, n = "function" == typeof this.headerLength ? this.headerLength(e, t, i) : this.headerLength, s = t + n, r = i - n;
        return {
            offset: t,
            length: i,
            headerLength: n,
            start: s,
            size: r,
            end: s + r
        };
    }
    static parse(e, t = {}) {
        return new this(e, new q({
            [this.type]: t
        }), e).parse();
    }
    normalizeInput(e) {
        return e instanceof I ? e : new I(e);
    }
    constructor(e, t = {}, i){
        c(this, "errors", []), c(this, "raw", new Map), c(this, "handleError", (e)=>{
            if (!this.options.silentErrors) throw e;
            this.errors.push(e.message);
        }), this.chunk = this.normalizeInput(e), this.file = i, this.type = this.constructor.type, this.globalOptions = this.options = t, this.localOptions = t[this.type], this.canTranslate = this.localOptions && this.localOptions.translate;
    }
    translate() {
        this.canTranslate && (this.translated = this.translateBlock(this.raw, this.type));
    }
    get output() {
        return this.translated ? this.translated : this.raw ? Object.fromEntries(this.raw) : void 0;
    }
    translateBlock(e, t) {
        let i = N.get(t), n = B.get(t), s = E.get(t), r = this.options[t], a = r.reviveValues && !!i, o = r.translateValues && !!n, l = r.translateKeys && !!s, h = {};
        for (let [t, r] of e)a && i.has(t) ? r = i.get(t)(r) : o && n.has(t) && (r = this.translateValue(r, n.get(t))), l && s.has(t) && (t = s.get(t) || t), h[t] = r;
        return h;
    }
    translateValue(e, t) {
        return t[e] || t.DEFAULT || e;
    }
    assignToOutput(e, t) {
        this.assignObjectToOutput(e, this.constructor.type, t);
    }
    assignObjectToOutput(e, t, i) {
        if (this.globalOptions.mergeOutput) return Object.assign(e, i);
        e[t] ? Object.assign(e[t], i) : e[t] = i;
    }
}
c(re, "headerLength", 4), c(re, "type", void 0), c(re, "multiSegment", !1), c(re, "canHandle", ()=>!1);
function ae(e) {
    return 192 === e || 194 === e || 196 === e || 219 === e || 221 === e || 218 === e || 254 === e;
}
function oe(e) {
    return e >= 224 && e <= 239;
}
function le(e, t, i) {
    for (let [n, s] of T)if (s.canHandle(e, t, i)) return n;
}
class he extends se {
    constructor(...e){
        super(...e), c(this, "appSegments", []), c(this, "jpegSegments", []), c(this, "unknownSegments", []);
    }
    static canHandle(e, t) {
        return 65496 === t;
    }
    async parse() {
        await this.findAppSegments(), await this.readSegments(this.appSegments), this.mergeMultiSegments(), this.createParsers(this.mergedAppSegments || this.appSegments);
    }
    setupSegmentFinderArgs(e) {
        !0 === e ? (this.findAll = !0, this.wanted = new Set(T.keyList())) : (e = void 0 === e ? T.keyList().filter((e)=>this.options[e].enabled) : e.filter((e)=>this.options[e].enabled && T.has(e)), this.findAll = !1, this.remaining = new Set(e), this.wanted = new Set(e)), this.unfinishedMultiSegment = !1;
    }
    async findAppSegments(e = 0, t) {
        this.setupSegmentFinderArgs(t);
        let { file: i, findAll: n, wanted: s, remaining: r } = this;
        if (!n && this.file.chunked && (n = Array.from(s).some((e)=>{
            let t = T.get(e), i = this.options[e];
            return t.multiSegment && i.multiSegment;
        }), n && await this.file.readWhole()), e = this.findAppSegmentsInRange(e, i.byteLength), !this.options.onlyTiff && i.chunked) {
            let t = !1;
            for(; r.size > 0 && !t && (i.canReadNextChunk || this.unfinishedMultiSegment);){
                let { nextChunkOffset: n } = i, s = this.appSegments.some((e)=>!this.file.available(e.offset || e.start, e.length || e.size));
                if (t = e > n && !s ? !await i.readNextChunk(e) : !await i.readNextChunk(n), void 0 === (e = this.findAppSegmentsInRange(e, i.byteLength))) return;
            }
        }
    }
    findAppSegmentsInRange(e, t) {
        t -= 2;
        let i, n, s, r, a, o, { file: l, findAll: h, wanted: u, remaining: c, options: f } = this;
        for(; e < t; e++)if (255 === l.getUint8(e)) {
            if (i = l.getUint8(e + 1), oe(i)) {
                if (n = l.getUint16(e + 2), s = le(l, e, n), s && u.has(s) && (r = T.get(s), a = r.findPosition(l, e), o = f[s], a.type = s, this.appSegments.push(a), !h && (r.multiSegment && o.multiSegment ? (this.unfinishedMultiSegment = a.chunkNumber < a.chunkCount, this.unfinishedMultiSegment || c.delete(s)) : c.delete(s), 0 === c.size))) break;
                f.recordUnknownSegments && (a = re.findPosition(l, e), a.marker = i, this.unknownSegments.push(a)), e += n + 1;
            } else if (ae(i)) {
                if (n = l.getUint16(e + 2), 218 === i && !1 !== f.stopAfterSos) return;
                f.recordJpegSegments && this.jpegSegments.push({
                    offset: e,
                    length: n,
                    marker: i
                }), e += n + 1;
            }
        }
        return e;
    }
    mergeMultiSegments() {
        if (!this.appSegments.some((e)=>e.multiSegment)) return;
        let e = function(e, t) {
            let i, n, s, r = new Map;
            for(let a = 0; a < e.length; a++)i = e[a], n = i[t], r.has(n) ? s = r.get(n) : r.set(n, s = []), s.push(i);
            return Array.from(r);
        }(this.appSegments, "type");
        this.mergedAppSegments = e.map(([e, t])=>{
            let i = T.get(e, this.options);
            if (i.handleMultiSegments) {
                return {
                    type: e,
                    chunk: i.handleMultiSegments(t)
                };
            }
            return t[0];
        });
    }
    getSegment(e) {
        return this.appSegments.find((t)=>t.type === e);
    }
    async getOrFindSegment(e) {
        let t = this.getSegment(e);
        return void 0 === t && (await this.findAppSegments(0, [
            e
        ]), t = this.getSegment(e)), t;
    }
}
c(he, "type", "jpeg"), w.set("jpeg", he);
const ue = [
    void 0,
    1,
    1,
    2,
    4,
    8,
    1,
    1,
    2,
    4,
    8,
    4,
    8,
    4
];
class ce extends re {
    parseHeader() {
        var e = this.chunk.getUint16();
        18761 === e ? this.le = !0 : 19789 === e && (this.le = !1), this.chunk.le = this.le, this.headerParsed = !0;
    }
    parseTags(e, t, i = new Map) {
        let { pick: n, skip: s } = this.options[t];
        n = new Set(n);
        let r = n.size > 0, a = 0 === s.size, o = this.chunk.getUint16(e);
        e += 2;
        for(let l = 0; l < o; l++){
            let o = this.chunk.getUint16(e);
            if (r) {
                if (n.has(o) && (i.set(o, this.parseTag(e, o, t)), n.delete(o), 0 === n.size)) break;
            } else !a && s.has(o) || i.set(o, this.parseTag(e, o, t));
            e += 12;
        }
        return i;
    }
    parseTag(e, t, i) {
        let { chunk: n } = this, s = n.getUint16(e + 2), r = n.getUint32(e + 4), a = ue[s];
        if (a * r <= 4 ? e += 8 : e = n.getUint32(e + 8), (s < 1 || s > 13) && g(`Invalid TIFF value type. block: ${i.toUpperCase()}, tag: ${t.toString(16)}, type: ${s}, offset ${e}`), e > n.byteLength && g(`Invalid TIFF value offset. block: ${i.toUpperCase()}, tag: ${t.toString(16)}, type: ${s}, offset ${e} is outside of chunk size ${n.byteLength}`), 1 === s) return n.getUint8Array(e, r);
        if (2 === s) return m(n.getString(e, r));
        if (7 === s) return n.getUint8Array(e, r);
        if (1 === r) return this.parseTagValue(s, e);
        {
            let t = new (function(e) {
                switch(e){
                    case 1:
                        return Uint8Array;
                    case 3:
                        return Uint16Array;
                    case 4:
                        return Uint32Array;
                    case 5:
                        return Array;
                    case 6:
                        return Int8Array;
                    case 8:
                        return Int16Array;
                    case 9:
                        return Int32Array;
                    case 10:
                        return Array;
                    case 11:
                        return Float32Array;
                    case 12:
                        return Float64Array;
                    default:
                        return Array;
                }
            }(s))(r), i = a;
            for(let n = 0; n < r; n++)t[n] = this.parseTagValue(s, e), e += i;
            return t;
        }
    }
    parseTagValue(e, t) {
        let { chunk: i } = this;
        switch(e){
            case 1:
                return i.getUint8(t);
            case 3:
                return i.getUint16(t);
            case 4:
                return i.getUint32(t);
            case 5:
                return i.getUint32(t) / i.getUint32(t + 4);
            case 6:
                return i.getInt8(t);
            case 8:
                return i.getInt16(t);
            case 9:
                return i.getInt32(t);
            case 10:
                return i.getInt32(t) / i.getInt32(t + 4);
            case 11:
                return i.getFloat(t);
            case 12:
                return i.getDouble(t);
            case 13:
                return i.getUint32(t);
            default:
                g(`Invalid tiff type ${e}`);
        }
    }
}
class fe extends ce {
    static canHandle(e, t) {
        return 225 === e.getUint8(t + 1) && 1165519206 === e.getUint32(t + 4) && 0 === e.getUint16(t + 8);
    }
    async parse() {
        this.parseHeader();
        let { options: e } = this;
        return e.ifd0.enabled && await this.parseIfd0Block(), e.exif.enabled && await this.safeParse("parseExifBlock"), e.gps.enabled && await this.safeParse("parseGpsBlock"), e.interop.enabled && await this.safeParse("parseInteropBlock"), e.ifd1.enabled && await this.safeParse("parseThumbnailBlock"), this.createOutput();
    }
    safeParse(e) {
        let t = this[e]();
        return void 0 !== t.catch && (t = t.catch(this.handleError)), t;
    }
    findIfd0Offset() {
        void 0 === this.ifd0Offset && (this.ifd0Offset = this.chunk.getUint32(4));
    }
    findIfd1Offset() {
        if (void 0 === this.ifd1Offset) {
            this.findIfd0Offset();
            let e = this.chunk.getUint16(this.ifd0Offset), t = this.ifd0Offset + 2 + 12 * e;
            this.ifd1Offset = this.chunk.getUint32(t);
        }
    }
    parseBlock(e, t) {
        let i = new Map;
        return this[t] = i, this.parseTags(e, t, i), i;
    }
    async parseIfd0Block() {
        if (this.ifd0) return;
        let { file: e } = this;
        this.findIfd0Offset(), this.ifd0Offset < 8 && g("Malformed EXIF data"), !e.chunked && this.ifd0Offset > e.byteLength && g(`IFD0 offset points to outside of file.\nthis.ifd0Offset: ${this.ifd0Offset}, file.byteLength: ${e.byteLength}`), e.tiff && await e.ensureChunk(this.ifd0Offset, S(this.options));
        let t = this.parseBlock(this.ifd0Offset, "ifd0");
        return 0 !== t.size ? (this.exifOffset = t.get(34665), this.interopOffset = t.get(40965), this.gpsOffset = t.get(34853), this.xmp = t.get(700), this.iptc = t.get(33723), this.icc = t.get(34675), this.options.sanitize && (t.delete(34665), t.delete(40965), t.delete(34853), t.delete(700), t.delete(33723), t.delete(34675)), t) : void 0;
    }
    async parseExifBlock() {
        if (this.exif) return;
        if (this.ifd0 || await this.parseIfd0Block(), void 0 === this.exifOffset) return;
        this.file.tiff && await this.file.ensureChunk(this.exifOffset, S(this.options));
        let e = this.parseBlock(this.exifOffset, "exif");
        return this.interopOffset || (this.interopOffset = e.get(40965)), this.makerNote = e.get(37500), this.userComment = e.get(37510), this.options.sanitize && (e.delete(40965), e.delete(37500), e.delete(37510)), this.unpack(e, 41728), this.unpack(e, 41729), e;
    }
    unpack(e, t) {
        let i = e.get(t);
        i && 1 === i.length && e.set(t, i[0]);
    }
    async parseGpsBlock() {
        if (this.gps) return;
        if (this.ifd0 || await this.parseIfd0Block(), void 0 === this.gpsOffset) return;
        let e = this.parseBlock(this.gpsOffset, "gps");
        return e && e.has(2) && e.has(4) && (e.set("latitude", de(...e.get(2), e.get(1))), e.set("longitude", de(...e.get(4), e.get(3)))), e;
    }
    async parseInteropBlock() {
        if (!this.interop && (this.ifd0 || await this.parseIfd0Block(), void 0 !== this.interopOffset || this.exif || await this.parseExifBlock(), void 0 !== this.interopOffset)) return this.parseBlock(this.interopOffset, "interop");
    }
    async parseThumbnailBlock(e = !1) {
        if (!this.ifd1 && !this.ifd1Parsed && (!this.options.mergeOutput || e)) return this.findIfd1Offset(), this.ifd1Offset > 0 && (this.parseBlock(this.ifd1Offset, "ifd1"), this.ifd1Parsed = !0), this.ifd1;
    }
    async extractThumbnail() {
        if (this.headerParsed || this.parseHeader(), this.ifd1Parsed || await this.parseThumbnailBlock(!0), void 0 === this.ifd1) return;
        let e = this.ifd1.get(513), t = this.ifd1.get(514);
        return this.chunk.getUint8Array(e, t);
    }
    get image() {
        return this.ifd0;
    }
    get thumbnail() {
        return this.ifd1;
    }
    createOutput() {
        let e, t, i, n = {};
        for (t of H)if (e = this[t], !p(e)) if (i = this.canTranslate ? this.translateBlock(e, t) : Object.fromEntries(e), this.options.mergeOutput) {
            if ("ifd1" === t) continue;
            Object.assign(n, i);
        } else n[t] = i;
        return this.makerNote && (n.makerNote = this.makerNote), this.userComment && (n.userComment = this.userComment), n;
    }
    assignToOutput(e, t) {
        if (this.globalOptions.mergeOutput) Object.assign(e, t);
        else for (let [i, n] of Object.entries(t))this.assignObjectToOutput(e, i, n);
    }
}
function de(e, t, i, n) {
    var s = e + t / 60 + i / 3600;
    return "S" !== n && "W" !== n || (s *= -1), s;
}
c(fe, "type", "tiff"), c(fe, "headerLength", 10), T.set("tiff", fe);
var pe = Object.freeze({
    __proto__: null,
    default: ne,
    Exifr: te,
    fileParsers: w,
    segmentParsers: T,
    fileReaders: A,
    tagKeys: E,
    tagValues: B,
    tagRevivers: N,
    createDictionary: U,
    extendDictionary: F,
    fetchUrlAsArrayBuffer: M,
    readBlobAsArrayBuffer: R,
    chunkedProps: G,
    otherSegments: V,
    segments: z,
    tiffBlocks: H,
    segmentsAndBlocks: j,
    tiffExtractables: W,
    inheritables: K,
    allFormatters: X,
    Options: q,
    parse: ie
});
const ge = {
    ifd0: !1,
    ifd1: !1,
    exif: !1,
    gps: !1,
    interop: !1,
    sanitize: !1,
    reviveValues: !0,
    translateKeys: !1,
    translateValues: !1,
    mergeOutput: !1
}, me = Object.assign({}, ge, {
    firstChunkSize: 4e4,
    gps: [
        1,
        2,
        3,
        4
    ]
});
async function Se(e) {
    let t = new te(me);
    await t.read(e);
    let i = await t.parse();
    if (i && i.gps) {
        let { latitude: e, longitude: t } = i.gps;
        return {
            latitude: e,
            longitude: t
        };
    }
}
const Ce = Object.assign({}, ge, {
    tiff: !1,
    ifd1: !0,
    mergeOutput: !1
});
async function ye(e) {
    let t = new te(Ce);
    await t.read(e);
    let i = await t.extractThumbnail();
    return i && a ? s.from(i) : i;
}
async function be(e) {
    let t = await this.thumbnail(e);
    if (void 0 !== t) {
        let e = new Blob([
            t
        ]);
        return URL.createObjectURL(e);
    }
}
const Ie = Object.assign({}, ge, {
    firstChunkSize: 4e4,
    ifd0: [
        274
    ]
});
async function Pe(e) {
    let t = new te(Ie);
    await t.read(e);
    let i = await t.parse();
    if (i && i.ifd0) return i.ifd0[274];
}
const ke = Object.freeze({
    1: {
        dimensionSwapped: !1,
        scaleX: 1,
        scaleY: 1,
        deg: 0,
        rad: 0
    },
    2: {
        dimensionSwapped: !1,
        scaleX: -1,
        scaleY: 1,
        deg: 0,
        rad: 0
    },
    3: {
        dimensionSwapped: !1,
        scaleX: 1,
        scaleY: 1,
        deg: 180,
        rad: 180 * Math.PI / 180
    },
    4: {
        dimensionSwapped: !1,
        scaleX: -1,
        scaleY: 1,
        deg: 180,
        rad: 180 * Math.PI / 180
    },
    5: {
        dimensionSwapped: !0,
        scaleX: 1,
        scaleY: -1,
        deg: 90,
        rad: 90 * Math.PI / 180
    },
    6: {
        dimensionSwapped: !0,
        scaleX: 1,
        scaleY: 1,
        deg: 90,
        rad: 90 * Math.PI / 180
    },
    7: {
        dimensionSwapped: !0,
        scaleX: 1,
        scaleY: -1,
        deg: 270,
        rad: 270 * Math.PI / 180
    },
    8: {
        dimensionSwapped: !0,
        scaleX: 1,
        scaleY: 1,
        deg: 270,
        rad: 270 * Math.PI / 180
    }
});
let we = !0, Te = !0;
if ("object" == typeof navigator) {
    let e = navigator.userAgent;
    if (e.includes("iPad") || e.includes("iPhone")) {
        let t = e.match(/OS (\d+)_(\d+)/);
        if (t) {
            let [, e, i] = t, n = Number(e) + .1 * Number(i);
            we = n < 13.4, Te = !1;
        }
    } else if (e.includes("OS X 10")) {
        let [, t] = e.match(/OS X 10[_.](\d+)/);
        we = Te = Number(t) < 15;
    }
    if (e.includes("Chrome/")) {
        let [, t] = e.match(/Chrome\/(\d+)/);
        we = Te = Number(t) < 81;
    } else if (e.includes("Firefox/")) {
        let [, t] = e.match(/Firefox\/(\d+)/);
        we = Te = Number(t) < 77;
    }
}
async function Ae(e) {
    let t = await Pe(e);
    return Object.assign({
        canvas: we,
        css: Te
    }, ke[t]);
}
class De extends I {
    constructor(...e){
        super(...e), c(this, "ranges", new Oe), 0 !== this.byteLength && this.ranges.add(0, this.byteLength);
    }
    _tryExtend(e, t, i) {
        if (0 === e && 0 === this.byteLength && i) {
            let e = new DataView(i.buffer || i, i.byteOffset, i.byteLength);
            this._swapDataView(e);
        } else {
            let i = e + t;
            if (i > this.byteLength) {
                let { dataView: e } = this._extend(i);
                this._swapDataView(e);
            }
        }
    }
    _extend(e) {
        let t;
        t = a ? s.allocUnsafe(e) : new Uint8Array(e);
        let i = new DataView(t.buffer, t.byteOffset, t.byteLength);
        return t.set(new Uint8Array(this.buffer, this.byteOffset, this.byteLength), 0), {
            uintView: t,
            dataView: i
        };
    }
    subarray(e, t, i = !1) {
        return t = t || this._lengthToEnd(e), i && this._tryExtend(e, t), this.ranges.add(e, t), super.subarray(e, t);
    }
    set(e, t, i = !1) {
        i && this._tryExtend(t, e.byteLength, e);
        let n = super.set(e, t);
        return this.ranges.add(t, n.byteLength), n;
    }
    async ensureChunk(e, t) {
        this.chunked && (this.ranges.available(e, t) || await this.readChunk(e, t));
    }
    available(e, t) {
        return this.ranges.available(e, t);
    }
}
class Oe {
    constructor(){
        c(this, "list", []);
    }
    get length() {
        return this.list.length;
    }
    add(e, t, i = 0) {
        let n = e + t, s = this.list.filter((t)=>xe(e, t.offset, n) || xe(e, t.end, n));
        if (s.length > 0) {
            e = Math.min(e, ...s.map((e)=>e.offset)), n = Math.max(n, ...s.map((e)=>e.end)), t = n - e;
            let i = s.shift();
            i.offset = e, i.length = t, i.end = n, this.list = this.list.filter((e)=>!s.includes(e));
        } else this.list.push({
            offset: e,
            length: t,
            end: n
        });
    }
    available(e, t) {
        let i = e + t;
        return this.list.some((t)=>t.offset <= e && i <= t.end);
    }
}
function xe(e, t, i) {
    return e <= t && t <= i;
}
class ve extends De {
    constructor(e, t){
        super(0), c(this, "chunksRead", 0), this.input = e, this.options = t;
    }
    async readWhole() {
        this.chunked = !1, await this.readChunk(this.nextChunkOffset);
    }
    async readChunked() {
        this.chunked = !0, await this.readChunk(0, this.options.firstChunkSize);
    }
    async readNextChunk(e = this.nextChunkOffset) {
        if (this.fullyRead) return this.chunksRead++, !1;
        let t = this.options.chunkSize, i = await this.readChunk(e, t);
        return !!i && i.byteLength === t;
    }
    async readChunk(e, t) {
        if (this.chunksRead++, 0 !== (t = this.safeWrapAddress(e, t))) return this._readChunk(e, t);
    }
    safeWrapAddress(e, t) {
        return void 0 !== this.size && e + t > this.size ? Math.max(0, this.size - e) : t;
    }
    get nextChunkOffset() {
        if (0 !== this.ranges.list.length) return this.ranges.list[0].length;
    }
    get canReadNextChunk() {
        return this.chunksRead < this.options.chunkLimit;
    }
    get fullyRead() {
        return void 0 !== this.size && this.nextChunkOffset === this.size;
    }
    read() {
        return this.options.chunked ? this.readChunked() : this.readWhole();
    }
    close() {}
}
A.set("blob", class extends ve {
    async readWhole() {
        this.chunked = !1;
        let e = await R(this.input);
        this._swapArrayBuffer(e);
    }
    readChunked() {
        return this.chunked = !0, this.size = this.input.size, super.readChunked();
    }
    async _readChunk(e, t) {
        let i = t ? e + t : void 0, n = this.input.slice(e, i), s = await R(n);
        return this.set(s, e, !0);
    }
});
var Me = Object.freeze({
    __proto__: null,
    default: pe,
    Exifr: te,
    fileParsers: w,
    segmentParsers: T,
    fileReaders: A,
    tagKeys: E,
    tagValues: B,
    tagRevivers: N,
    createDictionary: U,
    extendDictionary: F,
    fetchUrlAsArrayBuffer: M,
    readBlobAsArrayBuffer: R,
    chunkedProps: G,
    otherSegments: V,
    segments: z,
    tiffBlocks: H,
    segmentsAndBlocks: j,
    tiffExtractables: W,
    inheritables: K,
    allFormatters: X,
    Options: q,
    parse: ie,
    gpsOnlyOptions: me,
    gps: Se,
    thumbnailOnlyOptions: Ce,
    thumbnail: ye,
    thumbnailUrl: be,
    orientationOnlyOptions: Ie,
    orientation: Pe,
    rotations: ke,
    get rotateCanvas () {
        return we;
    },
    get rotateCss () {
        return Te;
    },
    rotation: Ae
});
A.set("url", class extends ve {
    async readWhole() {
        this.chunked = !1;
        let e = await M(this.input);
        e instanceof ArrayBuffer ? this._swapArrayBuffer(e) : e instanceof Uint8Array && this._swapBuffer(e);
    }
    async _readChunk(e, t) {
        let i = t ? e + t - 1 : void 0, n = this.options.httpHeaders || {};
        (e || i) && (n.range = `bytes=${[
            e,
            i
        ].join("-")}`);
        let s = await h(this.input, {
            headers: n
        }), r = await s.arrayBuffer(), a = r.byteLength;
        if (416 !== s.status) return a !== t && (this.size = e + a), this.set(r, e, !0);
    }
});
I.prototype.getUint64 = function(e) {
    let t = this.getUint32(e), i = this.getUint32(e + 4);
    return t < 1048575 ? t << 32 | i : void 0 !== typeof r ? (console.warn("Using BigInt because of type 64uint but JS can only handle 53b numbers."), r(t) << r(32) | r(i)) : void g("Trying to read 64b value but JS can only handle 53b numbers.");
};
class Re extends se {
    parseBoxes(e = 0) {
        let t = [];
        for(; e < this.file.byteLength - 4;){
            let i = this.parseBoxHead(e);
            if (t.push(i), 0 === i.length) break;
            e += i.length;
        }
        return t;
    }
    parseSubBoxes(e) {
        e.boxes = this.parseBoxes(e.start);
    }
    findBox(e, t) {
        return void 0 === e.boxes && this.parseSubBoxes(e), e.boxes.find((e)=>e.kind === t);
    }
    parseBoxHead(e) {
        let t = this.file.getUint32(e), i = this.file.getString(e + 4, 4), n = e + 8;
        return 1 === t && (t = this.file.getUint64(e + 8), n += 8), {
            offset: e,
            length: t,
            kind: i,
            start: n
        };
    }
    parseBoxFullHead(e) {
        if (void 0 !== e.version) return;
        let t = this.file.getUint32(e.start);
        e.version = t >> 24, e.start += 4;
    }
}
class Le extends Re {
    static canHandle(e, t) {
        if (0 !== t) return !1;
        let i = e.getUint16(2);
        if (i > 50) return !1;
        let n = 16, s = [];
        for(; n < i;)s.push(e.getString(n, 4)), n += 4;
        return s.includes(this.type);
    }
    async parse() {
        let e = this.file.getUint32(0), t = this.parseBoxHead(e);
        for(; "meta" !== t.kind;)e += t.length, await this.file.ensureChunk(e, 16), t = this.parseBoxHead(e);
        await this.file.ensureChunk(t.offset, t.length), this.parseBoxFullHead(t), this.parseSubBoxes(t), this.options.icc.enabled && await this.findIcc(t), this.options.tiff.enabled && await this.findExif(t);
    }
    async registerSegment(e, t, i) {
        await this.file.ensureChunk(t, i);
        let n = this.file.subarray(t, i);
        this.createParser(e, n);
    }
    async findIcc(e) {
        let t = this.findBox(e, "iprp");
        if (void 0 === t) return;
        let i = this.findBox(t, "ipco");
        if (void 0 === i) return;
        let n = this.findBox(i, "colr");
        void 0 !== n && await this.registerSegment("icc", n.offset + 12, n.length);
    }
    async findExif(e) {
        let t = this.findBox(e, "iinf");
        if (void 0 === t) return;
        let i = this.findBox(e, "iloc");
        if (void 0 === i) return;
        let n = this.findExifLocIdInIinf(t), s = this.findExtentInIloc(i, n);
        if (void 0 === s) return;
        let [r, a] = s;
        await this.file.ensureChunk(r, a);
        let o = 4 + this.file.getUint32(r);
        r += o, a -= o, await this.registerSegment("tiff", r, a);
    }
    findExifLocIdInIinf(e) {
        this.parseBoxFullHead(e);
        let t, i, n, s, r = e.start, a = this.file.getUint16(r);
        for(r += 2; a--;){
            if (t = this.parseBoxHead(r), this.parseBoxFullHead(t), i = t.start, t.version >= 2 && (n = 3 === t.version ? 4 : 2, s = this.file.getString(i + n + 2, 4), "Exif" === s)) return this.file.getUintBytes(i, n);
            r += t.length;
        }
    }
    get8bits(e) {
        let t = this.file.getUint8(e);
        return [
            t >> 4,
            15 & t
        ];
    }
    findExtentInIloc(e, t) {
        this.parseBoxFullHead(e);
        let i = e.start, [n, s] = this.get8bits(i++), [r, a] = this.get8bits(i++), o = 2 === e.version ? 4 : 2, l = 1 === e.version || 2 === e.version ? 2 : 0, h = a + n + s, u = 2 === e.version ? 4 : 2, c = this.file.getUintBytes(i, u);
        for(i += u; c--;){
            let e = this.file.getUintBytes(i, o);
            i += o + l + 2 + r;
            let u = this.file.getUint16(i);
            if (i += 2, e === t) return u > 1 && console.warn("ILOC box has more than one extent but we're only processing one\nPlease create an issue at https://github.com/MikeKovarik/exifr with this file"), [
                this.file.getUintBytes(i + a, n),
                this.file.getUintBytes(i + a + n, s)
            ];
            i += u * h;
        }
    }
}
class Ue extends Le {
}
c(Ue, "type", "heic");
class Fe extends Le {
}
c(Fe, "type", "avif"), w.set("heic", Ue), w.set("avif", Fe), U(E, [
    "ifd0",
    "ifd1"
], [
    [
        256,
        "ImageWidth"
    ],
    [
        257,
        "ImageHeight"
    ],
    [
        258,
        "BitsPerSample"
    ],
    [
        259,
        "Compression"
    ],
    [
        262,
        "PhotometricInterpretation"
    ],
    [
        270,
        "ImageDescription"
    ],
    [
        271,
        "Make"
    ],
    [
        272,
        "Model"
    ],
    [
        273,
        "StripOffsets"
    ],
    [
        274,
        "Orientation"
    ],
    [
        277,
        "SamplesPerPixel"
    ],
    [
        278,
        "RowsPerStrip"
    ],
    [
        279,
        "StripByteCounts"
    ],
    [
        282,
        "XResolution"
    ],
    [
        283,
        "YResolution"
    ],
    [
        284,
        "PlanarConfiguration"
    ],
    [
        296,
        "ResolutionUnit"
    ],
    [
        301,
        "TransferFunction"
    ],
    [
        305,
        "Software"
    ],
    [
        306,
        "ModifyDate"
    ],
    [
        315,
        "Artist"
    ],
    [
        316,
        "HostComputer"
    ],
    [
        317,
        "Predictor"
    ],
    [
        318,
        "WhitePoint"
    ],
    [
        319,
        "PrimaryChromaticities"
    ],
    [
        513,
        "ThumbnailOffset"
    ],
    [
        514,
        "ThumbnailLength"
    ],
    [
        529,
        "YCbCrCoefficients"
    ],
    [
        530,
        "YCbCrSubSampling"
    ],
    [
        531,
        "YCbCrPositioning"
    ],
    [
        532,
        "ReferenceBlackWhite"
    ],
    [
        700,
        "ApplicationNotes"
    ],
    [
        33432,
        "Copyright"
    ],
    [
        33723,
        "IPTC"
    ],
    [
        34665,
        "ExifIFD"
    ],
    [
        34675,
        "ICC"
    ],
    [
        34853,
        "GpsIFD"
    ],
    [
        330,
        "SubIFD"
    ],
    [
        40965,
        "InteropIFD"
    ],
    [
        40091,
        "XPTitle"
    ],
    [
        40092,
        "XPComment"
    ],
    [
        40093,
        "XPAuthor"
    ],
    [
        40094,
        "XPKeywords"
    ],
    [
        40095,
        "XPSubject"
    ]
]), U(E, "exif", [
    [
        33434,
        "ExposureTime"
    ],
    [
        33437,
        "FNumber"
    ],
    [
        34850,
        "ExposureProgram"
    ],
    [
        34852,
        "SpectralSensitivity"
    ],
    [
        34855,
        "ISO"
    ],
    [
        34858,
        "TimeZoneOffset"
    ],
    [
        34859,
        "SelfTimerMode"
    ],
    [
        34864,
        "SensitivityType"
    ],
    [
        34865,
        "StandardOutputSensitivity"
    ],
    [
        34866,
        "RecommendedExposureIndex"
    ],
    [
        34867,
        "ISOSpeed"
    ],
    [
        34868,
        "ISOSpeedLatitudeyyy"
    ],
    [
        34869,
        "ISOSpeedLatitudezzz"
    ],
    [
        36864,
        "ExifVersion"
    ],
    [
        36867,
        "DateTimeOriginal"
    ],
    [
        36868,
        "CreateDate"
    ],
    [
        36873,
        "GooglePlusUploadCode"
    ],
    [
        36880,
        "OffsetTime"
    ],
    [
        36881,
        "OffsetTimeOriginal"
    ],
    [
        36882,
        "OffsetTimeDigitized"
    ],
    [
        37121,
        "ComponentsConfiguration"
    ],
    [
        37122,
        "CompressedBitsPerPixel"
    ],
    [
        37377,
        "ShutterSpeedValue"
    ],
    [
        37378,
        "ApertureValue"
    ],
    [
        37379,
        "BrightnessValue"
    ],
    [
        37380,
        "ExposureCompensation"
    ],
    [
        37381,
        "MaxApertureValue"
    ],
    [
        37382,
        "SubjectDistance"
    ],
    [
        37383,
        "MeteringMode"
    ],
    [
        37384,
        "LightSource"
    ],
    [
        37385,
        "Flash"
    ],
    [
        37386,
        "FocalLength"
    ],
    [
        37393,
        "ImageNumber"
    ],
    [
        37394,
        "SecurityClassification"
    ],
    [
        37395,
        "ImageHistory"
    ],
    [
        37396,
        "SubjectArea"
    ],
    [
        37500,
        "MakerNote"
    ],
    [
        37510,
        "UserComment"
    ],
    [
        37520,
        "SubSecTime"
    ],
    [
        37521,
        "SubSecTimeOriginal"
    ],
    [
        37522,
        "SubSecTimeDigitized"
    ],
    [
        37888,
        "AmbientTemperature"
    ],
    [
        37889,
        "Humidity"
    ],
    [
        37890,
        "Pressure"
    ],
    [
        37891,
        "WaterDepth"
    ],
    [
        37892,
        "Acceleration"
    ],
    [
        37893,
        "CameraElevationAngle"
    ],
    [
        40960,
        "FlashpixVersion"
    ],
    [
        40961,
        "ColorSpace"
    ],
    [
        40962,
        "ExifImageWidth"
    ],
    [
        40963,
        "ExifImageHeight"
    ],
    [
        40964,
        "RelatedSoundFile"
    ],
    [
        41483,
        "FlashEnergy"
    ],
    [
        41486,
        "FocalPlaneXResolution"
    ],
    [
        41487,
        "FocalPlaneYResolution"
    ],
    [
        41488,
        "FocalPlaneResolutionUnit"
    ],
    [
        41492,
        "SubjectLocation"
    ],
    [
        41493,
        "ExposureIndex"
    ],
    [
        41495,
        "SensingMethod"
    ],
    [
        41728,
        "FileSource"
    ],
    [
        41729,
        "SceneType"
    ],
    [
        41730,
        "CFAPattern"
    ],
    [
        41985,
        "CustomRendered"
    ],
    [
        41986,
        "ExposureMode"
    ],
    [
        41987,
        "WhiteBalance"
    ],
    [
        41988,
        "DigitalZoomRatio"
    ],
    [
        41989,
        "FocalLengthIn35mmFormat"
    ],
    [
        41990,
        "SceneCaptureType"
    ],
    [
        41991,
        "GainControl"
    ],
    [
        41992,
        "Contrast"
    ],
    [
        41993,
        "Saturation"
    ],
    [
        41994,
        "Sharpness"
    ],
    [
        41996,
        "SubjectDistanceRange"
    ],
    [
        42016,
        "ImageUniqueID"
    ],
    [
        42032,
        "OwnerName"
    ],
    [
        42033,
        "SerialNumber"
    ],
    [
        42034,
        "LensInfo"
    ],
    [
        42035,
        "LensMake"
    ],
    [
        42036,
        "LensModel"
    ],
    [
        42037,
        "LensSerialNumber"
    ],
    [
        42080,
        "CompositeImage"
    ],
    [
        42081,
        "CompositeImageCount"
    ],
    [
        42082,
        "CompositeImageExposureTimes"
    ],
    [
        42240,
        "Gamma"
    ],
    [
        59932,
        "Padding"
    ],
    [
        59933,
        "OffsetSchema"
    ],
    [
        65e3,
        "OwnerName"
    ],
    [
        65001,
        "SerialNumber"
    ],
    [
        65002,
        "Lens"
    ],
    [
        65100,
        "RawFile"
    ],
    [
        65101,
        "Converter"
    ],
    [
        65102,
        "WhiteBalance"
    ],
    [
        65105,
        "Exposure"
    ],
    [
        65106,
        "Shadows"
    ],
    [
        65107,
        "Brightness"
    ],
    [
        65108,
        "Contrast"
    ],
    [
        65109,
        "Saturation"
    ],
    [
        65110,
        "Sharpness"
    ],
    [
        65111,
        "Smoothness"
    ],
    [
        65112,
        "MoireFilter"
    ],
    [
        40965,
        "InteropIFD"
    ]
]), U(E, "gps", [
    [
        0,
        "GPSVersionID"
    ],
    [
        1,
        "GPSLatitudeRef"
    ],
    [
        2,
        "GPSLatitude"
    ],
    [
        3,
        "GPSLongitudeRef"
    ],
    [
        4,
        "GPSLongitude"
    ],
    [
        5,
        "GPSAltitudeRef"
    ],
    [
        6,
        "GPSAltitude"
    ],
    [
        7,
        "GPSTimeStamp"
    ],
    [
        8,
        "GPSSatellites"
    ],
    [
        9,
        "GPSStatus"
    ],
    [
        10,
        "GPSMeasureMode"
    ],
    [
        11,
        "GPSDOP"
    ],
    [
        12,
        "GPSSpeedRef"
    ],
    [
        13,
        "GPSSpeed"
    ],
    [
        14,
        "GPSTrackRef"
    ],
    [
        15,
        "GPSTrack"
    ],
    [
        16,
        "GPSImgDirectionRef"
    ],
    [
        17,
        "GPSImgDirection"
    ],
    [
        18,
        "GPSMapDatum"
    ],
    [
        19,
        "GPSDestLatitudeRef"
    ],
    [
        20,
        "GPSDestLatitude"
    ],
    [
        21,
        "GPSDestLongitudeRef"
    ],
    [
        22,
        "GPSDestLongitude"
    ],
    [
        23,
        "GPSDestBearingRef"
    ],
    [
        24,
        "GPSDestBearing"
    ],
    [
        25,
        "GPSDestDistanceRef"
    ],
    [
        26,
        "GPSDestDistance"
    ],
    [
        27,
        "GPSProcessingMethod"
    ],
    [
        28,
        "GPSAreaInformation"
    ],
    [
        29,
        "GPSDateStamp"
    ],
    [
        30,
        "GPSDifferential"
    ],
    [
        31,
        "GPSHPositioningError"
    ]
]), U(B, [
    "ifd0",
    "ifd1"
], [
    [
        274,
        {
            1: "Horizontal (normal)",
            2: "Mirror horizontal",
            3: "Rotate 180",
            4: "Mirror vertical",
            5: "Mirror horizontal and rotate 270 CW",
            6: "Rotate 90 CW",
            7: "Mirror horizontal and rotate 90 CW",
            8: "Rotate 270 CW"
        }
    ],
    [
        296,
        {
            1: "None",
            2: "inches",
            3: "cm"
        }
    ]
]);
let Ee = U(B, "exif", [
    [
        34850,
        {
            0: "Not defined",
            1: "Manual",
            2: "Normal program",
            3: "Aperture priority",
            4: "Shutter priority",
            5: "Creative program",
            6: "Action program",
            7: "Portrait mode",
            8: "Landscape mode"
        }
    ],
    [
        37121,
        {
            0: "-",
            1: "Y",
            2: "Cb",
            3: "Cr",
            4: "R",
            5: "G",
            6: "B"
        }
    ],
    [
        37383,
        {
            0: "Unknown",
            1: "Average",
            2: "CenterWeightedAverage",
            3: "Spot",
            4: "MultiSpot",
            5: "Pattern",
            6: "Partial",
            255: "Other"
        }
    ],
    [
        37384,
        {
            0: "Unknown",
            1: "Daylight",
            2: "Fluorescent",
            3: "Tungsten (incandescent light)",
            4: "Flash",
            9: "Fine weather",
            10: "Cloudy weather",
            11: "Shade",
            12: "Daylight fluorescent (D 5700 - 7100K)",
            13: "Day white fluorescent (N 4600 - 5400K)",
            14: "Cool white fluorescent (W 3900 - 4500K)",
            15: "White fluorescent (WW 3200 - 3700K)",
            17: "Standard light A",
            18: "Standard light B",
            19: "Standard light C",
            20: "D55",
            21: "D65",
            22: "D75",
            23: "D50",
            24: "ISO studio tungsten",
            255: "Other"
        }
    ],
    [
        37385,
        {
            0: "Flash did not fire",
            1: "Flash fired",
            5: "Strobe return light not detected",
            7: "Strobe return light detected",
            9: "Flash fired, compulsory flash mode",
            13: "Flash fired, compulsory flash mode, return light not detected",
            15: "Flash fired, compulsory flash mode, return light detected",
            16: "Flash did not fire, compulsory flash mode",
            24: "Flash did not fire, auto mode",
            25: "Flash fired, auto mode",
            29: "Flash fired, auto mode, return light not detected",
            31: "Flash fired, auto mode, return light detected",
            32: "No flash function",
            65: "Flash fired, red-eye reduction mode",
            69: "Flash fired, red-eye reduction mode, return light not detected",
            71: "Flash fired, red-eye reduction mode, return light detected",
            73: "Flash fired, compulsory flash mode, red-eye reduction mode",
            77: "Flash fired, compulsory flash mode, red-eye reduction mode, return light not detected",
            79: "Flash fired, compulsory flash mode, red-eye reduction mode, return light detected",
            89: "Flash fired, auto mode, red-eye reduction mode",
            93: "Flash fired, auto mode, return light not detected, red-eye reduction mode",
            95: "Flash fired, auto mode, return light detected, red-eye reduction mode"
        }
    ],
    [
        41495,
        {
            1: "Not defined",
            2: "One-chip color area sensor",
            3: "Two-chip color area sensor",
            4: "Three-chip color area sensor",
            5: "Color sequential area sensor",
            7: "Trilinear sensor",
            8: "Color sequential linear sensor"
        }
    ],
    [
        41728,
        {
            1: "Film Scanner",
            2: "Reflection Print Scanner",
            3: "Digital Camera"
        }
    ],
    [
        41729,
        {
            1: "Directly photographed"
        }
    ],
    [
        41985,
        {
            0: "Normal",
            1: "Custom",
            2: "HDR (no original saved)",
            3: "HDR (original saved)",
            4: "Original (for HDR)",
            6: "Panorama",
            7: "Portrait HDR",
            8: "Portrait"
        }
    ],
    [
        41986,
        {
            0: "Auto",
            1: "Manual",
            2: "Auto bracket"
        }
    ],
    [
        41987,
        {
            0: "Auto",
            1: "Manual"
        }
    ],
    [
        41990,
        {
            0: "Standard",
            1: "Landscape",
            2: "Portrait",
            3: "Night",
            4: "Other"
        }
    ],
    [
        41991,
        {
            0: "None",
            1: "Low gain up",
            2: "High gain up",
            3: "Low gain down",
            4: "High gain down"
        }
    ],
    [
        41996,
        {
            0: "Unknown",
            1: "Macro",
            2: "Close",
            3: "Distant"
        }
    ],
    [
        42080,
        {
            0: "Unknown",
            1: "Not a Composite Image",
            2: "General Composite Image",
            3: "Composite Image Captured While Shooting"
        }
    ]
]);
const Be = {
    1: "No absolute unit of measurement",
    2: "Inch",
    3: "Centimeter"
};
Ee.set(37392, Be), Ee.set(41488, Be);
const Ne = {
    0: "Normal",
    1: "Low",
    2: "High"
};
function Ge(e) {
    return "object" == typeof e && void 0 !== e.length ? e[0] : e;
}
function Ve(e) {
    let t = Array.from(e).slice(1);
    return t[1] > 15 && (t = t.map((e)=>String.fromCharCode(e))), "0" !== t[2] && 0 !== t[2] || t.pop(), t.join(".");
}
function ze(e) {
    if ("string" == typeof e) {
        var [t, i, n, s, r, a] = e.trim().split(/[-: ]/g).map(Number), o = new Date(t, i - 1, n);
        return Number.isNaN(s) || Number.isNaN(r) || Number.isNaN(a) || (o.setHours(s), o.setMinutes(r), o.setSeconds(a)), Number.isNaN(+o) ? e : o;
    }
}
function He(e) {
    if ("string" == typeof e) return e;
    let t = [];
    if (0 === e[1] && 0 === e[e.length - 1]) for(let i = 0; i < e.length; i += 2)t.push(je(e[i + 1], e[i]));
    else for(let i = 0; i < e.length; i += 2)t.push(je(e[i], e[i + 1]));
    return m(String.fromCodePoint(...t));
}
function je(e, t) {
    return e << 8 | t;
}
Ee.set(41992, Ne), Ee.set(41993, Ne), Ee.set(41994, Ne), U(N, [
    "ifd0",
    "ifd1"
], [
    [
        50827,
        function(e) {
            return "string" != typeof e ? b(e) : e;
        }
    ],
    [
        306,
        ze
    ],
    [
        40091,
        He
    ],
    [
        40092,
        He
    ],
    [
        40093,
        He
    ],
    [
        40094,
        He
    ],
    [
        40095,
        He
    ]
]), U(N, "exif", [
    [
        40960,
        Ve
    ],
    [
        36864,
        Ve
    ],
    [
        36867,
        ze
    ],
    [
        36868,
        ze
    ],
    [
        40962,
        Ge
    ],
    [
        40963,
        Ge
    ]
]), U(N, "gps", [
    [
        0,
        (e)=>Array.from(e).join(".")
    ],
    [
        7,
        (e)=>Array.from(e).join(":")
    ]
]);
class We extends re {
    static canHandle(e, t) {
        return 225 === e.getUint8(t + 1) && 1752462448 === e.getUint32(t + 4) && "http://ns.adobe.com/" === e.getString(t + 4, "http://ns.adobe.com/".length);
    }
    static headerLength(e, t) {
        return "http://ns.adobe.com/xmp/extension/" === e.getString(t + 4, "http://ns.adobe.com/xmp/extension/".length) ? 79 : 4 + "http://ns.adobe.com/xap/1.0/".length + 1;
    }
    static findPosition(e, t) {
        let i = super.findPosition(e, t);
        return i.multiSegment = i.extended = 79 === i.headerLength, i.multiSegment ? (i.chunkCount = e.getUint8(t + 72), i.chunkNumber = e.getUint8(t + 76), 0 !== e.getUint8(t + 77) && i.chunkNumber++) : (i.chunkCount = 1 / 0, i.chunkNumber = -1), i;
    }
    static handleMultiSegments(e) {
        return e.map((e)=>e.chunk.getString()).join("");
    }
    normalizeInput(e) {
        return "string" == typeof e ? e : I.from(e).getString();
    }
    parse(e = this.chunk) {
        if (!this.localOptions.parse) return e;
        e = function(e) {
            let t = {}, i = {};
            for (let e of Ze)t[e] = [], i[e] = 0;
            return e.replace(et, (e, n, s)=>{
                if ("<" === n) {
                    let n = ++i[s];
                    return t[s].push(n), `${e}#${n}`;
                }
                return `${e}#${t[s].pop()}`;
            });
        }(e);
        let t = Xe.findAll(e, "rdf", "Description");
        0 === t.length && t.push(new Xe("rdf", "Description", void 0, e));
        let i, n = {};
        for (let e of t)for (let t of e.properties)i = Je(t.ns, n), _e(t, i);
        return function(e) {
            let t;
            for(let i in e)t = e[i] = f(e[i]), void 0 === t && delete e[i];
            return f(e);
        }(n);
    }
    assignToOutput(e, t) {
        if (this.localOptions.parse) for (let [i, n] of Object.entries(t))switch(i){
            case "tiff":
                this.assignObjectToOutput(e, "ifd0", n);
                break;
            case "exif":
                this.assignObjectToOutput(e, "exif", n);
                break;
            case "xmlns":
                break;
            default:
                this.assignObjectToOutput(e, i, n);
        }
        else e.xmp = t;
    }
}
c(We, "type", "xmp"), c(We, "multiSegment", !0), T.set("xmp", We);
class Ke {
    static findAll(e) {
        return qe(e, /([a-zA-Z0-9-]+):([a-zA-Z0-9-]+)=("[^"]*"|'[^']*')/gm).map(Ke.unpackMatch);
    }
    static unpackMatch(e) {
        let t = e[1], i = e[2], n = e[3].slice(1, -1);
        return n = Qe(n), new Ke(t, i, n);
    }
    constructor(e, t, i){
        this.ns = e, this.name = t, this.value = i;
    }
    serialize() {
        return this.value;
    }
}
class Xe {
    static findAll(e, t, i) {
        if (void 0 !== t || void 0 !== i) {
            t = t || "[\\w\\d-]+", i = i || "[\\w\\d-]+";
            var n = new RegExp(`<(${t}):(${i})(#\\d+)?((\\s+?[\\w\\d-:]+=("[^"]*"|'[^']*'))*\\s*)(\\/>|>([\\s\\S]*?)<\\/\\1:\\2\\3>)`, "gm");
        } else n = /<([\w\d-]+):([\w\d-]+)(#\d+)?((\s+?[\w\d-:]+=("[^"]*"|'[^']*'))*\s*)(\/>|>([\s\S]*?)<\/\1:\2\3>)/gm;
        return qe(e, n).map(Xe.unpackMatch);
    }
    static unpackMatch(e) {
        let t = e[1], i = e[2], n = e[4], s = e[8];
        return new Xe(t, i, n, s);
    }
    constructor(e, t, i, n){
        this.ns = e, this.name = t, this.attrString = i, this.innerXml = n, this.attrs = Ke.findAll(i), this.children = Xe.findAll(n), this.value = 0 === this.children.length ? Qe(n) : void 0, this.properties = [
            ...this.attrs,
            ...this.children
        ];
    }
    get isPrimitive() {
        return void 0 !== this.value && 0 === this.attrs.length && 0 === this.children.length;
    }
    get isListContainer() {
        return 1 === this.children.length && this.children[0].isList;
    }
    get isList() {
        let { ns: e, name: t } = this;
        return "rdf" === e && ("Seq" === t || "Bag" === t || "Alt" === t);
    }
    get isListItem() {
        return "rdf" === this.ns && "li" === this.name;
    }
    serialize() {
        if (0 === this.properties.length && void 0 === this.value) return;
        if (this.isPrimitive) return this.value;
        if (this.isListContainer) return this.children[0].serialize();
        if (this.isList) return $e(this.children.map(Ye));
        if (this.isListItem && 1 === this.children.length && 0 === this.attrs.length) return this.children[0].serialize();
        let e = {};
        for (let t of this.properties)_e(t, e);
        return void 0 !== this.value && (e.value = this.value), f(e);
    }
}
function _e(e, t) {
    let i = e.serialize();
    void 0 !== i && (t[e.name] = i);
}
var Ye = (e)=>e.serialize(), $e = (e)=>1 === e.length ? e[0] : e, Je = (e, t)=>t[e] ? t[e] : t[e] = {};
function qe(e, t) {
    let i, n = [];
    if (!e) return n;
    for(; null !== (i = t.exec(e));)n.push(i);
    return n;
}
function Qe(e) {
    if (function(e) {
        return null == e || "null" === e || "undefined" === e || "" === e || "" === e.trim();
    }(e)) return;
    let t = Number(e);
    if (!Number.isNaN(t)) return t;
    let i = e.toLowerCase();
    return "true" === i || "false" !== i && e.trim();
}
const Ze = [
    "rdf:li",
    "rdf:Seq",
    "rdf:Bag",
    "rdf:Alt",
    "rdf:Description"
], et = new RegExp(`(<|\\/)(${Ze.join("|")})`, "g");
var tt = Object.freeze({
    __proto__: null,
    default: Me,
    Exifr: te,
    fileParsers: w,
    segmentParsers: T,
    fileReaders: A,
    tagKeys: E,
    tagValues: B,
    tagRevivers: N,
    createDictionary: U,
    extendDictionary: F,
    fetchUrlAsArrayBuffer: M,
    readBlobAsArrayBuffer: R,
    chunkedProps: G,
    otherSegments: V,
    segments: z,
    tiffBlocks: H,
    segmentsAndBlocks: j,
    tiffExtractables: W,
    inheritables: K,
    allFormatters: X,
    Options: q,
    parse: ie,
    gpsOnlyOptions: me,
    gps: Se,
    thumbnailOnlyOptions: Ce,
    thumbnail: ye,
    thumbnailUrl: be,
    orientationOnlyOptions: Ie,
    orientation: Pe,
    rotations: ke,
    get rotateCanvas () {
        return we;
    },
    get rotateCss () {
        return Te;
    },
    rotation: Ae
});
const it = [
    "xmp",
    "icc",
    "iptc",
    "tiff"
], nt = ()=>{};
async function st(e, t, i) {
    let n = new q(t);
    n.chunked = !1, void 0 === i && "string" == typeof e && (i = function(e) {
        let t = e.toLowerCase().split(".").pop();
        if (function(e) {
            return "exif" === e || "tiff" === e || "tif" === e;
        }(t)) return "tiff";
        if (it.includes(t)) return t;
    }(e));
    let s = await D(e, n);
    if (i) {
        if (it.includes(i)) return rt(i, s, n);
        g("Invalid segment type");
    } else {
        if (function(e) {
            let t = e.getString(0, 50).trim();
            return t.includes("<?xpacket") || t.includes("<x:");
        }(s)) return rt("xmp", s, n);
        for (let [e] of T){
            if (!it.includes(e)) continue;
            let t = await rt(e, s, n).catch(nt);
            if (t) return t;
        }
        g("Unknown file format");
    }
}
async function rt(e, t, i) {
    let n = i[e];
    return n.enabled = !0, n.parse = !0, T.get(e).parse(t, n);
}
let at = l("fs", (e)=>e.promises);
A.set("fs", class extends ve {
    async readWhole() {
        this.chunked = !1, this.fs = await at;
        let e = await this.fs.readFile(this.input);
        this._swapBuffer(e);
    }
    async readChunked() {
        this.chunked = !0, this.fs = await at, await this.open(), await this.readChunk(0, this.options.firstChunkSize);
    }
    async open() {
        void 0 === this.fh && (this.fh = await this.fs.open(this.input, "r"), this.size = (await this.fh.stat(this.input)).size);
    }
    async _readChunk(e, t) {
        void 0 === this.fh && await this.open(), e + t > this.size && (t = this.size - e);
        var i = this.subarray(e, t, !0);
        return await this.fh.read(i.dataView, 0, t, e), i;
    }
    async close() {
        if (this.fh) {
            let e = this.fh;
            this.fh = void 0, await e.close();
        }
    }
});
A.set("base64", class extends ve {
    constructor(...e){
        super(...e), this.input = this.input.replace(/^data:([^;]+);base64,/gim, ""), this.size = this.input.length / 4 * 3, this.input.endsWith("==") ? this.size -= 2 : this.input.endsWith("=") && (this.size -= 1);
    }
    async _readChunk(e, t) {
        let i, n, r = this.input;
        void 0 === e ? (e = 0, i = 0, n = 0) : (i = 4 * Math.floor(e / 3), n = e - i / 4 * 3), void 0 === t && (t = this.size);
        let o = e + t, l = i + 4 * Math.ceil(o / 3);
        r = r.slice(i, l);
        let h = Math.min(t, this.size - e);
        if (a) {
            let t = s.from(r, "base64").slice(n, n + h);
            return this.set(t, e, !0);
        }
        {
            let t = this.subarray(e, h, !0), i = atob(r), s = t.toUint8();
            for(let e = 0; e < h; e++)s[e] = i.charCodeAt(n + e);
            return t;
        }
    }
});
class ot extends se {
    static canHandle(e, t) {
        return 18761 === t || 19789 === t;
    }
    extendOptions(e) {
        let { ifd0: t, xmp: i, iptc: n, icc: s } = e;
        i.enabled && t.deps.add(700), n.enabled && t.deps.add(33723), s.enabled && t.deps.add(34675), t.finalizeFilters();
    }
    async parse() {
        let { tiff: e, xmp: t, iptc: i, icc: n } = this.options;
        if (e.enabled || t.enabled || i.enabled || n.enabled) {
            let e = Math.max(S(this.options), this.options.chunkSize);
            await this.file.ensureChunk(0, e), this.createParser("tiff", this.file), this.parsers.tiff.parseHeader(), await this.parsers.tiff.parseIfd0Block(), this.adaptTiffPropAsSegment("xmp"), this.adaptTiffPropAsSegment("iptc"), this.adaptTiffPropAsSegment("icc");
        }
    }
    adaptTiffPropAsSegment(e) {
        if (this.parsers.tiff[e]) {
            let t = this.parsers.tiff[e];
            this.injectSegment(e, t);
        }
    }
}
c(ot, "type", "tiff"), w.set("tiff", ot);
let lt = l("zlib");
const ht = [
    "ihdr",
    "iccp",
    "text",
    "itxt",
    "exif"
];
class ut extends se {
    constructor(...e){
        super(...e), c(this, "catchError", (e)=>this.errors.push(e)), c(this, "metaChunks", []), c(this, "unknownChunks", []);
    }
    static canHandle(e, t) {
        return 35152 === t && 2303741511 === e.getUint32(0) && 218765834 === e.getUint32(4);
    }
    async parse() {
        let { file: e } = this;
        await this.findPngChunksInRange("PNG\r\n\n".length, e.byteLength), await this.readSegments(this.metaChunks), this.findIhdr(), this.parseTextChunks(), await this.findExif().catch(this.catchError), await this.findXmp().catch(this.catchError), await this.findIcc().catch(this.catchError);
    }
    async findPngChunksInRange(e, t) {
        let { file: i } = this;
        for(; e < t;){
            let t = i.getUint32(e), n = i.getUint32(e + 4), s = i.getString(e + 4, 4).toLowerCase(), r = t + 4 + 4 + 4, a = {
                type: s,
                offset: e,
                length: r,
                start: e + 4 + 4,
                size: t,
                marker: n
            };
            ht.includes(s) ? this.metaChunks.push(a) : this.unknownChunks.push(a), e += r;
        }
    }
    parseTextChunks() {
        let e = this.metaChunks.filter((e)=>"text" === e.type);
        for (let t of e){
            let [e, i] = this.file.getString(t.start, t.size).split("\0");
            this.injectKeyValToIhdr(e, i);
        }
    }
    injectKeyValToIhdr(e, t) {
        let i = this.parsers.ihdr;
        i && i.raw.set(e, t);
    }
    findIhdr() {
        let e = this.metaChunks.find((e)=>"ihdr" === e.type);
        e && !1 !== this.options.ihdr.enabled && this.createParser("ihdr", e.chunk);
    }
    async findExif() {
        let e = this.metaChunks.find((e)=>"exif" === e.type);
        e && this.injectSegment("tiff", e.chunk);
    }
    async findXmp() {
        let e = this.metaChunks.filter((e)=>"itxt" === e.type);
        for (let t of e){
            "XML:com.adobe.xmp" === t.chunk.getString(0, "XML:com.adobe.xmp".length) && this.injectSegment("xmp", t.chunk);
        }
    }
    async findIcc() {
        let e = this.metaChunks.find((e)=>"iccp" === e.type);
        if (!e) return;
        let { chunk: t } = e, i = t.getUint8Array(0, 81), s = 0;
        for(; s < 80 && 0 !== i[s];)s++;
        let r = s + 2, a = t.getString(0, s);
        if (this.injectKeyValToIhdr("ProfileName", a), n) {
            let e = await lt, i = t.getUint8Array(r);
            i = e.inflateSync(i), this.injectSegment("icc", i);
        }
    }
}
c(ut, "type", "png"), w.set("png", ut), U(E, "interop", [
    [
        1,
        "InteropIndex"
    ],
    [
        2,
        "InteropVersion"
    ],
    [
        4096,
        "RelatedImageFileFormat"
    ],
    [
        4097,
        "RelatedImageWidth"
    ],
    [
        4098,
        "RelatedImageHeight"
    ]
]), F(E, "ifd0", [
    [
        11,
        "ProcessingSoftware"
    ],
    [
        254,
        "SubfileType"
    ],
    [
        255,
        "OldSubfileType"
    ],
    [
        263,
        "Thresholding"
    ],
    [
        264,
        "CellWidth"
    ],
    [
        265,
        "CellLength"
    ],
    [
        266,
        "FillOrder"
    ],
    [
        269,
        "DocumentName"
    ],
    [
        280,
        "MinSampleValue"
    ],
    [
        281,
        "MaxSampleValue"
    ],
    [
        285,
        "PageName"
    ],
    [
        286,
        "XPosition"
    ],
    [
        287,
        "YPosition"
    ],
    [
        290,
        "GrayResponseUnit"
    ],
    [
        297,
        "PageNumber"
    ],
    [
        321,
        "HalftoneHints"
    ],
    [
        322,
        "TileWidth"
    ],
    [
        323,
        "TileLength"
    ],
    [
        332,
        "InkSet"
    ],
    [
        337,
        "TargetPrinter"
    ],
    [
        18246,
        "Rating"
    ],
    [
        18249,
        "RatingPercent"
    ],
    [
        33550,
        "PixelScale"
    ],
    [
        34264,
        "ModelTransform"
    ],
    [
        34377,
        "PhotoshopSettings"
    ],
    [
        50706,
        "DNGVersion"
    ],
    [
        50707,
        "DNGBackwardVersion"
    ],
    [
        50708,
        "UniqueCameraModel"
    ],
    [
        50709,
        "LocalizedCameraModel"
    ],
    [
        50736,
        "DNGLensInfo"
    ],
    [
        50739,
        "ShadowScale"
    ],
    [
        50740,
        "DNGPrivateData"
    ],
    [
        33920,
        "IntergraphMatrix"
    ],
    [
        33922,
        "ModelTiePoint"
    ],
    [
        34118,
        "SEMInfo"
    ],
    [
        34735,
        "GeoTiffDirectory"
    ],
    [
        34736,
        "GeoTiffDoubleParams"
    ],
    [
        34737,
        "GeoTiffAsciiParams"
    ],
    [
        50341,
        "PrintIM"
    ],
    [
        50721,
        "ColorMatrix1"
    ],
    [
        50722,
        "ColorMatrix2"
    ],
    [
        50723,
        "CameraCalibration1"
    ],
    [
        50724,
        "CameraCalibration2"
    ],
    [
        50725,
        "ReductionMatrix1"
    ],
    [
        50726,
        "ReductionMatrix2"
    ],
    [
        50727,
        "AnalogBalance"
    ],
    [
        50728,
        "AsShotNeutral"
    ],
    [
        50729,
        "AsShotWhiteXY"
    ],
    [
        50730,
        "BaselineExposure"
    ],
    [
        50731,
        "BaselineNoise"
    ],
    [
        50732,
        "BaselineSharpness"
    ],
    [
        50734,
        "LinearResponseLimit"
    ],
    [
        50735,
        "CameraSerialNumber"
    ],
    [
        50741,
        "MakerNoteSafety"
    ],
    [
        50778,
        "CalibrationIlluminant1"
    ],
    [
        50779,
        "CalibrationIlluminant2"
    ],
    [
        50781,
        "RawDataUniqueID"
    ],
    [
        50827,
        "OriginalRawFileName"
    ],
    [
        50828,
        "OriginalRawFileData"
    ],
    [
        50831,
        "AsShotICCProfile"
    ],
    [
        50832,
        "AsShotPreProfileMatrix"
    ],
    [
        50833,
        "CurrentICCProfile"
    ],
    [
        50834,
        "CurrentPreProfileMatrix"
    ],
    [
        50879,
        "ColorimetricReference"
    ],
    [
        50885,
        "SRawType"
    ],
    [
        50898,
        "PanasonicTitle"
    ],
    [
        50899,
        "PanasonicTitle2"
    ],
    [
        50931,
        "CameraCalibrationSig"
    ],
    [
        50932,
        "ProfileCalibrationSig"
    ],
    [
        50933,
        "ProfileIFD"
    ],
    [
        50934,
        "AsShotProfileName"
    ],
    [
        50936,
        "ProfileName"
    ],
    [
        50937,
        "ProfileHueSatMapDims"
    ],
    [
        50938,
        "ProfileHueSatMapData1"
    ],
    [
        50939,
        "ProfileHueSatMapData2"
    ],
    [
        50940,
        "ProfileToneCurve"
    ],
    [
        50941,
        "ProfileEmbedPolicy"
    ],
    [
        50942,
        "ProfileCopyright"
    ],
    [
        50964,
        "ForwardMatrix1"
    ],
    [
        50965,
        "ForwardMatrix2"
    ],
    [
        50966,
        "PreviewApplicationName"
    ],
    [
        50967,
        "PreviewApplicationVersion"
    ],
    [
        50968,
        "PreviewSettingsName"
    ],
    [
        50969,
        "PreviewSettingsDigest"
    ],
    [
        50970,
        "PreviewColorSpace"
    ],
    [
        50971,
        "PreviewDateTime"
    ],
    [
        50972,
        "RawImageDigest"
    ],
    [
        50973,
        "OriginalRawFileDigest"
    ],
    [
        50981,
        "ProfileLookTableDims"
    ],
    [
        50982,
        "ProfileLookTableData"
    ],
    [
        51043,
        "TimeCodes"
    ],
    [
        51044,
        "FrameRate"
    ],
    [
        51058,
        "TStop"
    ],
    [
        51081,
        "ReelName"
    ],
    [
        51089,
        "OriginalDefaultFinalSize"
    ],
    [
        51090,
        "OriginalBestQualitySize"
    ],
    [
        51091,
        "OriginalDefaultCropSize"
    ],
    [
        51105,
        "CameraLabel"
    ],
    [
        51107,
        "ProfileHueSatMapEncoding"
    ],
    [
        51108,
        "ProfileLookTableEncoding"
    ],
    [
        51109,
        "BaselineExposureOffset"
    ],
    [
        51110,
        "DefaultBlackRender"
    ],
    [
        51111,
        "NewRawImageDigest"
    ],
    [
        51112,
        "RawToPreviewGain"
    ]
]);
let ct = [
    [
        273,
        "StripOffsets"
    ],
    [
        279,
        "StripByteCounts"
    ],
    [
        288,
        "FreeOffsets"
    ],
    [
        289,
        "FreeByteCounts"
    ],
    [
        291,
        "GrayResponseCurve"
    ],
    [
        292,
        "T4Options"
    ],
    [
        293,
        "T6Options"
    ],
    [
        300,
        "ColorResponseUnit"
    ],
    [
        320,
        "ColorMap"
    ],
    [
        324,
        "TileOffsets"
    ],
    [
        325,
        "TileByteCounts"
    ],
    [
        326,
        "BadFaxLines"
    ],
    [
        327,
        "CleanFaxData"
    ],
    [
        328,
        "ConsecutiveBadFaxLines"
    ],
    [
        330,
        "SubIFD"
    ],
    [
        333,
        "InkNames"
    ],
    [
        334,
        "NumberofInks"
    ],
    [
        336,
        "DotRange"
    ],
    [
        338,
        "ExtraSamples"
    ],
    [
        339,
        "SampleFormat"
    ],
    [
        340,
        "SMinSampleValue"
    ],
    [
        341,
        "SMaxSampleValue"
    ],
    [
        342,
        "TransferRange"
    ],
    [
        343,
        "ClipPath"
    ],
    [
        344,
        "XClipPathUnits"
    ],
    [
        345,
        "YClipPathUnits"
    ],
    [
        346,
        "Indexed"
    ],
    [
        347,
        "JPEGTables"
    ],
    [
        351,
        "OPIProxy"
    ],
    [
        400,
        "GlobalParametersIFD"
    ],
    [
        401,
        "ProfileType"
    ],
    [
        402,
        "FaxProfile"
    ],
    [
        403,
        "CodingMethods"
    ],
    [
        404,
        "VersionYear"
    ],
    [
        405,
        "ModeNumber"
    ],
    [
        433,
        "Decode"
    ],
    [
        434,
        "DefaultImageColor"
    ],
    [
        435,
        "T82Options"
    ],
    [
        437,
        "JPEGTables"
    ],
    [
        512,
        "JPEGProc"
    ],
    [
        515,
        "JPEGRestartInterval"
    ],
    [
        517,
        "JPEGLosslessPredictors"
    ],
    [
        518,
        "JPEGPointTransforms"
    ],
    [
        519,
        "JPEGQTables"
    ],
    [
        520,
        "JPEGDCTables"
    ],
    [
        521,
        "JPEGACTables"
    ],
    [
        559,
        "StripRowCounts"
    ],
    [
        999,
        "USPTOMiscellaneous"
    ],
    [
        18247,
        "XP_DIP_XML"
    ],
    [
        18248,
        "StitchInfo"
    ],
    [
        28672,
        "SonyRawFileType"
    ],
    [
        28688,
        "SonyToneCurve"
    ],
    [
        28721,
        "VignettingCorrection"
    ],
    [
        28722,
        "VignettingCorrParams"
    ],
    [
        28724,
        "ChromaticAberrationCorrection"
    ],
    [
        28725,
        "ChromaticAberrationCorrParams"
    ],
    [
        28726,
        "DistortionCorrection"
    ],
    [
        28727,
        "DistortionCorrParams"
    ],
    [
        29895,
        "SonyCropTopLeft"
    ],
    [
        29896,
        "SonyCropSize"
    ],
    [
        32781,
        "ImageID"
    ],
    [
        32931,
        "WangTag1"
    ],
    [
        32932,
        "WangAnnotation"
    ],
    [
        32933,
        "WangTag3"
    ],
    [
        32934,
        "WangTag4"
    ],
    [
        32953,
        "ImageReferencePoints"
    ],
    [
        32954,
        "RegionXformTackPoint"
    ],
    [
        32955,
        "WarpQuadrilateral"
    ],
    [
        32956,
        "AffineTransformMat"
    ],
    [
        32995,
        "Matteing"
    ],
    [
        32996,
        "DataType"
    ],
    [
        32997,
        "ImageDepth"
    ],
    [
        32998,
        "TileDepth"
    ],
    [
        33300,
        "ImageFullWidth"
    ],
    [
        33301,
        "ImageFullHeight"
    ],
    [
        33302,
        "TextureFormat"
    ],
    [
        33303,
        "WrapModes"
    ],
    [
        33304,
        "FovCot"
    ],
    [
        33305,
        "MatrixWorldToScreen"
    ],
    [
        33306,
        "MatrixWorldToCamera"
    ],
    [
        33405,
        "Model2"
    ],
    [
        33421,
        "CFARepeatPatternDim"
    ],
    [
        33422,
        "CFAPattern2"
    ],
    [
        33423,
        "BatteryLevel"
    ],
    [
        33424,
        "KodakIFD"
    ],
    [
        33445,
        "MDFileTag"
    ],
    [
        33446,
        "MDScalePixel"
    ],
    [
        33447,
        "MDColorTable"
    ],
    [
        33448,
        "MDLabName"
    ],
    [
        33449,
        "MDSampleInfo"
    ],
    [
        33450,
        "MDPrepDate"
    ],
    [
        33451,
        "MDPrepTime"
    ],
    [
        33452,
        "MDFileUnits"
    ],
    [
        33589,
        "AdventScale"
    ],
    [
        33590,
        "AdventRevision"
    ],
    [
        33628,
        "UIC1Tag"
    ],
    [
        33629,
        "UIC2Tag"
    ],
    [
        33630,
        "UIC3Tag"
    ],
    [
        33631,
        "UIC4Tag"
    ],
    [
        33918,
        "IntergraphPacketData"
    ],
    [
        33919,
        "IntergraphFlagRegisters"
    ],
    [
        33921,
        "INGRReserved"
    ],
    [
        34016,
        "Site"
    ],
    [
        34017,
        "ColorSequence"
    ],
    [
        34018,
        "IT8Header"
    ],
    [
        34019,
        "RasterPadding"
    ],
    [
        34020,
        "BitsPerRunLength"
    ],
    [
        34021,
        "BitsPerExtendedRunLength"
    ],
    [
        34022,
        "ColorTable"
    ],
    [
        34023,
        "ImageColorIndicator"
    ],
    [
        34024,
        "BackgroundColorIndicator"
    ],
    [
        34025,
        "ImageColorValue"
    ],
    [
        34026,
        "BackgroundColorValue"
    ],
    [
        34027,
        "PixelIntensityRange"
    ],
    [
        34028,
        "TransparencyIndicator"
    ],
    [
        34029,
        "ColorCharacterization"
    ],
    [
        34030,
        "HCUsage"
    ],
    [
        34031,
        "TrapIndicator"
    ],
    [
        34032,
        "CMYKEquivalent"
    ],
    [
        34152,
        "AFCP_IPTC"
    ],
    [
        34232,
        "PixelMagicJBIGOptions"
    ],
    [
        34263,
        "JPLCartoIFD"
    ],
    [
        34306,
        "WB_GRGBLevels"
    ],
    [
        34310,
        "LeafData"
    ],
    [
        34687,
        "TIFF_FXExtensions"
    ],
    [
        34688,
        "MultiProfiles"
    ],
    [
        34689,
        "SharedData"
    ],
    [
        34690,
        "T88Options"
    ],
    [
        34732,
        "ImageLayer"
    ],
    [
        34750,
        "JBIGOptions"
    ],
    [
        34856,
        "Opto-ElectricConvFactor"
    ],
    [
        34857,
        "Interlace"
    ],
    [
        34908,
        "FaxRecvParams"
    ],
    [
        34909,
        "FaxSubAddress"
    ],
    [
        34910,
        "FaxRecvTime"
    ],
    [
        34929,
        "FedexEDR"
    ],
    [
        34954,
        "LeafSubIFD"
    ],
    [
        37387,
        "FlashEnergy"
    ],
    [
        37388,
        "SpatialFrequencyResponse"
    ],
    [
        37389,
        "Noise"
    ],
    [
        37390,
        "FocalPlaneXResolution"
    ],
    [
        37391,
        "FocalPlaneYResolution"
    ],
    [
        37392,
        "FocalPlaneResolutionUnit"
    ],
    [
        37397,
        "ExposureIndex"
    ],
    [
        37398,
        "TIFF-EPStandardID"
    ],
    [
        37399,
        "SensingMethod"
    ],
    [
        37434,
        "CIP3DataFile"
    ],
    [
        37435,
        "CIP3Sheet"
    ],
    [
        37436,
        "CIP3Side"
    ],
    [
        37439,
        "StoNits"
    ],
    [
        37679,
        "MSDocumentText"
    ],
    [
        37680,
        "MSPropertySetStorage"
    ],
    [
        37681,
        "MSDocumentTextPosition"
    ],
    [
        37724,
        "ImageSourceData"
    ],
    [
        40965,
        "InteropIFD"
    ],
    [
        40976,
        "SamsungRawPointersOffset"
    ],
    [
        40977,
        "SamsungRawPointersLength"
    ],
    [
        41217,
        "SamsungRawByteOrder"
    ],
    [
        41218,
        "SamsungRawUnknown"
    ],
    [
        41484,
        "SpatialFrequencyResponse"
    ],
    [
        41485,
        "Noise"
    ],
    [
        41489,
        "ImageNumber"
    ],
    [
        41490,
        "SecurityClassification"
    ],
    [
        41491,
        "ImageHistory"
    ],
    [
        41494,
        "TIFF-EPStandardID"
    ],
    [
        41995,
        "DeviceSettingDescription"
    ],
    [
        42112,
        "GDALMetadata"
    ],
    [
        42113,
        "GDALNoData"
    ],
    [
        44992,
        "ExpandSoftware"
    ],
    [
        44993,
        "ExpandLens"
    ],
    [
        44994,
        "ExpandFilm"
    ],
    [
        44995,
        "ExpandFilterLens"
    ],
    [
        44996,
        "ExpandScanner"
    ],
    [
        44997,
        "ExpandFlashLamp"
    ],
    [
        46275,
        "HasselbladRawImage"
    ],
    [
        48129,
        "PixelFormat"
    ],
    [
        48130,
        "Transformation"
    ],
    [
        48131,
        "Uncompressed"
    ],
    [
        48132,
        "ImageType"
    ],
    [
        48256,
        "ImageWidth"
    ],
    [
        48257,
        "ImageHeight"
    ],
    [
        48258,
        "WidthResolution"
    ],
    [
        48259,
        "HeightResolution"
    ],
    [
        48320,
        "ImageOffset"
    ],
    [
        48321,
        "ImageByteCount"
    ],
    [
        48322,
        "AlphaOffset"
    ],
    [
        48323,
        "AlphaByteCount"
    ],
    [
        48324,
        "ImageDataDiscard"
    ],
    [
        48325,
        "AlphaDataDiscard"
    ],
    [
        50215,
        "OceScanjobDesc"
    ],
    [
        50216,
        "OceApplicationSelector"
    ],
    [
        50217,
        "OceIDNumber"
    ],
    [
        50218,
        "OceImageLogic"
    ],
    [
        50255,
        "Annotations"
    ],
    [
        50459,
        "HasselbladExif"
    ],
    [
        50547,
        "OriginalFileName"
    ],
    [
        50560,
        "USPTOOriginalContentType"
    ],
    [
        50656,
        "CR2CFAPattern"
    ],
    [
        50710,
        "CFAPlaneColor"
    ],
    [
        50711,
        "CFALayout"
    ],
    [
        50712,
        "LinearizationTable"
    ],
    [
        50713,
        "BlackLevelRepeatDim"
    ],
    [
        50714,
        "BlackLevel"
    ],
    [
        50715,
        "BlackLevelDeltaH"
    ],
    [
        50716,
        "BlackLevelDeltaV"
    ],
    [
        50717,
        "WhiteLevel"
    ],
    [
        50718,
        "DefaultScale"
    ],
    [
        50719,
        "DefaultCropOrigin"
    ],
    [
        50720,
        "DefaultCropSize"
    ],
    [
        50733,
        "BayerGreenSplit"
    ],
    [
        50737,
        "ChromaBlurRadius"
    ],
    [
        50738,
        "AntiAliasStrength"
    ],
    [
        50752,
        "RawImageSegmentation"
    ],
    [
        50780,
        "BestQualityScale"
    ],
    [
        50784,
        "AliasLayerMetadata"
    ],
    [
        50829,
        "ActiveArea"
    ],
    [
        50830,
        "MaskedAreas"
    ],
    [
        50935,
        "NoiseReductionApplied"
    ],
    [
        50974,
        "SubTileBlockSize"
    ],
    [
        50975,
        "RowInterleaveFactor"
    ],
    [
        51008,
        "OpcodeList1"
    ],
    [
        51009,
        "OpcodeList2"
    ],
    [
        51022,
        "OpcodeList3"
    ],
    [
        51041,
        "NoiseProfile"
    ],
    [
        51114,
        "CacheVersion"
    ],
    [
        51125,
        "DefaultUserCrop"
    ],
    [
        51157,
        "NikonNEFInfo"
    ],
    [
        65024,
        "KdcIFD"
    ]
];
F(E, "ifd0", ct), F(E, "exif", ct), U(B, "gps", [
    [
        23,
        {
            M: "Magnetic North",
            T: "True North"
        }
    ],
    [
        25,
        {
            K: "Kilometers",
            M: "Miles",
            N: "Nautical Miles"
        }
    ]
]);
class ft extends re {
    static canHandle(e, t) {
        return 224 === e.getUint8(t + 1) && 1246120262 === e.getUint32(t + 4) && 0 === e.getUint8(t + 8);
    }
    parse() {
        return this.parseTags(), this.translate(), this.output;
    }
    parseTags() {
        this.raw = new Map([
            [
                0,
                this.chunk.getUint16(0)
            ],
            [
                2,
                this.chunk.getUint8(2)
            ],
            [
                3,
                this.chunk.getUint16(3)
            ],
            [
                5,
                this.chunk.getUint16(5)
            ],
            [
                7,
                this.chunk.getUint8(7)
            ],
            [
                8,
                this.chunk.getUint8(8)
            ]
        ]);
    }
}
c(ft, "type", "jfif"), c(ft, "headerLength", 9), T.set("jfif", ft), U(E, "jfif", [
    [
        0,
        "JFIFVersion"
    ],
    [
        2,
        "ResolutionUnit"
    ],
    [
        3,
        "XResolution"
    ],
    [
        5,
        "YResolution"
    ],
    [
        7,
        "ThumbnailWidth"
    ],
    [
        8,
        "ThumbnailHeight"
    ]
]);
class dt extends re {
    parse() {
        return this.parseTags(), this.translate(), this.output;
    }
    parseTags() {
        this.raw = new Map([
            [
                0,
                this.chunk.getUint32(0)
            ],
            [
                4,
                this.chunk.getUint32(4)
            ],
            [
                8,
                this.chunk.getUint8(8)
            ],
            [
                9,
                this.chunk.getUint8(9)
            ],
            [
                10,
                this.chunk.getUint8(10)
            ],
            [
                11,
                this.chunk.getUint8(11)
            ],
            [
                12,
                this.chunk.getUint8(12)
            ],
            ...Array.from(this.raw)
        ]);
    }
}
c(dt, "type", "ihdr"), T.set("ihdr", dt), U(E, "ihdr", [
    [
        0,
        "ImageWidth"
    ],
    [
        4,
        "ImageHeight"
    ],
    [
        8,
        "BitDepth"
    ],
    [
        9,
        "ColorType"
    ],
    [
        10,
        "Compression"
    ],
    [
        11,
        "Filter"
    ],
    [
        12,
        "Interlace"
    ]
]), U(B, "ihdr", [
    [
        9,
        {
            0: "Grayscale",
            2: "RGB",
            3: "Palette",
            4: "Grayscale with Alpha",
            6: "RGB with Alpha",
            DEFAULT: "Unknown"
        }
    ],
    [
        10,
        {
            0: "Deflate/Inflate",
            DEFAULT: "Unknown"
        }
    ],
    [
        11,
        {
            0: "Adaptive",
            DEFAULT: "Unknown"
        }
    ],
    [
        12,
        {
            0: "Noninterlaced",
            1: "Adam7 Interlace",
            DEFAULT: "Unknown"
        }
    ]
]);
class pt extends re {
    static canHandle(e, t) {
        return 226 === e.getUint8(t + 1) && 1229144927 === e.getUint32(t + 4);
    }
    static findPosition(e, t) {
        let i = super.findPosition(e, t);
        return i.chunkNumber = e.getUint8(t + 16), i.chunkCount = e.getUint8(t + 17), i.multiSegment = i.chunkCount > 1, i;
    }
    static handleMultiSegments(e) {
        return function(e) {
            let t = function(e) {
                let t = e[0].constructor, i = 0;
                for (let t of e)i += t.length;
                let n = new t(i), s = 0;
                for (let t of e)n.set(t, s), s += t.length;
                return n;
            }(e.map((e)=>e.chunk.toUint8()));
            return new I(t);
        }(e);
    }
    parse() {
        return this.raw = new Map, this.parseHeader(), this.parseTags(), this.translate(), this.output;
    }
    parseHeader() {
        let { raw: e } = this;
        this.chunk.byteLength < 84 && g("ICC header is too short");
        for (let [t, i] of Object.entries(gt)){
            t = parseInt(t, 10);
            let n = i(this.chunk, t);
            "\0\0\0\0" !== n && e.set(t, n);
        }
    }
    parseTags() {
        let e, t, i, n, s, { raw: r } = this, a = this.chunk.getUint32(128), o = 132, l = this.chunk.byteLength;
        for(; a--;){
            if (e = this.chunk.getString(o, 4), t = this.chunk.getUint32(o + 4), i = this.chunk.getUint32(o + 8), n = this.chunk.getString(t, 4), t + i > l) return void console.warn("reached the end of the first ICC chunk. Enable options.tiff.multiSegment to read all ICC segments.");
            s = this.parseTag(n, t, i), void 0 !== s && "\0\0\0\0" !== s && r.set(e, s), o += 12;
        }
    }
    parseTag(e, t, i) {
        switch(e){
            case "desc":
                return this.parseDesc(t);
            case "mluc":
                return this.parseMluc(t);
            case "text":
                return this.parseText(t, i);
            case "sig ":
                return this.parseSig(t);
        }
        if (!(t + i > this.chunk.byteLength)) return this.chunk.getUint8Array(t, i);
    }
    parseDesc(e) {
        let t = this.chunk.getUint32(e + 8) - 1;
        return m(this.chunk.getString(e + 12, t));
    }
    parseText(e, t) {
        return m(this.chunk.getString(e + 8, t - 8));
    }
    parseSig(e) {
        return m(this.chunk.getString(e + 8, 4));
    }
    parseMluc(e) {
        let { chunk: t } = this, i = t.getUint32(e + 8), n = t.getUint32(e + 12), s = e + 16, r = [];
        for(let a = 0; a < i; a++){
            let i = t.getString(s + 0, 2), a = t.getString(s + 2, 2), o = t.getUint32(s + 4), l = t.getUint32(s + 8) + e, h = m(t.getUnicodeString(l, o));
            r.push({
                lang: i,
                country: a,
                text: h
            }), s += n;
        }
        return 1 === i ? r[0].text : r;
    }
    translateValue(e, t) {
        return "string" == typeof e ? t[e] || t[e.toLowerCase()] || e : t[e] || e;
    }
}
c(pt, "type", "icc"), c(pt, "multiSegment", !0), c(pt, "headerLength", 18);
const gt = {
    4: mt,
    8: function(e, t) {
        return [
            e.getUint8(t),
            e.getUint8(t + 1) >> 4,
            e.getUint8(t + 1) % 16
        ].map((e)=>e.toString(10)).join(".");
    },
    12: mt,
    16: mt,
    20: mt,
    24: function(e, t) {
        const i = e.getUint16(t), n = e.getUint16(t + 2) - 1, s = e.getUint16(t + 4), r = e.getUint16(t + 6), a = e.getUint16(t + 8), o = e.getUint16(t + 10);
        return new Date(Date.UTC(i, n, s, r, a, o));
    },
    36: mt,
    40: mt,
    48: mt,
    52: mt,
    64: (e, t)=>e.getUint32(t),
    80: mt
};
function mt(e, t) {
    return m(e.getString(t, 4));
}
T.set("icc", pt), U(E, "icc", [
    [
        4,
        "ProfileCMMType"
    ],
    [
        8,
        "ProfileVersion"
    ],
    [
        12,
        "ProfileClass"
    ],
    [
        16,
        "ColorSpaceData"
    ],
    [
        20,
        "ProfileConnectionSpace"
    ],
    [
        24,
        "ProfileDateTime"
    ],
    [
        36,
        "ProfileFileSignature"
    ],
    [
        40,
        "PrimaryPlatform"
    ],
    [
        44,
        "CMMFlags"
    ],
    [
        48,
        "DeviceManufacturer"
    ],
    [
        52,
        "DeviceModel"
    ],
    [
        56,
        "DeviceAttributes"
    ],
    [
        64,
        "RenderingIntent"
    ],
    [
        68,
        "ConnectionSpaceIlluminant"
    ],
    [
        80,
        "ProfileCreator"
    ],
    [
        84,
        "ProfileID"
    ],
    [
        "Header",
        "ProfileHeader"
    ],
    [
        "MS00",
        "WCSProfiles"
    ],
    [
        "bTRC",
        "BlueTRC"
    ],
    [
        "bXYZ",
        "BlueMatrixColumn"
    ],
    [
        "bfd",
        "UCRBG"
    ],
    [
        "bkpt",
        "MediaBlackPoint"
    ],
    [
        "calt",
        "CalibrationDateTime"
    ],
    [
        "chad",
        "ChromaticAdaptation"
    ],
    [
        "chrm",
        "Chromaticity"
    ],
    [
        "ciis",
        "ColorimetricIntentImageState"
    ],
    [
        "clot",
        "ColorantTableOut"
    ],
    [
        "clro",
        "ColorantOrder"
    ],
    [
        "clrt",
        "ColorantTable"
    ],
    [
        "cprt",
        "ProfileCopyright"
    ],
    [
        "crdi",
        "CRDInfo"
    ],
    [
        "desc",
        "ProfileDescription"
    ],
    [
        "devs",
        "DeviceSettings"
    ],
    [
        "dmdd",
        "DeviceModelDesc"
    ],
    [
        "dmnd",
        "DeviceMfgDesc"
    ],
    [
        "dscm",
        "ProfileDescriptionML"
    ],
    [
        "fpce",
        "FocalPlaneColorimetryEstimates"
    ],
    [
        "gTRC",
        "GreenTRC"
    ],
    [
        "gXYZ",
        "GreenMatrixColumn"
    ],
    [
        "gamt",
        "Gamut"
    ],
    [
        "kTRC",
        "GrayTRC"
    ],
    [
        "lumi",
        "Luminance"
    ],
    [
        "meas",
        "Measurement"
    ],
    [
        "meta",
        "Metadata"
    ],
    [
        "mmod",
        "MakeAndModel"
    ],
    [
        "ncl2",
        "NamedColor2"
    ],
    [
        "ncol",
        "NamedColor"
    ],
    [
        "ndin",
        "NativeDisplayInfo"
    ],
    [
        "pre0",
        "Preview0"
    ],
    [
        "pre1",
        "Preview1"
    ],
    [
        "pre2",
        "Preview2"
    ],
    [
        "ps2i",
        "PS2RenderingIntent"
    ],
    [
        "ps2s",
        "PostScript2CSA"
    ],
    [
        "psd0",
        "PostScript2CRD0"
    ],
    [
        "psd1",
        "PostScript2CRD1"
    ],
    [
        "psd2",
        "PostScript2CRD2"
    ],
    [
        "psd3",
        "PostScript2CRD3"
    ],
    [
        "pseq",
        "ProfileSequenceDesc"
    ],
    [
        "psid",
        "ProfileSequenceIdentifier"
    ],
    [
        "psvm",
        "PS2CRDVMSize"
    ],
    [
        "rTRC",
        "RedTRC"
    ],
    [
        "rXYZ",
        "RedMatrixColumn"
    ],
    [
        "resp",
        "OutputResponse"
    ],
    [
        "rhoc",
        "ReflectionHardcopyOrigColorimetry"
    ],
    [
        "rig0",
        "PerceptualRenderingIntentGamut"
    ],
    [
        "rig2",
        "SaturationRenderingIntentGamut"
    ],
    [
        "rpoc",
        "ReflectionPrintOutputColorimetry"
    ],
    [
        "sape",
        "SceneAppearanceEstimates"
    ],
    [
        "scoe",
        "SceneColorimetryEstimates"
    ],
    [
        "scrd",
        "ScreeningDesc"
    ],
    [
        "scrn",
        "Screening"
    ],
    [
        "targ",
        "CharTarget"
    ],
    [
        "tech",
        "Technology"
    ],
    [
        "vcgt",
        "VideoCardGamma"
    ],
    [
        "view",
        "ViewingConditions"
    ],
    [
        "vued",
        "ViewingCondDesc"
    ],
    [
        "wtpt",
        "MediaWhitePoint"
    ]
]);
const St = {
    "4d2p": "Erdt Systems",
    AAMA: "Aamazing Technologies",
    ACER: "Acer",
    ACLT: "Acolyte Color Research",
    ACTI: "Actix Sytems",
    ADAR: "Adara Technology",
    ADBE: "Adobe",
    ADI: "ADI Systems",
    AGFA: "Agfa Graphics",
    ALMD: "Alps Electric",
    ALPS: "Alps Electric",
    ALWN: "Alwan Color Expertise",
    AMTI: "Amiable Technologies",
    AOC: "AOC International",
    APAG: "Apago",
    APPL: "Apple Computer",
    AST: "AST",
    "AT&T": "AT&T",
    BAEL: "BARBIERI electronic",
    BRCO: "Barco NV",
    BRKP: "Breakpoint",
    BROT: "Brother",
    BULL: "Bull",
    BUS: "Bus Computer Systems",
    "C-IT": "C-Itoh",
    CAMR: "Intel",
    CANO: "Canon",
    CARR: "Carroll Touch",
    CASI: "Casio",
    CBUS: "Colorbus PL",
    CEL: "Crossfield",
    CELx: "Crossfield",
    CGS: "CGS Publishing Technologies International",
    CHM: "Rochester Robotics",
    CIGL: "Colour Imaging Group, London",
    CITI: "Citizen",
    CL00: "Candela",
    CLIQ: "Color IQ",
    CMCO: "Chromaco",
    CMiX: "CHROMiX",
    COLO: "Colorgraphic Communications",
    COMP: "Compaq",
    COMp: "Compeq/Focus Technology",
    CONR: "Conrac Display Products",
    CORD: "Cordata Technologies",
    CPQ: "Compaq",
    CPRO: "ColorPro",
    CRN: "Cornerstone",
    CTX: "CTX International",
    CVIS: "ColorVision",
    CWC: "Fujitsu Laboratories",
    DARI: "Darius Technology",
    DATA: "Dataproducts",
    DCP: "Dry Creek Photo",
    DCRC: "Digital Contents Resource Center, Chung-Ang University",
    DELL: "Dell Computer",
    DIC: "Dainippon Ink and Chemicals",
    DICO: "Diconix",
    DIGI: "Digital",
    "DL&C": "Digital Light & Color",
    DPLG: "Doppelganger",
    DS: "Dainippon Screen",
    DSOL: "DOOSOL",
    DUPN: "DuPont",
    EPSO: "Epson",
    ESKO: "Esko-Graphics",
    ETRI: "Electronics and Telecommunications Research Institute",
    EVER: "Everex Systems",
    EXAC: "ExactCODE",
    Eizo: "Eizo",
    FALC: "Falco Data Products",
    FF: "Fuji Photo Film",
    FFEI: "FujiFilm Electronic Imaging",
    FNRD: "Fnord Software",
    FORA: "Fora",
    FORE: "Forefront Technology",
    FP: "Fujitsu",
    FPA: "WayTech Development",
    FUJI: "Fujitsu",
    FX: "Fuji Xerox",
    GCC: "GCC Technologies",
    GGSL: "Global Graphics Software",
    GMB: "Gretagmacbeth",
    GMG: "GMG",
    GOLD: "GoldStar Technology",
    GOOG: "Google",
    GPRT: "Giantprint",
    GTMB: "Gretagmacbeth",
    GVC: "WayTech Development",
    GW2K: "Sony",
    HCI: "HCI",
    HDM: "Heidelberger Druckmaschinen",
    HERM: "Hermes",
    HITA: "Hitachi America",
    HP: "Hewlett-Packard",
    HTC: "Hitachi",
    HiTi: "HiTi Digital",
    IBM: "IBM",
    IDNT: "Scitex",
    IEC: "Hewlett-Packard",
    IIYA: "Iiyama North America",
    IKEG: "Ikegami Electronics",
    IMAG: "Image Systems",
    IMI: "Ingram Micro",
    INTC: "Intel",
    INTL: "N/A (INTL)",
    INTR: "Intra Electronics",
    IOCO: "Iocomm International Technology",
    IPS: "InfoPrint Solutions Company",
    IRIS: "Scitex",
    ISL: "Ichikawa Soft Laboratory",
    ITNL: "N/A (ITNL)",
    IVM: "IVM",
    IWAT: "Iwatsu Electric",
    Idnt: "Scitex",
    Inca: "Inca Digital Printers",
    Iris: "Scitex",
    JPEG: "Joint Photographic Experts Group",
    JSFT: "Jetsoft Development",
    JVC: "JVC Information Products",
    KART: "Scitex",
    KFC: "KFC Computek Components",
    KLH: "KLH Computers",
    KMHD: "Konica Minolta",
    KNCA: "Konica",
    KODA: "Kodak",
    KYOC: "Kyocera",
    Kart: "Scitex",
    LCAG: "Leica",
    LCCD: "Leeds Colour",
    LDAK: "Left Dakota",
    LEAD: "Leading Technology",
    LEXM: "Lexmark International",
    LINK: "Link Computer",
    LINO: "Linotronic",
    LITE: "Lite-On",
    Leaf: "Leaf",
    Lino: "Linotronic",
    MAGC: "Mag Computronic",
    MAGI: "MAG Innovision",
    MANN: "Mannesmann",
    MICN: "Micron Technology",
    MICR: "Microtek",
    MICV: "Microvitec",
    MINO: "Minolta",
    MITS: "Mitsubishi Electronics America",
    MITs: "Mitsuba",
    MNLT: "Minolta",
    MODG: "Modgraph",
    MONI: "Monitronix",
    MONS: "Monaco Systems",
    MORS: "Morse Technology",
    MOTI: "Motive Systems",
    MSFT: "Microsoft",
    MUTO: "MUTOH INDUSTRIES",
    Mits: "Mitsubishi Electric",
    NANA: "NANAO",
    NEC: "NEC",
    NEXP: "NexPress Solutions",
    NISS: "Nissei Sangyo America",
    NKON: "Nikon",
    NONE: "none",
    OCE: "Oce Technologies",
    OCEC: "OceColor",
    OKI: "Oki",
    OKID: "Okidata",
    OKIP: "Okidata",
    OLIV: "Olivetti",
    OLYM: "Olympus",
    ONYX: "Onyx Graphics",
    OPTI: "Optiquest",
    PACK: "Packard Bell",
    PANA: "Matsushita Electric Industrial",
    PANT: "Pantone",
    PBN: "Packard Bell",
    PFU: "PFU",
    PHIL: "Philips Consumer Electronics",
    PNTX: "HOYA",
    POne: "Phase One A/S",
    PREM: "Premier Computer Innovations",
    PRIN: "Princeton Graphic Systems",
    PRIP: "Princeton Publishing Labs",
    QLUX: "Hong Kong",
    QMS: "QMS",
    QPCD: "QPcard AB",
    QUAD: "QuadLaser",
    QUME: "Qume",
    RADI: "Radius",
    RDDx: "Integrated Color Solutions",
    RDG: "Roland DG",
    REDM: "REDMS Group",
    RELI: "Relisys",
    RGMS: "Rolf Gierling Multitools",
    RICO: "Ricoh",
    RNLD: "Edmund Ronald",
    ROYA: "Royal",
    RPC: "Ricoh Printing Systems",
    RTL: "Royal Information Electronics",
    SAMP: "Sampo",
    SAMS: "Samsung",
    SANT: "Jaime Santana Pomares",
    SCIT: "Scitex",
    SCRN: "Dainippon Screen",
    SDP: "Scitex",
    SEC: "Samsung",
    SEIK: "Seiko Instruments",
    SEIk: "Seikosha",
    SGUY: "ScanGuy.com",
    SHAR: "Sharp Laboratories",
    SICC: "International Color Consortium",
    SONY: "Sony",
    SPCL: "SpectraCal",
    STAR: "Star",
    STC: "Sampo Technology",
    Scit: "Scitex",
    Sdp: "Scitex",
    Sony: "Sony",
    TALO: "Talon Technology",
    TAND: "Tandy",
    TATU: "Tatung",
    TAXA: "TAXAN America",
    TDS: "Tokyo Denshi Sekei",
    TECO: "TECO Information Systems",
    TEGR: "Tegra",
    TEKT: "Tektronix",
    TI: "Texas Instruments",
    TMKR: "TypeMaker",
    TOSB: "Toshiba",
    TOSH: "Toshiba",
    TOTK: "TOTOKU ELECTRIC",
    TRIU: "Triumph",
    TSBT: "Toshiba",
    TTX: "TTX Computer Products",
    TVM: "TVM Professional Monitor",
    TW: "TW Casper",
    ULSX: "Ulead Systems",
    UNIS: "Unisys",
    UTZF: "Utz Fehlau & Sohn",
    VARI: "Varityper",
    VIEW: "Viewsonic",
    VISL: "Visual communication",
    VIVO: "Vivo Mobile Communication",
    WANG: "Wang",
    WLBR: "Wilbur Imaging",
    WTG2: "Ware To Go",
    WYSE: "WYSE Technology",
    XERX: "Xerox",
    XRIT: "X-Rite",
    ZRAN: "Zoran",
    Zebr: "Zebra Technologies",
    appl: "Apple Computer",
    bICC: "basICColor",
    berg: "bergdesign",
    ceyd: "Integrated Color Solutions",
    clsp: "MacDermid ColorSpan",
    ds: "Dainippon Screen",
    dupn: "DuPont",
    ffei: "FujiFilm Electronic Imaging",
    flux: "FluxData",
    iris: "Scitex",
    kart: "Scitex",
    lcms: "Little CMS",
    lino: "Linotronic",
    none: "none",
    ob4d: "Erdt Systems",
    obic: "Medigraph",
    quby: "Qubyx Sarl",
    scit: "Scitex",
    scrn: "Dainippon Screen",
    sdp: "Scitex",
    siwi: "SIWI GRAFIKA",
    yxym: "YxyMaster"
}, Ct = {
    scnr: "Scanner",
    mntr: "Monitor",
    prtr: "Printer",
    link: "Device Link",
    abst: "Abstract",
    spac: "Color Space Conversion Profile",
    nmcl: "Named Color",
    cenc: "ColorEncodingSpace profile",
    mid: "MultiplexIdentification profile",
    mlnk: "MultiplexLink profile",
    mvis: "MultiplexVisualization profile",
    nkpf: "Nikon Input Device Profile (NON-STANDARD!)"
};
U(B, "icc", [
    [
        4,
        St
    ],
    [
        12,
        Ct
    ],
    [
        40,
        Object.assign({}, St, Ct)
    ],
    [
        48,
        St
    ],
    [
        80,
        St
    ],
    [
        64,
        {
            0: "Perceptual",
            1: "Relative Colorimetric",
            2: "Saturation",
            3: "Absolute Colorimetric"
        }
    ],
    [
        "tech",
        {
            amd: "Active Matrix Display",
            crt: "Cathode Ray Tube Display",
            kpcd: "Photo CD",
            pmd: "Passive Matrix Display",
            dcam: "Digital Camera",
            dcpj: "Digital Cinema Projector",
            dmpc: "Digital Motion Picture Camera",
            dsub: "Dye Sublimation Printer",
            epho: "Electrophotographic Printer",
            esta: "Electrostatic Printer",
            flex: "Flexography",
            fprn: "Film Writer",
            fscn: "Film Scanner",
            grav: "Gravure",
            ijet: "Ink Jet Printer",
            imgs: "Photo Image Setter",
            mpfr: "Motion Picture Film Recorder",
            mpfs: "Motion Picture Film Scanner",
            offs: "Offset Lithography",
            pjtv: "Projection Television",
            rpho: "Photographic Paper Printer",
            rscn: "Reflective Scanner",
            silk: "Silkscreen",
            twax: "Thermal Wax Printer",
            vidc: "Video Camera",
            vidm: "Video Monitor"
        }
    ]
]);
class yt extends re {
    static canHandle(e, t, i) {
        return 237 === e.getUint8(t + 1) && "Photoshop" === e.getString(t + 4, 9) && void 0 !== this.containsIptc8bim(e, t, i);
    }
    static headerLength(e, t, i) {
        let n, s = this.containsIptc8bim(e, t, i);
        if (void 0 !== s) return n = e.getUint8(t + s + 7), n % 2 != 0 && (n += 1), 0 === n && (n = 4), s + 8 + n;
    }
    static containsIptc8bim(e, t, i) {
        for(let n = 0; n < i; n++)if (this.isIptcSegmentHead(e, t + n)) return n;
    }
    static isIptcSegmentHead(e, t) {
        return 56 === e.getUint8(t) && 943868237 === e.getUint32(t) && 1028 === e.getUint16(t + 4);
    }
    parse() {
        let { raw: e } = this, t = this.chunk.byteLength - 1, i = !1;
        for(let n = 0; n < t; n++)if (28 === this.chunk.getUint8(n) && 2 === this.chunk.getUint8(n + 1)) {
            i = !0;
            let t = this.chunk.getUint16(n + 3), s = this.chunk.getUint8(n + 2), r = this.chunk.getLatin1String(n + 5, t);
            e.set(s, this.pluralizeValue(e.get(s), r)), n += 4 + t;
        } else if (i) break;
        return this.translate(), this.output;
    }
    pluralizeValue(e, t) {
        return void 0 !== e ? e instanceof Array ? (e.push(t), e) : [
            e,
            t
        ] : t;
    }
}
c(yt, "type", "iptc"), c(yt, "translateValues", !1), c(yt, "reviveValues", !1), T.set("iptc", yt), U(E, "iptc", [
    [
        0,
        "ApplicationRecordVersion"
    ],
    [
        3,
        "ObjectTypeReference"
    ],
    [
        4,
        "ObjectAttributeReference"
    ],
    [
        5,
        "ObjectName"
    ],
    [
        7,
        "EditStatus"
    ],
    [
        8,
        "EditorialUpdate"
    ],
    [
        10,
        "Urgency"
    ],
    [
        12,
        "SubjectReference"
    ],
    [
        15,
        "Category"
    ],
    [
        20,
        "SupplementalCategories"
    ],
    [
        22,
        "FixtureIdentifier"
    ],
    [
        25,
        "Keywords"
    ],
    [
        26,
        "ContentLocationCode"
    ],
    [
        27,
        "ContentLocationName"
    ],
    [
        30,
        "ReleaseDate"
    ],
    [
        35,
        "ReleaseTime"
    ],
    [
        37,
        "ExpirationDate"
    ],
    [
        38,
        "ExpirationTime"
    ],
    [
        40,
        "SpecialInstructions"
    ],
    [
        42,
        "ActionAdvised"
    ],
    [
        45,
        "ReferenceService"
    ],
    [
        47,
        "ReferenceDate"
    ],
    [
        50,
        "ReferenceNumber"
    ],
    [
        55,
        "DateCreated"
    ],
    [
        60,
        "TimeCreated"
    ],
    [
        62,
        "DigitalCreationDate"
    ],
    [
        63,
        "DigitalCreationTime"
    ],
    [
        65,
        "OriginatingProgram"
    ],
    [
        70,
        "ProgramVersion"
    ],
    [
        75,
        "ObjectCycle"
    ],
    [
        80,
        "Byline"
    ],
    [
        85,
        "BylineTitle"
    ],
    [
        90,
        "City"
    ],
    [
        92,
        "Sublocation"
    ],
    [
        95,
        "State"
    ],
    [
        100,
        "CountryCode"
    ],
    [
        101,
        "Country"
    ],
    [
        103,
        "OriginalTransmissionReference"
    ],
    [
        105,
        "Headline"
    ],
    [
        110,
        "Credit"
    ],
    [
        115,
        "Source"
    ],
    [
        116,
        "CopyrightNotice"
    ],
    [
        118,
        "Contact"
    ],
    [
        120,
        "Caption"
    ],
    [
        121,
        "LocalCaption"
    ],
    [
        122,
        "Writer"
    ],
    [
        125,
        "RasterizedCaption"
    ],
    [
        130,
        "ImageType"
    ],
    [
        131,
        "ImageOrientation"
    ],
    [
        135,
        "LanguageIdentifier"
    ],
    [
        150,
        "AudioType"
    ],
    [
        151,
        "AudioSamplingRate"
    ],
    [
        152,
        "AudioSamplingResolution"
    ],
    [
        153,
        "AudioDuration"
    ],
    [
        154,
        "AudioOutcue"
    ],
    [
        184,
        "JobID"
    ],
    [
        185,
        "MasterDocumentID"
    ],
    [
        186,
        "ShortDocumentID"
    ],
    [
        187,
        "UniqueDocumentID"
    ],
    [
        188,
        "OwnerID"
    ],
    [
        200,
        "ObjectPreviewFileFormat"
    ],
    [
        201,
        "ObjectPreviewFileVersion"
    ],
    [
        202,
        "ObjectPreviewData"
    ],
    [
        221,
        "Prefs"
    ],
    [
        225,
        "ClassifyState"
    ],
    [
        228,
        "SimilarityIndex"
    ],
    [
        230,
        "DocumentNotes"
    ],
    [
        231,
        "DocumentHistory"
    ],
    [
        232,
        "ExifCameraInfo"
    ],
    [
        255,
        "CatalogSets"
    ]
]), U(B, "iptc", [
    [
        10,
        {
            0: "0 (reserved)",
            1: "1 (most urgent)",
            2: "2",
            3: "3",
            4: "4",
            5: "5 (normal urgency)",
            6: "6",
            7: "7",
            8: "8 (least urgent)",
            9: "9 (user-defined priority)"
        }
    ],
    [
        75,
        {
            a: "Morning",
            b: "Both Morning and Evening",
            p: "Evening"
        }
    ],
    [
        131,
        {
            L: "Landscape",
            P: "Portrait",
            S: "Square"
        }
    ]
]);
const __TURBOPACK__default__export__ = tt;
;
}),
"[project]/node_modules/@radix-ui/number/dist/index.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// packages/core/number/src/number.ts
__turbopack_context__.s([
    "clamp",
    ()=>clamp
]);
function clamp(value, [min, max]) {
    return Math.min(max, Math.max(min, value));
}
;
 //# sourceMappingURL=index.mjs.map
}),
"[project]/node_modules/@radix-ui/react-use-previous/dist/index.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// packages/react/use-previous/src/usePrevious.tsx
__turbopack_context__.s([
    "usePrevious",
    ()=>usePrevious
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
;
function usePrevious(value) {
    const ref = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"]({
        value,
        previous: value
    });
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"]({
        "usePrevious.useMemo": ()=>{
            if (ref.current.value !== value) {
                ref.current.previous = ref.current.value;
                ref.current.value = value;
            }
            return ref.current.previous;
        }
    }["usePrevious.useMemo"], [
        value
    ]);
}
;
 //# sourceMappingURL=index.mjs.map
}),
"[project]/node_modules/@radix-ui/react-select/dist/index.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Arrow",
    ()=>Arrow2,
    "Content",
    ()=>Content2,
    "Group",
    ()=>Group,
    "Icon",
    ()=>Icon,
    "Item",
    ()=>Item,
    "ItemIndicator",
    ()=>ItemIndicator,
    "ItemText",
    ()=>ItemText,
    "Label",
    ()=>Label,
    "Portal",
    ()=>Portal,
    "Root",
    ()=>Root2,
    "ScrollDownButton",
    ()=>ScrollDownButton,
    "ScrollUpButton",
    ()=>ScrollUpButton,
    "Select",
    ()=>Select,
    "SelectArrow",
    ()=>SelectArrow,
    "SelectContent",
    ()=>SelectContent,
    "SelectGroup",
    ()=>SelectGroup,
    "SelectIcon",
    ()=>SelectIcon,
    "SelectItem",
    ()=>SelectItem,
    "SelectItemIndicator",
    ()=>SelectItemIndicator,
    "SelectItemText",
    ()=>SelectItemText,
    "SelectLabel",
    ()=>SelectLabel,
    "SelectPortal",
    ()=>SelectPortal,
    "SelectScrollDownButton",
    ()=>SelectScrollDownButton,
    "SelectScrollUpButton",
    ()=>SelectScrollUpButton,
    "SelectSeparator",
    ()=>SelectSeparator,
    "SelectTrigger",
    ()=>SelectTrigger,
    "SelectValue",
    ()=>SelectValue,
    "SelectViewport",
    ()=>SelectViewport,
    "Separator",
    ()=>Separator,
    "Trigger",
    ()=>Trigger,
    "Value",
    ()=>Value,
    "Viewport",
    ()=>Viewport,
    "createSelectScope",
    ()=>createSelectScope
]);
// packages/react/select/src/Select.tsx
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2d$dom$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react-dom/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$number$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@radix-ui/number/dist/index.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$primitive$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@radix-ui/primitive/dist/index.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$react$2d$collection$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@radix-ui/react-collection/dist/index.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$react$2d$compose$2d$refs$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@radix-ui/react-compose-refs/dist/index.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$react$2d$context$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@radix-ui/react-context/dist/index.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$react$2d$direction$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@radix-ui/react-direction/dist/index.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$react$2d$dismissable$2d$layer$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@radix-ui/react-dismissable-layer/dist/index.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$react$2d$focus$2d$guards$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@radix-ui/react-focus-guards/dist/index.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$react$2d$focus$2d$scope$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@radix-ui/react-focus-scope/dist/index.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$react$2d$id$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@radix-ui/react-id/dist/index.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$react$2d$popper$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@radix-ui/react-popper/dist/index.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$react$2d$portal$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@radix-ui/react-portal/dist/index.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$react$2d$primitive$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@radix-ui/react-primitive/dist/index.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$react$2d$slot$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@radix-ui/react-slot/dist/index.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$react$2d$use$2d$callback$2d$ref$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@radix-ui/react-use-callback-ref/dist/index.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$react$2d$use$2d$controllable$2d$state$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@radix-ui/react-use-controllable-state/dist/index.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$react$2d$use$2d$layout$2d$effect$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@radix-ui/react-use-layout-effect/dist/index.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$react$2d$use$2d$previous$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@radix-ui/react-use-previous/dist/index.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$react$2d$visually$2d$hidden$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@radix-ui/react-visually-hidden/dist/index.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$aria$2d$hidden$2f$dist$2f$es2015$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/aria-hidden/dist/es2015/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$remove$2d$scroll$2f$dist$2f$es2015$2f$Combination$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__RemoveScroll$3e$__ = __turbopack_context__.i("[project]/node_modules/react-remove-scroll/dist/es2015/Combination.js [app-client] (ecmascript) <export default as RemoveScroll>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react/jsx-runtime.js [app-client] (ecmascript)");
"use client";
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
var OPEN_KEYS = [
    " ",
    "Enter",
    "ArrowUp",
    "ArrowDown"
];
var SELECTION_KEYS = [
    " ",
    "Enter"
];
var SELECT_NAME = "Select";
var [Collection, useCollection, createCollectionScope] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$react$2d$collection$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createCollection"])(SELECT_NAME);
var [createSelectContext, createSelectScope] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$react$2d$context$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createContextScope"])(SELECT_NAME, [
    createCollectionScope,
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$react$2d$popper$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createPopperScope"]
]);
var usePopperScope = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$react$2d$popper$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createPopperScope"])();
var [SelectProvider, useSelectContext] = createSelectContext(SELECT_NAME);
var [SelectNativeOptionsProvider, useSelectNativeOptionsContext] = createSelectContext(SELECT_NAME);
var Select = (props)=>{
    const { __scopeSelect, children, open: openProp, defaultOpen, onOpenChange, value: valueProp, defaultValue, onValueChange, dir, name, autoComplete, disabled, required, form } = props;
    const popperScope = usePopperScope(__scopeSelect);
    const [trigger, setTrigger] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"](null);
    const [valueNode, setValueNode] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"](null);
    const [valueNodeHasChildren, setValueNodeHasChildren] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"](false);
    const direction = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$react$2d$direction$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useDirection"])(dir);
    const [open = false, setOpen] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$react$2d$use$2d$controllable$2d$state$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useControllableState"])({
        prop: openProp,
        defaultProp: defaultOpen,
        onChange: onOpenChange
    });
    const [value, setValue] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$react$2d$use$2d$controllable$2d$state$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useControllableState"])({
        prop: valueProp,
        defaultProp: defaultValue,
        onChange: onValueChange
    });
    const triggerPointerDownPosRef = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"](null);
    const isFormControl = trigger ? form || !!trigger.closest("form") : true;
    const [nativeOptionsSet, setNativeOptionsSet] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"](/* @__PURE__ */ new Set());
    const nativeSelectKey = Array.from(nativeOptionsSet).map((option)=>option.props.value).join(";");
    return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$react$2d$popper$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Root"], {
        ...popperScope,
        children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsxs"])(SelectProvider, {
            required,
            scope: __scopeSelect,
            trigger,
            onTriggerChange: setTrigger,
            valueNode,
            onValueNodeChange: setValueNode,
            valueNodeHasChildren,
            onValueNodeHasChildrenChange: setValueNodeHasChildren,
            contentId: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$react$2d$id$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useId"])(),
            value,
            onValueChange: setValue,
            open,
            onOpenChange: setOpen,
            dir: direction,
            triggerPointerDownPosRef,
            disabled,
            children: [
                /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(Collection.Provider, {
                    scope: __scopeSelect,
                    children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(SelectNativeOptionsProvider, {
                        scope: props.__scopeSelect,
                        onNativeOptionAdd: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"]({
                            "Select.useCallback": (option)=>{
                                setNativeOptionsSet({
                                    "Select.useCallback": (prev)=>new Set(prev).add(option)
                                }["Select.useCallback"]);
                            }
                        }["Select.useCallback"], []),
                        onNativeOptionRemove: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"]({
                            "Select.useCallback": (option)=>{
                                setNativeOptionsSet({
                                    "Select.useCallback": (prev)=>{
                                        const optionsSet = new Set(prev);
                                        optionsSet.delete(option);
                                        return optionsSet;
                                    }
                                }["Select.useCallback"]);
                            }
                        }["Select.useCallback"], []),
                        children
                    })
                }),
                isFormControl ? /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsxs"])(BubbleSelect, {
                    "aria-hidden": true,
                    required,
                    tabIndex: -1,
                    name,
                    autoComplete,
                    value,
                    onChange: (event)=>setValue(event.target.value),
                    disabled,
                    form,
                    children: [
                        value === void 0 ? /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("option", {
                            value: ""
                        }) : null,
                        Array.from(nativeOptionsSet)
                    ]
                }, nativeSelectKey) : null
            ]
        })
    });
};
Select.displayName = SELECT_NAME;
var TRIGGER_NAME = "SelectTrigger";
var SelectTrigger = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["forwardRef"]((props, forwardedRef)=>{
    const { __scopeSelect, disabled = false, ...triggerProps } = props;
    const popperScope = usePopperScope(__scopeSelect);
    const context = useSelectContext(TRIGGER_NAME, __scopeSelect);
    const isDisabled = context.disabled || disabled;
    const composedRefs = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$react$2d$compose$2d$refs$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useComposedRefs"])(forwardedRef, context.onTriggerChange);
    const getItems = useCollection(__scopeSelect);
    const pointerTypeRef = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"]("touch");
    const [searchRef, handleTypeaheadSearch, resetTypeahead] = useTypeaheadSearch({
        "SelectTrigger.useTypeaheadSearch": (search)=>{
            const enabledItems = getItems().filter({
                "SelectTrigger.useTypeaheadSearch.enabledItems": (item)=>!item.disabled
            }["SelectTrigger.useTypeaheadSearch.enabledItems"]);
            const currentItem = enabledItems.find({
                "SelectTrigger.useTypeaheadSearch.currentItem": (item)=>item.value === context.value
            }["SelectTrigger.useTypeaheadSearch.currentItem"]);
            const nextItem = findNextItem(enabledItems, search, currentItem);
            if (nextItem !== void 0) {
                context.onValueChange(nextItem.value);
            }
        }
    }["SelectTrigger.useTypeaheadSearch"]);
    const handleOpen = (pointerEvent)=>{
        if (!isDisabled) {
            context.onOpenChange(true);
            resetTypeahead();
        }
        if (pointerEvent) {
            context.triggerPointerDownPosRef.current = {
                x: Math.round(pointerEvent.pageX),
                y: Math.round(pointerEvent.pageY)
            };
        }
    };
    return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$react$2d$popper$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Anchor"], {
        asChild: true,
        ...popperScope,
        children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$react$2d$primitive$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Primitive"].button, {
            type: "button",
            role: "combobox",
            "aria-controls": context.contentId,
            "aria-expanded": context.open,
            "aria-required": context.required,
            "aria-autocomplete": "none",
            dir: context.dir,
            "data-state": context.open ? "open" : "closed",
            disabled: isDisabled,
            "data-disabled": isDisabled ? "" : void 0,
            "data-placeholder": shouldShowPlaceholder(context.value) ? "" : void 0,
            ...triggerProps,
            ref: composedRefs,
            onClick: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$primitive$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["composeEventHandlers"])(triggerProps.onClick, (event)=>{
                event.currentTarget.focus();
                if (pointerTypeRef.current !== "mouse") {
                    handleOpen(event);
                }
            }),
            onPointerDown: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$primitive$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["composeEventHandlers"])(triggerProps.onPointerDown, (event)=>{
                pointerTypeRef.current = event.pointerType;
                const target = event.target;
                if (target.hasPointerCapture(event.pointerId)) {
                    target.releasePointerCapture(event.pointerId);
                }
                if (event.button === 0 && event.ctrlKey === false && event.pointerType === "mouse") {
                    handleOpen(event);
                    event.preventDefault();
                }
            }),
            onKeyDown: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$primitive$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["composeEventHandlers"])(triggerProps.onKeyDown, (event)=>{
                const isTypingAhead = searchRef.current !== "";
                const isModifierKey = event.ctrlKey || event.altKey || event.metaKey;
                if (!isModifierKey && event.key.length === 1) handleTypeaheadSearch(event.key);
                if (isTypingAhead && event.key === " ") return;
                if (OPEN_KEYS.includes(event.key)) {
                    handleOpen();
                    event.preventDefault();
                }
            })
        })
    });
});
SelectTrigger.displayName = TRIGGER_NAME;
var VALUE_NAME = "SelectValue";
var SelectValue = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["forwardRef"]((props, forwardedRef)=>{
    const { __scopeSelect, className, style, children, placeholder = "", ...valueProps } = props;
    const context = useSelectContext(VALUE_NAME, __scopeSelect);
    const { onValueNodeHasChildrenChange } = context;
    const hasChildren = children !== void 0;
    const composedRefs = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$react$2d$compose$2d$refs$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useComposedRefs"])(forwardedRef, context.onValueNodeChange);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$react$2d$use$2d$layout$2d$effect$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useLayoutEffect"])({
        "SelectValue.useLayoutEffect": ()=>{
            onValueNodeHasChildrenChange(hasChildren);
        }
    }["SelectValue.useLayoutEffect"], [
        onValueNodeHasChildrenChange,
        hasChildren
    ]);
    return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$react$2d$primitive$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Primitive"].span, {
        ...valueProps,
        ref: composedRefs,
        style: {
            pointerEvents: "none"
        },
        children: shouldShowPlaceholder(context.value) ? /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Fragment"], {
            children: placeholder
        }) : children
    });
});
SelectValue.displayName = VALUE_NAME;
var ICON_NAME = "SelectIcon";
var SelectIcon = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["forwardRef"]((props, forwardedRef)=>{
    const { __scopeSelect, children, ...iconProps } = props;
    return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$react$2d$primitive$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Primitive"].span, {
        "aria-hidden": true,
        ...iconProps,
        ref: forwardedRef,
        children: children || "\u25BC"
    });
});
SelectIcon.displayName = ICON_NAME;
var PORTAL_NAME = "SelectPortal";
var SelectPortal = (props)=>{
    return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$react$2d$portal$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Portal"], {
        asChild: true,
        ...props
    });
};
SelectPortal.displayName = PORTAL_NAME;
var CONTENT_NAME = "SelectContent";
var SelectContent = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["forwardRef"]((props, forwardedRef)=>{
    const context = useSelectContext(CONTENT_NAME, props.__scopeSelect);
    const [fragment, setFragment] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"]();
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$react$2d$use$2d$layout$2d$effect$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useLayoutEffect"])({
        "SelectContent.useLayoutEffect": ()=>{
            setFragment(new DocumentFragment());
        }
    }["SelectContent.useLayoutEffect"], []);
    if (!context.open) {
        const frag = fragment;
        return frag ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2d$dom$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createPortal"](/* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(SelectContentProvider, {
            scope: props.__scopeSelect,
            children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(Collection.Slot, {
                scope: props.__scopeSelect,
                children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("div", {
                    children: props.children
                })
            })
        }), frag) : null;
    }
    return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(SelectContentImpl, {
        ...props,
        ref: forwardedRef
    });
});
SelectContent.displayName = CONTENT_NAME;
var CONTENT_MARGIN = 10;
var [SelectContentProvider, useSelectContentContext] = createSelectContext(CONTENT_NAME);
var CONTENT_IMPL_NAME = "SelectContentImpl";
var SelectContentImpl = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["forwardRef"]((props, forwardedRef)=>{
    const { __scopeSelect, position = "item-aligned", onCloseAutoFocus, onEscapeKeyDown, onPointerDownOutside, //
    // PopperContent props
    side, sideOffset, align, alignOffset, arrowPadding, collisionBoundary, collisionPadding, sticky, hideWhenDetached, avoidCollisions, //
    ...contentProps } = props;
    const context = useSelectContext(CONTENT_NAME, __scopeSelect);
    const [content, setContent] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"](null);
    const [viewport, setViewport] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"](null);
    const composedRefs = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$react$2d$compose$2d$refs$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useComposedRefs"])(forwardedRef, {
        "SelectContentImpl.useComposedRefs[composedRefs]": (node)=>setContent(node)
    }["SelectContentImpl.useComposedRefs[composedRefs]"]);
    const [selectedItem, setSelectedItem] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"](null);
    const [selectedItemText, setSelectedItemText] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"](null);
    const getItems = useCollection(__scopeSelect);
    const [isPositioned, setIsPositioned] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"](false);
    const firstValidItemFoundRef = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"](false);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"]({
        "SelectContentImpl.useEffect": ()=>{
            if (content) return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$aria$2d$hidden$2f$dist$2f$es2015$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hideOthers"])(content);
        }
    }["SelectContentImpl.useEffect"], [
        content
    ]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$react$2d$focus$2d$guards$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useFocusGuards"])();
    const focusFirst = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"]({
        "SelectContentImpl.useCallback[focusFirst]": (candidates)=>{
            const [firstItem, ...restItems] = getItems().map({
                "SelectContentImpl.useCallback[focusFirst]": (item)=>item.ref.current
            }["SelectContentImpl.useCallback[focusFirst]"]);
            const [lastItem] = restItems.slice(-1);
            const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;
            for (const candidate of candidates){
                if (candidate === PREVIOUSLY_FOCUSED_ELEMENT) return;
                candidate?.scrollIntoView({
                    block: "nearest"
                });
                if (candidate === firstItem && viewport) viewport.scrollTop = 0;
                if (candidate === lastItem && viewport) viewport.scrollTop = viewport.scrollHeight;
                candidate?.focus();
                if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT) return;
            }
        }
    }["SelectContentImpl.useCallback[focusFirst]"], [
        getItems,
        viewport
    ]);
    const focusSelectedItem = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"]({
        "SelectContentImpl.useCallback[focusSelectedItem]": ()=>focusFirst([
                selectedItem,
                content
            ])
    }["SelectContentImpl.useCallback[focusSelectedItem]"], [
        focusFirst,
        selectedItem,
        content
    ]);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"]({
        "SelectContentImpl.useEffect": ()=>{
            if (isPositioned) {
                focusSelectedItem();
            }
        }
    }["SelectContentImpl.useEffect"], [
        isPositioned,
        focusSelectedItem
    ]);
    const { onOpenChange, triggerPointerDownPosRef } = context;
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"]({
        "SelectContentImpl.useEffect": ()=>{
            if (content) {
                let pointerMoveDelta = {
                    x: 0,
                    y: 0
                };
                const handlePointerMove = {
                    "SelectContentImpl.useEffect.handlePointerMove": (event)=>{
                        pointerMoveDelta = {
                            x: Math.abs(Math.round(event.pageX) - (triggerPointerDownPosRef.current?.x ?? 0)),
                            y: Math.abs(Math.round(event.pageY) - (triggerPointerDownPosRef.current?.y ?? 0))
                        };
                    }
                }["SelectContentImpl.useEffect.handlePointerMove"];
                const handlePointerUp = {
                    "SelectContentImpl.useEffect.handlePointerUp": (event)=>{
                        if (pointerMoveDelta.x <= 10 && pointerMoveDelta.y <= 10) {
                            event.preventDefault();
                        } else {
                            if (!content.contains(event.target)) {
                                onOpenChange(false);
                            }
                        }
                        document.removeEventListener("pointermove", handlePointerMove);
                        triggerPointerDownPosRef.current = null;
                    }
                }["SelectContentImpl.useEffect.handlePointerUp"];
                if (triggerPointerDownPosRef.current !== null) {
                    document.addEventListener("pointermove", handlePointerMove);
                    document.addEventListener("pointerup", handlePointerUp, {
                        capture: true,
                        once: true
                    });
                }
                return ({
                    "SelectContentImpl.useEffect": ()=>{
                        document.removeEventListener("pointermove", handlePointerMove);
                        document.removeEventListener("pointerup", handlePointerUp, {
                            capture: true
                        });
                    }
                })["SelectContentImpl.useEffect"];
            }
        }
    }["SelectContentImpl.useEffect"], [
        content,
        onOpenChange,
        triggerPointerDownPosRef
    ]);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"]({
        "SelectContentImpl.useEffect": ()=>{
            const close = {
                "SelectContentImpl.useEffect.close": ()=>onOpenChange(false)
            }["SelectContentImpl.useEffect.close"];
            window.addEventListener("blur", close);
            window.addEventListener("resize", close);
            return ({
                "SelectContentImpl.useEffect": ()=>{
                    window.removeEventListener("blur", close);
                    window.removeEventListener("resize", close);
                }
            })["SelectContentImpl.useEffect"];
        }
    }["SelectContentImpl.useEffect"], [
        onOpenChange
    ]);
    const [searchRef, handleTypeaheadSearch] = useTypeaheadSearch({
        "SelectContentImpl.useTypeaheadSearch": (search)=>{
            const enabledItems = getItems().filter({
                "SelectContentImpl.useTypeaheadSearch.enabledItems": (item)=>!item.disabled
            }["SelectContentImpl.useTypeaheadSearch.enabledItems"]);
            const currentItem = enabledItems.find({
                "SelectContentImpl.useTypeaheadSearch.currentItem": (item)=>item.ref.current === document.activeElement
            }["SelectContentImpl.useTypeaheadSearch.currentItem"]);
            const nextItem = findNextItem(enabledItems, search, currentItem);
            if (nextItem) {
                setTimeout({
                    "SelectContentImpl.useTypeaheadSearch": ()=>nextItem.ref.current.focus()
                }["SelectContentImpl.useTypeaheadSearch"]);
            }
        }
    }["SelectContentImpl.useTypeaheadSearch"]);
    const itemRefCallback = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"]({
        "SelectContentImpl.useCallback[itemRefCallback]": (node, value, disabled)=>{
            const isFirstValidItem = !firstValidItemFoundRef.current && !disabled;
            const isSelectedItem = context.value !== void 0 && context.value === value;
            if (isSelectedItem || isFirstValidItem) {
                setSelectedItem(node);
                if (isFirstValidItem) firstValidItemFoundRef.current = true;
            }
        }
    }["SelectContentImpl.useCallback[itemRefCallback]"], [
        context.value
    ]);
    const handleItemLeave = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"]({
        "SelectContentImpl.useCallback[handleItemLeave]": ()=>content?.focus()
    }["SelectContentImpl.useCallback[handleItemLeave]"], [
        content
    ]);
    const itemTextRefCallback = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"]({
        "SelectContentImpl.useCallback[itemTextRefCallback]": (node, value, disabled)=>{
            const isFirstValidItem = !firstValidItemFoundRef.current && !disabled;
            const isSelectedItem = context.value !== void 0 && context.value === value;
            if (isSelectedItem || isFirstValidItem) {
                setSelectedItemText(node);
            }
        }
    }["SelectContentImpl.useCallback[itemTextRefCallback]"], [
        context.value
    ]);
    const SelectPosition = position === "popper" ? SelectPopperPosition : SelectItemAlignedPosition;
    const popperContentProps = SelectPosition === SelectPopperPosition ? {
        side,
        sideOffset,
        align,
        alignOffset,
        arrowPadding,
        collisionBoundary,
        collisionPadding,
        sticky,
        hideWhenDetached,
        avoidCollisions
    } : {};
    return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(SelectContentProvider, {
        scope: __scopeSelect,
        content,
        viewport,
        onViewportChange: setViewport,
        itemRefCallback,
        selectedItem,
        onItemLeave: handleItemLeave,
        itemTextRefCallback,
        focusSelectedItem,
        selectedItemText,
        position,
        isPositioned,
        searchRef,
        children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$remove$2d$scroll$2f$dist$2f$es2015$2f$Combination$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__RemoveScroll$3e$__["RemoveScroll"], {
            as: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$react$2d$slot$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Slot"],
            allowPinchZoom: true,
            children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$react$2d$focus$2d$scope$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FocusScope"], {
                asChild: true,
                trapped: context.open,
                onMountAutoFocus: (event)=>{
                    event.preventDefault();
                },
                onUnmountAutoFocus: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$primitive$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["composeEventHandlers"])(onCloseAutoFocus, (event)=>{
                    context.trigger?.focus({
                        preventScroll: true
                    });
                    event.preventDefault();
                }),
                children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$react$2d$dismissable$2d$layer$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DismissableLayer"], {
                    asChild: true,
                    disableOutsidePointerEvents: true,
                    onEscapeKeyDown,
                    onPointerDownOutside,
                    onFocusOutside: (event)=>event.preventDefault(),
                    onDismiss: ()=>context.onOpenChange(false),
                    children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(SelectPosition, {
                        role: "listbox",
                        id: context.contentId,
                        "data-state": context.open ? "open" : "closed",
                        dir: context.dir,
                        onContextMenu: (event)=>event.preventDefault(),
                        ...contentProps,
                        ...popperContentProps,
                        onPlaced: ()=>setIsPositioned(true),
                        ref: composedRefs,
                        style: {
                            // flex layout so we can place the scroll buttons properly
                            display: "flex",
                            flexDirection: "column",
                            // reset the outline by default as the content MAY get focused
                            outline: "none",
                            ...contentProps.style
                        },
                        onKeyDown: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$primitive$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["composeEventHandlers"])(contentProps.onKeyDown, (event)=>{
                            const isModifierKey = event.ctrlKey || event.altKey || event.metaKey;
                            if (event.key === "Tab") event.preventDefault();
                            if (!isModifierKey && event.key.length === 1) handleTypeaheadSearch(event.key);
                            if ([
                                "ArrowUp",
                                "ArrowDown",
                                "Home",
                                "End"
                            ].includes(event.key)) {
                                const items = getItems().filter((item)=>!item.disabled);
                                let candidateNodes = items.map((item)=>item.ref.current);
                                if ([
                                    "ArrowUp",
                                    "End"
                                ].includes(event.key)) {
                                    candidateNodes = candidateNodes.slice().reverse();
                                }
                                if ([
                                    "ArrowUp",
                                    "ArrowDown"
                                ].includes(event.key)) {
                                    const currentElement = event.target;
                                    const currentIndex = candidateNodes.indexOf(currentElement);
                                    candidateNodes = candidateNodes.slice(currentIndex + 1);
                                }
                                setTimeout(()=>focusFirst(candidateNodes));
                                event.preventDefault();
                            }
                        })
                    })
                })
            })
        })
    });
});
SelectContentImpl.displayName = CONTENT_IMPL_NAME;
var ITEM_ALIGNED_POSITION_NAME = "SelectItemAlignedPosition";
var SelectItemAlignedPosition = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["forwardRef"]((props, forwardedRef)=>{
    const { __scopeSelect, onPlaced, ...popperProps } = props;
    const context = useSelectContext(CONTENT_NAME, __scopeSelect);
    const contentContext = useSelectContentContext(CONTENT_NAME, __scopeSelect);
    const [contentWrapper, setContentWrapper] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"](null);
    const [content, setContent] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"](null);
    const composedRefs = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$react$2d$compose$2d$refs$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useComposedRefs"])(forwardedRef, {
        "SelectItemAlignedPosition.useComposedRefs[composedRefs]": (node)=>setContent(node)
    }["SelectItemAlignedPosition.useComposedRefs[composedRefs]"]);
    const getItems = useCollection(__scopeSelect);
    const shouldExpandOnScrollRef = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"](false);
    const shouldRepositionRef = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"](true);
    const { viewport, selectedItem, selectedItemText, focusSelectedItem } = contentContext;
    const position = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"]({
        "SelectItemAlignedPosition.useCallback[position]": ()=>{
            if (context.trigger && context.valueNode && contentWrapper && content && viewport && selectedItem && selectedItemText) {
                const triggerRect = context.trigger.getBoundingClientRect();
                const contentRect = content.getBoundingClientRect();
                const valueNodeRect = context.valueNode.getBoundingClientRect();
                const itemTextRect = selectedItemText.getBoundingClientRect();
                if (context.dir !== "rtl") {
                    const itemTextOffset = itemTextRect.left - contentRect.left;
                    const left = valueNodeRect.left - itemTextOffset;
                    const leftDelta = triggerRect.left - left;
                    const minContentWidth = triggerRect.width + leftDelta;
                    const contentWidth = Math.max(minContentWidth, contentRect.width);
                    const rightEdge = window.innerWidth - CONTENT_MARGIN;
                    const clampedLeft = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$number$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clamp"])(left, [
                        CONTENT_MARGIN,
                        // Prevents the content from going off the starting edge of the
                        // viewport. It may still go off the ending edge, but this can be
                        // controlled by the user since they may want to manage overflow in a
                        // specific way.
                        // https://github.com/radix-ui/primitives/issues/2049
                        Math.max(CONTENT_MARGIN, rightEdge - contentWidth)
                    ]);
                    contentWrapper.style.minWidth = minContentWidth + "px";
                    contentWrapper.style.left = clampedLeft + "px";
                } else {
                    const itemTextOffset = contentRect.right - itemTextRect.right;
                    const right = window.innerWidth - valueNodeRect.right - itemTextOffset;
                    const rightDelta = window.innerWidth - triggerRect.right - right;
                    const minContentWidth = triggerRect.width + rightDelta;
                    const contentWidth = Math.max(minContentWidth, contentRect.width);
                    const leftEdge = window.innerWidth - CONTENT_MARGIN;
                    const clampedRight = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$number$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clamp"])(right, [
                        CONTENT_MARGIN,
                        Math.max(CONTENT_MARGIN, leftEdge - contentWidth)
                    ]);
                    contentWrapper.style.minWidth = minContentWidth + "px";
                    contentWrapper.style.right = clampedRight + "px";
                }
                const items = getItems();
                const availableHeight = window.innerHeight - CONTENT_MARGIN * 2;
                const itemsHeight = viewport.scrollHeight;
                const contentStyles = window.getComputedStyle(content);
                const contentBorderTopWidth = parseInt(contentStyles.borderTopWidth, 10);
                const contentPaddingTop = parseInt(contentStyles.paddingTop, 10);
                const contentBorderBottomWidth = parseInt(contentStyles.borderBottomWidth, 10);
                const contentPaddingBottom = parseInt(contentStyles.paddingBottom, 10);
                const fullContentHeight = contentBorderTopWidth + contentPaddingTop + itemsHeight + contentPaddingBottom + contentBorderBottomWidth;
                const minContentHeight = Math.min(selectedItem.offsetHeight * 5, fullContentHeight);
                const viewportStyles = window.getComputedStyle(viewport);
                const viewportPaddingTop = parseInt(viewportStyles.paddingTop, 10);
                const viewportPaddingBottom = parseInt(viewportStyles.paddingBottom, 10);
                const topEdgeToTriggerMiddle = triggerRect.top + triggerRect.height / 2 - CONTENT_MARGIN;
                const triggerMiddleToBottomEdge = availableHeight - topEdgeToTriggerMiddle;
                const selectedItemHalfHeight = selectedItem.offsetHeight / 2;
                const itemOffsetMiddle = selectedItem.offsetTop + selectedItemHalfHeight;
                const contentTopToItemMiddle = contentBorderTopWidth + contentPaddingTop + itemOffsetMiddle;
                const itemMiddleToContentBottom = fullContentHeight - contentTopToItemMiddle;
                const willAlignWithoutTopOverflow = contentTopToItemMiddle <= topEdgeToTriggerMiddle;
                if (willAlignWithoutTopOverflow) {
                    const isLastItem = items.length > 0 && selectedItem === items[items.length - 1].ref.current;
                    contentWrapper.style.bottom = "0px";
                    const viewportOffsetBottom = content.clientHeight - viewport.offsetTop - viewport.offsetHeight;
                    const clampedTriggerMiddleToBottomEdge = Math.max(triggerMiddleToBottomEdge, selectedItemHalfHeight + // viewport might have padding bottom, include it to avoid a scrollable viewport
                    (isLastItem ? viewportPaddingBottom : 0) + viewportOffsetBottom + contentBorderBottomWidth);
                    const height = contentTopToItemMiddle + clampedTriggerMiddleToBottomEdge;
                    contentWrapper.style.height = height + "px";
                } else {
                    const isFirstItem = items.length > 0 && selectedItem === items[0].ref.current;
                    contentWrapper.style.top = "0px";
                    const clampedTopEdgeToTriggerMiddle = Math.max(topEdgeToTriggerMiddle, contentBorderTopWidth + viewport.offsetTop + // viewport might have padding top, include it to avoid a scrollable viewport
                    (isFirstItem ? viewportPaddingTop : 0) + selectedItemHalfHeight);
                    const height = clampedTopEdgeToTriggerMiddle + itemMiddleToContentBottom;
                    contentWrapper.style.height = height + "px";
                    viewport.scrollTop = contentTopToItemMiddle - topEdgeToTriggerMiddle + viewport.offsetTop;
                }
                contentWrapper.style.margin = `${CONTENT_MARGIN}px 0`;
                contentWrapper.style.minHeight = minContentHeight + "px";
                contentWrapper.style.maxHeight = availableHeight + "px";
                onPlaced?.();
                requestAnimationFrame({
                    "SelectItemAlignedPosition.useCallback[position]": ()=>shouldExpandOnScrollRef.current = true
                }["SelectItemAlignedPosition.useCallback[position]"]);
            }
        }
    }["SelectItemAlignedPosition.useCallback[position]"], [
        getItems,
        context.trigger,
        context.valueNode,
        contentWrapper,
        content,
        viewport,
        selectedItem,
        selectedItemText,
        context.dir,
        onPlaced
    ]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$react$2d$use$2d$layout$2d$effect$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useLayoutEffect"])({
        "SelectItemAlignedPosition.useLayoutEffect": ()=>position()
    }["SelectItemAlignedPosition.useLayoutEffect"], [
        position
    ]);
    const [contentZIndex, setContentZIndex] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"]();
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$react$2d$use$2d$layout$2d$effect$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useLayoutEffect"])({
        "SelectItemAlignedPosition.useLayoutEffect": ()=>{
            if (content) setContentZIndex(window.getComputedStyle(content).zIndex);
        }
    }["SelectItemAlignedPosition.useLayoutEffect"], [
        content
    ]);
    const handleScrollButtonChange = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"]({
        "SelectItemAlignedPosition.useCallback[handleScrollButtonChange]": (node)=>{
            if (node && shouldRepositionRef.current === true) {
                position();
                focusSelectedItem?.();
                shouldRepositionRef.current = false;
            }
        }
    }["SelectItemAlignedPosition.useCallback[handleScrollButtonChange]"], [
        position,
        focusSelectedItem
    ]);
    return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(SelectViewportProvider, {
        scope: __scopeSelect,
        contentWrapper,
        shouldExpandOnScrollRef,
        onScrollButtonChange: handleScrollButtonChange,
        children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("div", {
            ref: setContentWrapper,
            style: {
                display: "flex",
                flexDirection: "column",
                position: "fixed",
                zIndex: contentZIndex
            },
            children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$react$2d$primitive$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Primitive"].div, {
                ...popperProps,
                ref: composedRefs,
                style: {
                    // When we get the height of the content, it includes borders. If we were to set
                    // the height without having `boxSizing: 'border-box'` it would be too big.
                    boxSizing: "border-box",
                    // We need to ensure the content doesn't get taller than the wrapper
                    maxHeight: "100%",
                    ...popperProps.style
                }
            })
        })
    });
});
SelectItemAlignedPosition.displayName = ITEM_ALIGNED_POSITION_NAME;
var POPPER_POSITION_NAME = "SelectPopperPosition";
var SelectPopperPosition = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["forwardRef"]((props, forwardedRef)=>{
    const { __scopeSelect, align = "start", collisionPadding = CONTENT_MARGIN, ...popperProps } = props;
    const popperScope = usePopperScope(__scopeSelect);
    return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$react$2d$popper$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Content"], {
        ...popperScope,
        ...popperProps,
        ref: forwardedRef,
        align,
        collisionPadding,
        style: {
            // Ensure border-box for floating-ui calculations
            boxSizing: "border-box",
            ...popperProps.style,
            // re-namespace exposed content custom properties
            ...{
                "--radix-select-content-transform-origin": "var(--radix-popper-transform-origin)",
                "--radix-select-content-available-width": "var(--radix-popper-available-width)",
                "--radix-select-content-available-height": "var(--radix-popper-available-height)",
                "--radix-select-trigger-width": "var(--radix-popper-anchor-width)",
                "--radix-select-trigger-height": "var(--radix-popper-anchor-height)"
            }
        }
    });
});
SelectPopperPosition.displayName = POPPER_POSITION_NAME;
var [SelectViewportProvider, useSelectViewportContext] = createSelectContext(CONTENT_NAME, {});
var VIEWPORT_NAME = "SelectViewport";
var SelectViewport = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["forwardRef"]((props, forwardedRef)=>{
    const { __scopeSelect, nonce, ...viewportProps } = props;
    const contentContext = useSelectContentContext(VIEWPORT_NAME, __scopeSelect);
    const viewportContext = useSelectViewportContext(VIEWPORT_NAME, __scopeSelect);
    const composedRefs = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$react$2d$compose$2d$refs$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useComposedRefs"])(forwardedRef, contentContext.onViewportChange);
    const prevScrollTopRef = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"](0);
    return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsxs"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Fragment"], {
        children: [
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("style", {
                dangerouslySetInnerHTML: {
                    __html: `[data-radix-select-viewport]{scrollbar-width:none;-ms-overflow-style:none;-webkit-overflow-scrolling:touch;}[data-radix-select-viewport]::-webkit-scrollbar{display:none}`
                },
                nonce
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(Collection.Slot, {
                scope: __scopeSelect,
                children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$react$2d$primitive$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Primitive"].div, {
                    "data-radix-select-viewport": "",
                    role: "presentation",
                    ...viewportProps,
                    ref: composedRefs,
                    style: {
                        // we use position: 'relative' here on the `viewport` so that when we call
                        // `selectedItem.offsetTop` in calculations, the offset is relative to the viewport
                        // (independent of the scrollUpButton).
                        position: "relative",
                        flex: 1,
                        // Viewport should only be scrollable in the vertical direction.
                        // This won't work in vertical writing modes, so we'll need to
                        // revisit this if/when that is supported
                        // https://developer.chrome.com/blog/vertical-form-controls
                        overflow: "hidden auto",
                        ...viewportProps.style
                    },
                    onScroll: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$primitive$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["composeEventHandlers"])(viewportProps.onScroll, (event)=>{
                        const viewport = event.currentTarget;
                        const { contentWrapper, shouldExpandOnScrollRef } = viewportContext;
                        if (shouldExpandOnScrollRef?.current && contentWrapper) {
                            const scrolledBy = Math.abs(prevScrollTopRef.current - viewport.scrollTop);
                            if (scrolledBy > 0) {
                                const availableHeight = window.innerHeight - CONTENT_MARGIN * 2;
                                const cssMinHeight = parseFloat(contentWrapper.style.minHeight);
                                const cssHeight = parseFloat(contentWrapper.style.height);
                                const prevHeight = Math.max(cssMinHeight, cssHeight);
                                if (prevHeight < availableHeight) {
                                    const nextHeight = prevHeight + scrolledBy;
                                    const clampedNextHeight = Math.min(availableHeight, nextHeight);
                                    const heightDiff = nextHeight - clampedNextHeight;
                                    contentWrapper.style.height = clampedNextHeight + "px";
                                    if (contentWrapper.style.bottom === "0px") {
                                        viewport.scrollTop = heightDiff > 0 ? heightDiff : 0;
                                        contentWrapper.style.justifyContent = "flex-end";
                                    }
                                }
                            }
                        }
                        prevScrollTopRef.current = viewport.scrollTop;
                    })
                })
            })
        ]
    });
});
SelectViewport.displayName = VIEWPORT_NAME;
var GROUP_NAME = "SelectGroup";
var [SelectGroupContextProvider, useSelectGroupContext] = createSelectContext(GROUP_NAME);
var SelectGroup = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["forwardRef"]((props, forwardedRef)=>{
    const { __scopeSelect, ...groupProps } = props;
    const groupId = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$react$2d$id$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useId"])();
    return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(SelectGroupContextProvider, {
        scope: __scopeSelect,
        id: groupId,
        children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$react$2d$primitive$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Primitive"].div, {
            role: "group",
            "aria-labelledby": groupId,
            ...groupProps,
            ref: forwardedRef
        })
    });
});
SelectGroup.displayName = GROUP_NAME;
var LABEL_NAME = "SelectLabel";
var SelectLabel = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["forwardRef"]((props, forwardedRef)=>{
    const { __scopeSelect, ...labelProps } = props;
    const groupContext = useSelectGroupContext(LABEL_NAME, __scopeSelect);
    return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$react$2d$primitive$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Primitive"].div, {
        id: groupContext.id,
        ...labelProps,
        ref: forwardedRef
    });
});
SelectLabel.displayName = LABEL_NAME;
var ITEM_NAME = "SelectItem";
var [SelectItemContextProvider, useSelectItemContext] = createSelectContext(ITEM_NAME);
var SelectItem = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["forwardRef"]((props, forwardedRef)=>{
    const { __scopeSelect, value, disabled = false, textValue: textValueProp, ...itemProps } = props;
    const context = useSelectContext(ITEM_NAME, __scopeSelect);
    const contentContext = useSelectContentContext(ITEM_NAME, __scopeSelect);
    const isSelected = context.value === value;
    const [textValue, setTextValue] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"](textValueProp ?? "");
    const [isFocused, setIsFocused] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"](false);
    const composedRefs = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$react$2d$compose$2d$refs$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useComposedRefs"])(forwardedRef, {
        "SelectItem.useComposedRefs[composedRefs]": (node)=>contentContext.itemRefCallback?.(node, value, disabled)
    }["SelectItem.useComposedRefs[composedRefs]"]);
    const textId = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$react$2d$id$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useId"])();
    const pointerTypeRef = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"]("touch");
    const handleSelect = ()=>{
        if (!disabled) {
            context.onValueChange(value);
            context.onOpenChange(false);
        }
    };
    if (value === "") {
        throw new Error("A <Select.Item /> must have a value prop that is not an empty string. This is because the Select value can be set to an empty string to clear the selection and show the placeholder.");
    }
    return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(SelectItemContextProvider, {
        scope: __scopeSelect,
        value,
        disabled,
        textId,
        isSelected,
        onItemTextChange: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"]({
            "SelectItem.useCallback": (node)=>{
                setTextValue({
                    "SelectItem.useCallback": (prevTextValue)=>prevTextValue || (node?.textContent ?? "").trim()
                }["SelectItem.useCallback"]);
            }
        }["SelectItem.useCallback"], []),
        children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(Collection.ItemSlot, {
            scope: __scopeSelect,
            value,
            disabled,
            textValue,
            children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$react$2d$primitive$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Primitive"].div, {
                role: "option",
                "aria-labelledby": textId,
                "data-highlighted": isFocused ? "" : void 0,
                "aria-selected": isSelected && isFocused,
                "data-state": isSelected ? "checked" : "unchecked",
                "aria-disabled": disabled || void 0,
                "data-disabled": disabled ? "" : void 0,
                tabIndex: disabled ? void 0 : -1,
                ...itemProps,
                ref: composedRefs,
                onFocus: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$primitive$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["composeEventHandlers"])(itemProps.onFocus, ()=>setIsFocused(true)),
                onBlur: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$primitive$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["composeEventHandlers"])(itemProps.onBlur, ()=>setIsFocused(false)),
                onClick: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$primitive$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["composeEventHandlers"])(itemProps.onClick, ()=>{
                    if (pointerTypeRef.current !== "mouse") handleSelect();
                }),
                onPointerUp: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$primitive$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["composeEventHandlers"])(itemProps.onPointerUp, ()=>{
                    if (pointerTypeRef.current === "mouse") handleSelect();
                }),
                onPointerDown: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$primitive$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["composeEventHandlers"])(itemProps.onPointerDown, (event)=>{
                    pointerTypeRef.current = event.pointerType;
                }),
                onPointerMove: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$primitive$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["composeEventHandlers"])(itemProps.onPointerMove, (event)=>{
                    pointerTypeRef.current = event.pointerType;
                    if (disabled) {
                        contentContext.onItemLeave?.();
                    } else if (pointerTypeRef.current === "mouse") {
                        event.currentTarget.focus({
                            preventScroll: true
                        });
                    }
                }),
                onPointerLeave: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$primitive$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["composeEventHandlers"])(itemProps.onPointerLeave, (event)=>{
                    if (event.currentTarget === document.activeElement) {
                        contentContext.onItemLeave?.();
                    }
                }),
                onKeyDown: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$primitive$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["composeEventHandlers"])(itemProps.onKeyDown, (event)=>{
                    const isTypingAhead = contentContext.searchRef?.current !== "";
                    if (isTypingAhead && event.key === " ") return;
                    if (SELECTION_KEYS.includes(event.key)) handleSelect();
                    if (event.key === " ") event.preventDefault();
                })
            })
        })
    });
});
SelectItem.displayName = ITEM_NAME;
var ITEM_TEXT_NAME = "SelectItemText";
var SelectItemText = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["forwardRef"]((props, forwardedRef)=>{
    const { __scopeSelect, className, style, ...itemTextProps } = props;
    const context = useSelectContext(ITEM_TEXT_NAME, __scopeSelect);
    const contentContext = useSelectContentContext(ITEM_TEXT_NAME, __scopeSelect);
    const itemContext = useSelectItemContext(ITEM_TEXT_NAME, __scopeSelect);
    const nativeOptionsContext = useSelectNativeOptionsContext(ITEM_TEXT_NAME, __scopeSelect);
    const [itemTextNode, setItemTextNode] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"](null);
    const composedRefs = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$react$2d$compose$2d$refs$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useComposedRefs"])(forwardedRef, {
        "SelectItemText.useComposedRefs[composedRefs]": (node)=>setItemTextNode(node)
    }["SelectItemText.useComposedRefs[composedRefs]"], itemContext.onItemTextChange, {
        "SelectItemText.useComposedRefs[composedRefs]": (node)=>contentContext.itemTextRefCallback?.(node, itemContext.value, itemContext.disabled)
    }["SelectItemText.useComposedRefs[composedRefs]"]);
    const textContent = itemTextNode?.textContent;
    const nativeOption = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"]({
        "SelectItemText.useMemo[nativeOption]": ()=>/* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("option", {
                value: itemContext.value,
                disabled: itemContext.disabled,
                children: textContent
            }, itemContext.value)
    }["SelectItemText.useMemo[nativeOption]"], [
        itemContext.disabled,
        itemContext.value,
        textContent
    ]);
    const { onNativeOptionAdd, onNativeOptionRemove } = nativeOptionsContext;
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$react$2d$use$2d$layout$2d$effect$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useLayoutEffect"])({
        "SelectItemText.useLayoutEffect": ()=>{
            onNativeOptionAdd(nativeOption);
            return ({
                "SelectItemText.useLayoutEffect": ()=>onNativeOptionRemove(nativeOption)
            })["SelectItemText.useLayoutEffect"];
        }
    }["SelectItemText.useLayoutEffect"], [
        onNativeOptionAdd,
        onNativeOptionRemove,
        nativeOption
    ]);
    return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsxs"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Fragment"], {
        children: [
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$react$2d$primitive$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Primitive"].span, {
                id: itemContext.textId,
                ...itemTextProps,
                ref: composedRefs
            }),
            itemContext.isSelected && context.valueNode && !context.valueNodeHasChildren ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2d$dom$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createPortal"](itemTextProps.children, context.valueNode) : null
        ]
    });
});
SelectItemText.displayName = ITEM_TEXT_NAME;
var ITEM_INDICATOR_NAME = "SelectItemIndicator";
var SelectItemIndicator = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["forwardRef"]((props, forwardedRef)=>{
    const { __scopeSelect, ...itemIndicatorProps } = props;
    const itemContext = useSelectItemContext(ITEM_INDICATOR_NAME, __scopeSelect);
    return itemContext.isSelected ? /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$react$2d$primitive$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Primitive"].span, {
        "aria-hidden": true,
        ...itemIndicatorProps,
        ref: forwardedRef
    }) : null;
});
SelectItemIndicator.displayName = ITEM_INDICATOR_NAME;
var SCROLL_UP_BUTTON_NAME = "SelectScrollUpButton";
var SelectScrollUpButton = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["forwardRef"]((props, forwardedRef)=>{
    const contentContext = useSelectContentContext(SCROLL_UP_BUTTON_NAME, props.__scopeSelect);
    const viewportContext = useSelectViewportContext(SCROLL_UP_BUTTON_NAME, props.__scopeSelect);
    const [canScrollUp, setCanScrollUp] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"](false);
    const composedRefs = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$react$2d$compose$2d$refs$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useComposedRefs"])(forwardedRef, viewportContext.onScrollButtonChange);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$react$2d$use$2d$layout$2d$effect$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useLayoutEffect"])({
        "SelectScrollUpButton.useLayoutEffect": ()=>{
            if (contentContext.viewport && contentContext.isPositioned) {
                let handleScroll2 = {
                    "SelectScrollUpButton.useLayoutEffect.handleScroll2": function() {
                        const canScrollUp2 = viewport.scrollTop > 0;
                        setCanScrollUp(canScrollUp2);
                    }
                }["SelectScrollUpButton.useLayoutEffect.handleScroll2"];
                var handleScroll = handleScroll2;
                const viewport = contentContext.viewport;
                handleScroll2();
                viewport.addEventListener("scroll", handleScroll2);
                return ({
                    "SelectScrollUpButton.useLayoutEffect": ()=>viewport.removeEventListener("scroll", handleScroll2)
                })["SelectScrollUpButton.useLayoutEffect"];
            }
        }
    }["SelectScrollUpButton.useLayoutEffect"], [
        contentContext.viewport,
        contentContext.isPositioned
    ]);
    return canScrollUp ? /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(SelectScrollButtonImpl, {
        ...props,
        ref: composedRefs,
        onAutoScroll: ()=>{
            const { viewport, selectedItem } = contentContext;
            if (viewport && selectedItem) {
                viewport.scrollTop = viewport.scrollTop - selectedItem.offsetHeight;
            }
        }
    }) : null;
});
SelectScrollUpButton.displayName = SCROLL_UP_BUTTON_NAME;
var SCROLL_DOWN_BUTTON_NAME = "SelectScrollDownButton";
var SelectScrollDownButton = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["forwardRef"]((props, forwardedRef)=>{
    const contentContext = useSelectContentContext(SCROLL_DOWN_BUTTON_NAME, props.__scopeSelect);
    const viewportContext = useSelectViewportContext(SCROLL_DOWN_BUTTON_NAME, props.__scopeSelect);
    const [canScrollDown, setCanScrollDown] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"](false);
    const composedRefs = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$react$2d$compose$2d$refs$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useComposedRefs"])(forwardedRef, viewportContext.onScrollButtonChange);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$react$2d$use$2d$layout$2d$effect$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useLayoutEffect"])({
        "SelectScrollDownButton.useLayoutEffect": ()=>{
            if (contentContext.viewport && contentContext.isPositioned) {
                let handleScroll2 = {
                    "SelectScrollDownButton.useLayoutEffect.handleScroll2": function() {
                        const maxScroll = viewport.scrollHeight - viewport.clientHeight;
                        const canScrollDown2 = Math.ceil(viewport.scrollTop) < maxScroll;
                        setCanScrollDown(canScrollDown2);
                    }
                }["SelectScrollDownButton.useLayoutEffect.handleScroll2"];
                var handleScroll = handleScroll2;
                const viewport = contentContext.viewport;
                handleScroll2();
                viewport.addEventListener("scroll", handleScroll2);
                return ({
                    "SelectScrollDownButton.useLayoutEffect": ()=>viewport.removeEventListener("scroll", handleScroll2)
                })["SelectScrollDownButton.useLayoutEffect"];
            }
        }
    }["SelectScrollDownButton.useLayoutEffect"], [
        contentContext.viewport,
        contentContext.isPositioned
    ]);
    return canScrollDown ? /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(SelectScrollButtonImpl, {
        ...props,
        ref: composedRefs,
        onAutoScroll: ()=>{
            const { viewport, selectedItem } = contentContext;
            if (viewport && selectedItem) {
                viewport.scrollTop = viewport.scrollTop + selectedItem.offsetHeight;
            }
        }
    }) : null;
});
SelectScrollDownButton.displayName = SCROLL_DOWN_BUTTON_NAME;
var SelectScrollButtonImpl = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["forwardRef"]((props, forwardedRef)=>{
    const { __scopeSelect, onAutoScroll, ...scrollIndicatorProps } = props;
    const contentContext = useSelectContentContext("SelectScrollButton", __scopeSelect);
    const autoScrollTimerRef = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"](null);
    const getItems = useCollection(__scopeSelect);
    const clearAutoScrollTimer = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"]({
        "SelectScrollButtonImpl.useCallback[clearAutoScrollTimer]": ()=>{
            if (autoScrollTimerRef.current !== null) {
                window.clearInterval(autoScrollTimerRef.current);
                autoScrollTimerRef.current = null;
            }
        }
    }["SelectScrollButtonImpl.useCallback[clearAutoScrollTimer]"], []);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"]({
        "SelectScrollButtonImpl.useEffect": ()=>{
            return ({
                "SelectScrollButtonImpl.useEffect": ()=>clearAutoScrollTimer()
            })["SelectScrollButtonImpl.useEffect"];
        }
    }["SelectScrollButtonImpl.useEffect"], [
        clearAutoScrollTimer
    ]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$react$2d$use$2d$layout$2d$effect$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useLayoutEffect"])({
        "SelectScrollButtonImpl.useLayoutEffect": ()=>{
            const activeItem = getItems().find({
                "SelectScrollButtonImpl.useLayoutEffect.activeItem": (item)=>item.ref.current === document.activeElement
            }["SelectScrollButtonImpl.useLayoutEffect.activeItem"]);
            activeItem?.ref.current?.scrollIntoView({
                block: "nearest"
            });
        }
    }["SelectScrollButtonImpl.useLayoutEffect"], [
        getItems
    ]);
    return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$react$2d$primitive$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Primitive"].div, {
        "aria-hidden": true,
        ...scrollIndicatorProps,
        ref: forwardedRef,
        style: {
            flexShrink: 0,
            ...scrollIndicatorProps.style
        },
        onPointerDown: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$primitive$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["composeEventHandlers"])(scrollIndicatorProps.onPointerDown, ()=>{
            if (autoScrollTimerRef.current === null) {
                autoScrollTimerRef.current = window.setInterval(onAutoScroll, 50);
            }
        }),
        onPointerMove: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$primitive$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["composeEventHandlers"])(scrollIndicatorProps.onPointerMove, ()=>{
            contentContext.onItemLeave?.();
            if (autoScrollTimerRef.current === null) {
                autoScrollTimerRef.current = window.setInterval(onAutoScroll, 50);
            }
        }),
        onPointerLeave: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$primitive$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["composeEventHandlers"])(scrollIndicatorProps.onPointerLeave, ()=>{
            clearAutoScrollTimer();
        })
    });
});
var SEPARATOR_NAME = "SelectSeparator";
var SelectSeparator = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["forwardRef"]((props, forwardedRef)=>{
    const { __scopeSelect, ...separatorProps } = props;
    return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$react$2d$primitive$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Primitive"].div, {
        "aria-hidden": true,
        ...separatorProps,
        ref: forwardedRef
    });
});
SelectSeparator.displayName = SEPARATOR_NAME;
var ARROW_NAME = "SelectArrow";
var SelectArrow = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["forwardRef"]((props, forwardedRef)=>{
    const { __scopeSelect, ...arrowProps } = props;
    const popperScope = usePopperScope(__scopeSelect);
    const context = useSelectContext(ARROW_NAME, __scopeSelect);
    const contentContext = useSelectContentContext(ARROW_NAME, __scopeSelect);
    return context.open && contentContext.position === "popper" ? /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$react$2d$popper$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Arrow"], {
        ...popperScope,
        ...arrowProps,
        ref: forwardedRef
    }) : null;
});
SelectArrow.displayName = ARROW_NAME;
function shouldShowPlaceholder(value) {
    return value === "" || value === void 0;
}
var BubbleSelect = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["forwardRef"]((props, forwardedRef)=>{
    const { value, ...selectProps } = props;
    const ref = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"](null);
    const composedRefs = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$react$2d$compose$2d$refs$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useComposedRefs"])(forwardedRef, ref);
    const prevValue = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$react$2d$use$2d$previous$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["usePrevious"])(value);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"]({
        "BubbleSelect.useEffect": ()=>{
            const select = ref.current;
            const selectProto = window.HTMLSelectElement.prototype;
            const descriptor = Object.getOwnPropertyDescriptor(selectProto, "value");
            const setValue = descriptor.set;
            if (prevValue !== value && setValue) {
                const event = new Event("change", {
                    bubbles: true
                });
                setValue.call(select, value);
                select.dispatchEvent(event);
            }
        }
    }["BubbleSelect.useEffect"], [
        prevValue,
        value
    ]);
    return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$react$2d$visually$2d$hidden$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VisuallyHidden"], {
        asChild: true,
        children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("select", {
            ...selectProps,
            ref: composedRefs,
            defaultValue: value
        })
    });
});
BubbleSelect.displayName = "BubbleSelect";
function useTypeaheadSearch(onSearchChange) {
    const handleSearchChange = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$react$2d$use$2d$callback$2d$ref$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallbackRef"])(onSearchChange);
    const searchRef = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"]("");
    const timerRef = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"](0);
    const handleTypeaheadSearch = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"]({
        "useTypeaheadSearch.useCallback[handleTypeaheadSearch]": (key)=>{
            const search = searchRef.current + key;
            handleSearchChange(search);
            (function updateSearch(value) {
                searchRef.current = value;
                window.clearTimeout(timerRef.current);
                if (value !== "") timerRef.current = window.setTimeout({
                    "useTypeaheadSearch.useCallback[handleTypeaheadSearch].updateSearch": ()=>updateSearch("")
                }["useTypeaheadSearch.useCallback[handleTypeaheadSearch].updateSearch"], 1e3);
            })(search);
        }
    }["useTypeaheadSearch.useCallback[handleTypeaheadSearch]"], [
        handleSearchChange
    ]);
    const resetTypeahead = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"]({
        "useTypeaheadSearch.useCallback[resetTypeahead]": ()=>{
            searchRef.current = "";
            window.clearTimeout(timerRef.current);
        }
    }["useTypeaheadSearch.useCallback[resetTypeahead]"], []);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"]({
        "useTypeaheadSearch.useEffect": ()=>{
            return ({
                "useTypeaheadSearch.useEffect": ()=>window.clearTimeout(timerRef.current)
            })["useTypeaheadSearch.useEffect"];
        }
    }["useTypeaheadSearch.useEffect"], []);
    return [
        searchRef,
        handleTypeaheadSearch,
        resetTypeahead
    ];
}
function findNextItem(items, search, currentItem) {
    const isRepeated = search.length > 1 && Array.from(search).every((char)=>char === search[0]);
    const normalizedSearch = isRepeated ? search[0] : search;
    const currentItemIndex = currentItem ? items.indexOf(currentItem) : -1;
    let wrappedItems = wrapArray(items, Math.max(currentItemIndex, 0));
    const excludeCurrentItem = normalizedSearch.length === 1;
    if (excludeCurrentItem) wrappedItems = wrappedItems.filter((v)=>v !== currentItem);
    const nextItem = wrappedItems.find((item)=>item.textValue.toLowerCase().startsWith(normalizedSearch.toLowerCase()));
    return nextItem !== currentItem ? nextItem : void 0;
}
function wrapArray(array, startIndex) {
    return array.map((_, index)=>array[(startIndex + index) % array.length]);
}
var Root2 = Select;
var Trigger = SelectTrigger;
var Value = SelectValue;
var Icon = SelectIcon;
var Portal = SelectPortal;
var Content2 = SelectContent;
var Viewport = SelectViewport;
var Group = SelectGroup;
var Label = SelectLabel;
var Item = SelectItem;
var ItemText = SelectItemText;
var ItemIndicator = SelectItemIndicator;
var ScrollUpButton = SelectScrollUpButton;
var ScrollDownButton = SelectScrollDownButton;
var Separator = SelectSeparator;
var Arrow2 = SelectArrow;
;
 //# sourceMappingURL=index.mjs.map
}),
"[project]/node_modules/lucide-react/dist/esm/icons/chevron-down.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * @license lucide-react v0.454.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ __turbopack_context__.s([
    "default",
    ()=>ChevronDown
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lucide-react/dist/esm/createLucideIcon.js [app-client] (ecmascript)");
;
const ChevronDown = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])("ChevronDown", [
    [
        "path",
        {
            d: "m6 9 6 6 6-6",
            key: "qrunsl"
        }
    ]
]);
;
 //# sourceMappingURL=chevron-down.js.map
}),
"[project]/node_modules/lucide-react/dist/esm/icons/chevron-down.js [app-client] (ecmascript) <export default as ChevronDownIcon>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ChevronDownIcon",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$chevron$2d$down$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$chevron$2d$down$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lucide-react/dist/esm/icons/chevron-down.js [app-client] (ecmascript)");
}),
"[project]/node_modules/lucide-react/dist/esm/icons/chevron-up.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * @license lucide-react v0.454.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ __turbopack_context__.s([
    "default",
    ()=>ChevronUp
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lucide-react/dist/esm/createLucideIcon.js [app-client] (ecmascript)");
;
const ChevronUp = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])("ChevronUp", [
    [
        "path",
        {
            d: "m18 15-6-6-6 6",
            key: "153udz"
        }
    ]
]);
;
 //# sourceMappingURL=chevron-up.js.map
}),
"[project]/node_modules/lucide-react/dist/esm/icons/chevron-up.js [app-client] (ecmascript) <export default as ChevronUpIcon>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ChevronUpIcon",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$chevron$2d$up$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$chevron$2d$up$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lucide-react/dist/esm/icons/chevron-up.js [app-client] (ecmascript)");
}),
]);

//# sourceMappingURL=node_modules_dfbca22d._.js.map