{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 52, "column": 0}, "map": {"version":3,"sources":["file:///E:/Project%20Files/Earning-model/stamp-card-project/stamp-loyalty-platform/lib/aiParser.js"],"sourcesContent":["import OpenAI from \"openai\";\r\n\r\nconst client = new OpenAI({\r\n  apiKey: process.env.OPENAI_API_KEY,\r\n});\r\n\r\n// --------------------\r\n// Helper: robust JSON extraction\r\n// --------------------\r\nfunction parseLLMJson(raw) {\r\n  if (!raw) throw new Error(\"Empty AI response\");\r\n\r\n  let text = raw\r\n    .trim()\r\n    .replace(/^```json/i, \"\")\r\n    .replace(/^```/, \"\")\r\n    .replace(/```$/, \"\")\r\n    .trim();\r\n\r\n  const start = text.indexOf(\"{\");\r\n  const end = text.lastIndexOf(\"}\");\r\n  if (start === -1 || end === -1) {\r\n    throw new Error(\"No JSON object found in AI output\");\r\n  }\r\n\r\n  return JSON.parse(\r\n    text\r\n      .slice(start, end + 1)\r\n      .replace(/,\\s*}/g, \"}\")\r\n      .replace(/,\\s*]/g, \"]\")\r\n      .replace(/\\n/g, \" \")\r\n      .replace(/\\t/g, \" \")\r\n  );\r\n}\r\n\r\n// --------------------\r\n// Helper: reject hallucinated dates\r\n// --------------------\r\nfunction isReasonableDate(dateStr) {\r\n  const d = new Date(dateStr);\r\n  if (isNaN(d.getTime())) return false;\r\n\r\n  const now = new Date();\r\n\r\n  // ‚ùå reject future dates (+1 day buffer)\r\n  if (d > new Date(now.getTime() + 24 * 60 * 60 * 1000)) return false;\r\n\r\n  // ‚ùå reject very old dates (>7 days)\r\n  if (d < new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000)) return false;\r\n\r\n  return true;\r\n}\r\n\r\n// --------------------\r\n// MAIN AI OCR FUNCTION\r\n// --------------------\r\nexport async function parsePaymentScreenshot(imageBase64) {\r\n  try {\r\n    const system =\r\n      \"You are an OCR extraction system. Output ONLY valid JSON.\";\r\n\r\n    const userPrompt = `\r\nExtract payment info from the UPI payment screenshot.\r\n\r\nRules:\r\n- amount: number | null\r\n- upiId: string | null (must contain '@')\r\n- utr: string | null (12‚Äì18 alphanumeric characters)\r\n- date: YYYY-MM-DD | null\r\n- time: HH:MM or HH:MM:SS | null\r\n- status: success | failed | pending | unknown\r\n- app: GPay | PhonePe | Paytm | AmazonPay | UNKNOWN\r\n- fake: boolean\r\n- confidence: number between 0 and 1\r\n\r\nCRITICAL DATE RULES:\r\n- Extract date ONLY if the YEAR is clearly visible in the image.\r\n- If the year is missing, unclear, or inferred ‚Üí return date = null.\r\n- Do NOT guess or infer year from context or current date.\r\n- Time may be extracted even if date is null.\r\n\r\nOTHER RULES:\r\n- Do NOT guess any value.\r\n- If unclear or unreadable, return null.\r\n- Output ONLY JSON.\r\n`;\r\n\r\n    const res = await client.chat.completions.create({\r\n      model: \"gpt-4.1-mini\",\r\n      temperature: 0,\r\n      max_tokens: 180,\r\n      messages: [\r\n        { role: \"system\", content: system },\r\n        {\r\n          role: \"user\",\r\n          content: [\r\n            { type: \"text\", text: userPrompt },\r\n            {\r\n              type: \"image_url\",\r\n              image_url: {\r\n                url: `data:image/jpeg;base64,${imageBase64}`,\r\n              },\r\n            },\r\n          ],\r\n        },\r\n      ],\r\n    });\r\n\r\n    const raw = res.choices[0]?.message?.content;\r\n    const parsed = parseLLMJson(raw);\r\n\r\n    return {\r\n      // ---------- Amount ----------\r\n      amount:\r\n        typeof parsed.amount === \"number\" && !isNaN(parsed.amount)\r\n          ? parsed.amount\r\n          : null,\r\n\r\n      // ---------- UPI ID ----------\r\n      upiId:\r\n        typeof parsed.upiId === \"string\" &&\r\n          parsed.upiId.includes(\"@\")\r\n          ? parsed.upiId\r\n          : null,\r\n\r\n      // ---------- UTR ----------\r\n      utr:\r\n        typeof parsed.utr === \"string\" &&\r\n          /^[A-Za-z0-9]{12,18}$/.test(parsed.utr)\r\n          ? parsed.utr\r\n          : null,\r\n\r\n      // ---------- Date (STRICT) ----------\r\n      date:\r\n        typeof parsed.date === \"string\" &&\r\n          /^\\d{4}-\\d{2}-\\d{2}$/.test(parsed.date) &&\r\n          isReasonableDate(parsed.date)\r\n          ? parsed.date\r\n          : null,\r\n\r\n      // ---------- Time ----------\r\n      time:\r\n        typeof parsed.time === \"string\" &&\r\n          /^(\\d{2}:\\d{2}|\\d{2}:\\d{2}:\\d{2})$/.test(parsed.time)\r\n          ? parsed.time\r\n          : null,\r\n\r\n      // ---------- Status ----------\r\n      status:\r\n        typeof parsed.status === \"string\" &&\r\n          [\"success\", \"failed\", \"pending\", \"unknown\"].includes(\r\n            parsed.status.toLowerCase()\r\n          )\r\n          ? parsed.status.toLowerCase()\r\n          : \"unknown\",\r\n\r\n      // ---------- App ----------\r\n      appDetected:\r\n        typeof parsed.app === \"string\"\r\n          ? parsed.app\r\n          : \"UNKNOWN\",\r\n\r\n      // ---------- Fraud ----------\r\n      isLikelyFake: Boolean(parsed.fake),\r\n\r\n      // ---------- Confidence ----------\r\n      confidence:\r\n        typeof parsed.confidence === \"number\"\r\n          ? Math.min(Math.max(parsed.confidence, 0), 1)\r\n          : 0,\r\n    };\r\n  } catch (err) {\r\n    console.error(\"AI OCR ERROR ‚Üí\", err);\r\n\r\n    return {\r\n      amount: null,\r\n      upiId: null,\r\n      utr: null,\r\n      date: null,\r\n      time: null,\r\n      status: \"unknown\",\r\n      appDetected: \"UNKNOWN\",\r\n      isLikelyFake: false,\r\n      confidence: 0,\r\n      aiError: true,\r\n    };\r\n  }\r\n}\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 195, "column": 0}, "map": {"version":3,"sources":["file:///E:/Project%20Files/Earning-model/stamp-card-project/stamp-loyalty-platform/lib/tools.js"],"sourcesContent":["// image resize \r\nimport sharp from \"sharp\"; // for metadata + brightness\r\nimport exifr from \"exifr\"; // for screenshot EXIF check\r\n\r\n\r\n// Helper function ‚Äî simple variance check\r\nasync function computeNoiseVariance(buffer) {\r\n  const raw = await sharp(buffer).greyscale().raw().toBuffer();\r\n  const mean = raw.reduce((a, b) => a + b, 0) / raw.length;\r\n\r\n  let sumSq = 0;\r\n  for (let i = 0; i < raw.length; i++) {\r\n    sumSq += Math.pow(raw[i] - mean, 2);\r\n  }\r\n\r\n  return { variance: sumSq / raw.length };\r\n}\r\n\r\n\r\n// Simple edge detection using Sobel\r\nasync function computeEdgeScore(buffer) {\r\n  const img = await sharp(buffer)\r\n    .greyscale()\r\n    .raw()\r\n    .toBuffer({ resolveWithObject: true });\r\n\r\n  let edges = 0;\r\n  let transitions = 0;\r\n\r\n  for (let i = 1; i < img.data.length; i++) {\r\n    if (Math.abs(img.data[i] - img.data[i - 1]) > 30) {\r\n      edges++;\r\n    }\r\n    transitions++;\r\n  }\r\n\r\n  return edges / transitions; // 0‚Äì1 score\r\n}\r\n\r\n\r\n\r\n// ss validation \r\nexport async function validateScreenshotBeforeAI(buffer, clientOCR) {\r\n  const meta = await sharp(buffer).metadata();\r\n\r\n  // 1Ô∏è‚É£ Resolution\r\n  if (meta.width < 400 || meta.height < 600) {\r\n    return \"low_resolution\";\r\n  }\r\n\r\n  // 2Ô∏è‚É£ Aspect ratio (UPI screenshots are tall)\r\n  const ratio = meta.height / meta.width;\r\n  if (ratio < 1.6 || ratio > 2.7) {\r\n    return \"invalid_aspect_ratio\";\r\n  }\r\n\r\n  // 3Ô∏è‚É£ Brightness (SAFE for all formats)\r\n  const raw = await sharp(buffer).greyscale().raw().toBuffer();\r\n  let total = 0;\r\n  for (let i = 0; i < raw.length; i++) total += raw[i];\r\n  const brightness = total / raw.length;\r\n\r\n  if (brightness < 15) {\r\n    return \"bad_brightness\"; // too dark or too bright\r\n  }\r\n\r\n  // 4Ô∏è‚É£ Screenshot vs Photo detection (EXIF)\r\n  let exif = null;\r\n  try {\r\n    exif = await exifr.parse(buffer);\r\n  } catch (_) { }\r\n\r\n  if (exif && (exif.LensModel || exif.ExposureTime || exif.ISO || exif.FNumber)) {\r\n    return \"not_a_screenshot\"; // it's a camera photo\r\n  }\r\n\r\n  // 5Ô∏è‚É£ Client OCR strength\r\n  const clientText =\r\n    typeof clientOCR?.text === \"string\"\r\n      ? clientOCR.text.toLowerCase()\r\n      : \"\";\r\n\r\n  if (clientText.length < 10) {\r\n    return \"text_too_short\";\r\n  }\r\n\r\n  // 6Ô∏è‚É£ UPI Detection (Advanced)\r\n  const keywords = [\r\n    // Generic UPI terms\r\n    \"upi\", \"unified payments\", \"transaction\", \"ref no\", \"reference\",\r\n    \"paid to\", \"credited\", \"debited\", \"‚Çπ\", \"rs\", \"amount\", \"received\",\r\n    \"txn\", \"upi ref\", \"transaction id\",\r\n\r\n    // Google Pay\r\n    \"gpay\", \"google pay\",\r\n\r\n    // PhonePe\r\n    \"phonepe\", \"phone pe\",\r\n\r\n    // Paytm\r\n    \"paytm\",\r\n\r\n    // BHIM\r\n    \"bhim\", \"bharat interface for money\",\r\n\r\n    // WhatsApp Pay\r\n    \"whatsapp pay\", \"wa pay\",\r\n\r\n    // Amazon Pay\r\n    \"amazon pay\", \"amazon upi\",\r\n\r\n    // Bank UPI Apps\r\n    \"sbi upi\", \"icici upi\", \"hdfc upi\", \"axis upi\", \"kotak upi\",\r\n\r\n    // VPA keywords\r\n    \"upi id\", \"vpa\", \"@ok\", \"@upi\", \"@oksbi\", \"@okaxis\", \"@okhdfcbank\",\r\n    \"@ybl\", \"@ibl\", \"@axl\", \"@idfcbank\"\r\n  ];\r\n\r\n  // üîç Fuzzy search to handle OCR mistakes\r\n  function fuzzyIncludes(text, keyword) {\r\n    return text.replace(/\\s+/g, \"\").includes(keyword.replace(/\\s+/g, \"\"));\r\n  }\r\n\r\n  let found = keywords.some((k) => fuzzyIncludes(clientText, k));\r\n\r\n\r\n  // 6.1Ô∏è‚É£ Success phrases (GPay / PhonePe / Paytm)\r\n  const successPhrases = [\r\n    \"payment successful\",\r\n    \"money sent\",\r\n    \"you paid\",\r\n    \"transaction successful\",\r\n    \"paid successfully\",\r\n    \"credited to your account\",\r\n    \"debited from your account\",\r\n    \"sent to\",\r\n    \"received from\"\r\n  ];\r\n\r\n  if (!found) {\r\n    found = successPhrases.some((p) => fuzzyIncludes(clientText, p));\r\n  }\r\n\r\n\r\n  // 6.2Ô∏è‚É£ UPI handle detection (regex)\r\n  const upiHandleRegex = /[a-z0-9._%+-]+@([a-z]+|[a-z]+bank|okaxis|oksbi|ybl|ibl|axl)/i;\r\n  if (!found && upiHandleRegex.test(clientText)) {\r\n    found = true;\r\n  }\r\n\r\n\r\n  // 6.3Ô∏è‚É£ Amount pattern detection\r\n  const amountRegex = /(‚Çπ|rs\\.?)\\s?\\d+(\\.\\d{1,2})?/i;\r\n  if (!found && amountRegex.test(clientText)) {\r\n    found = true;\r\n  }\r\n\r\n\r\n  // 6.4Ô∏è‚É£ Transaction layout keywords\r\n  const layoutKeywords = [\"to\", \"from\", \"via upi\", \"scan & pay\", \"scan and pay\"];\r\n  if (!found) {\r\n    found = layoutKeywords.some((k) => fuzzyIncludes(clientText, k));\r\n  }\r\n\r\n  // 7.1 Noise Analysis ‚Äî detect overly smooth areas (edited or AI)\r\n  const { variance } = await computeNoiseVariance(buffer);\r\n  if (variance < 5) return \"suspiciously_smooth\"; // edited / AI look\r\n\r\n  // 7.2 Edge Detection ‚Äî high edge discontinuity means edits\r\n  const edgeScore = await computeEdgeScore(buffer);\r\n  if (edgeScore > 0.35) return \"edge_artifacts_detected\";\r\n\r\n  // 7.3 Compression Pattern Consistency\r\n  if (meta.format === \"jpeg\" && meta.density && meta.density < 50) {\r\n    return \"weird_compression_pattern\";\r\n  }\r\n\r\n  // 7.4 Metadata inconsistencies\r\n  if (exif && exif.Software && exif.Software.includes(\"Photoshop\")) {\r\n    return \"edited_metadata\";\r\n  }\r\n\r\n\r\n\r\n  // ‚ùå final fail if NOTHING matched\r\n  if (!found) return \"not_upi_keywords\";\r\n\r\n\r\n  return null; // VALID\r\n}\r\n\r\n\r\n\r\n// detect payment paid or else \r\nexport function detectPaymentDirection(text = \"\") {\r\n  const t = text.toLowerCase();\r\n\r\n  const paidWords = [\r\n    \"paid successfully\",\r\n    \"paid\",\r\n    \"payment successful\",\r\n    \"you paid\",\r\n    \"sent\",\r\n    \"debited\",\r\n    \"paid to\",\r\n  ];\r\n\r\n  const receivedWords = [\r\n    \"received\",\r\n    \"payment received\",\r\n    \"credited\",\r\n    \"you received\",\r\n    \"received from\",\r\n    \"money received\",\r\n  ];\r\n\r\n  const paid = paidWords.some((w) => t.includes(w));\r\n  const received = receivedWords.some((w) => t.includes(w));\r\n\r\n  if (paid && !received) return \"PAID\";\r\n  if (!paid && received) return \"RECEIVED\";\r\n\r\n  // If both appear ‚Üí pick strongest match\r\n  if (paid && received) {\r\n    // Usually amount is closer to paid area\r\n    return \"PAID\";\r\n  }\r\n\r\n  return \"UNKNOWN\";\r\n}\r\n\r\n\r\n// extract date for ocr \r\nexport function extractDate(text) {\r\n  if (!text) return null;\r\n\r\n  text = text.replace(/,/g, \"\").trim();\r\n\r\n  // Supported formats:\r\n  // 24/01/2025\r\n  // 24-01-2025\r\n  // 24.01.2025\r\n  // 2025/01/24\r\n  // 24 Jan 2025\r\n  // Jan 24 2025\r\n\r\n  const patterns = [\r\n    /\\b(\\d{2})\\/(\\d{2})\\/(\\d{4})\\b/,      // 24/01/2025\r\n    /\\b(\\d{2})-(\\d{2})-(\\d{4})\\b/,        // 24-01-2025\r\n    /\\b(\\d{2})\\.(\\d{2})\\.(\\d{4})\\b/,      // 24.01.2025\r\n    /\\b(\\d{4})\\/(\\d{2})\\/(\\d{2})\\b/,      // 2025/01/24\r\n    /\\b(\\d{2})\\s([A-Za-z]+)\\s(\\d{4})\\b/,  // 24 Jan 2025\r\n    /\\b([A-Za-z]+)\\s(\\d{2})\\s(\\d{4})\\b/   // Jan 24 2025\r\n  ];\r\n\r\n  for (let regex of patterns) {\r\n    const match = text.match(regex);\r\n    if (match) return match[0]; // Return exact date string found\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\n\r\n// convert ist date to utc \r\nexport function ISTMidnightToUTC() {\r\n  const now = new Date();\r\n  const istOffset = 5.5 * 60 * 60 * 1000;\r\n\r\n  const istDate = new Date(now.getTime() + istOffset);\r\n  const istMidnight = new Date(\r\n    istDate.getFullYear(),\r\n    istDate.getMonth(),\r\n    istDate.getDate(),\r\n    0, 0, 0, 0\r\n  );\r\n\r\n  return new Date(istMidnight.getTime() - istOffset);\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 447, "column": 0}, "map": {"version":3,"sources":["file:///E:/Project%20Files/Earning-model/stamp-card-project/stamp-loyalty-platform/lib/upiTime.js"],"sourcesContent":["/**\r\n * Validate screenshot date + time independently,\r\n * supporting all UPI app variations.\r\n */\r\nexport function validateUPIScreenshotTime(dateStr, timeStr) {\r\n    if (!dateStr || !timeStr) {\r\n        return { valid: false, reason: \"invalid_date_or_time\" };\r\n    }\r\n\r\n    // Normalize input\r\n    dateStr = dateStr.trim().replace(/,/g, \"\");\r\n    timeStr = timeStr.trim().replace(/\\./g, \":\").replace(/-/g, \":\");\r\n\r\n    const parsedTime = parseUPITime(timeStr);\r\n    if (!parsedTime) {\r\n        return { valid: false, reason: \"invalid_time_format\" };\r\n    }\r\n\r\n    const now = new Date();\r\n\r\n    // ---- DATE VALIDATION (DATE ONLY) ----\r\n    const screenshotDate = stripTime(new Date(dateStr));\r\n    const today = stripTime(now);\r\n\r\n    if (screenshotDate < today) {\r\n        return { valid: false, reason: \"old_screenshot_date\" };\r\n    }\r\n\r\n    if (screenshotDate > today) {\r\n        return { valid: false, reason: \"future_screenshot_date\" };\r\n    }\r\n\r\n    // ---- TIME VALIDATION (PAST 15 MIN ONLY) ----\r\n    if (!isWithinLast15Minutes(parsedTime)) {\r\n        return { valid: false, reason: \"time_limit_end\" };\r\n    }\r\n\r\n    // ---- COMBINE DATE + TIME ----\r\n    const finalDateTime = new Date(\r\n        today.getFullYear(),\r\n        today.getMonth(),\r\n        today.getDate(),\r\n        parsedTime.hour,\r\n        parsedTime.minute,\r\n        parsedTime.second || 0,\r\n        0\r\n    );\r\n\r\n    return {\r\n        valid: true,\r\n        dateTime: finalDateTime,\r\n    };\r\n}\r\n\r\n/** -------------------------------\r\n * Remove time from date\r\n ----------------------------------*/\r\nfunction stripTime(d) {\r\n    return new Date(d.getFullYear(), d.getMonth(), d.getDate());\r\n}\r\n\r\n/** -------------------------------\r\n * UPI TIME PARSER (ALL FORMATS)\r\n ----------------------------------*/\r\nfunction parseUPITime(timeStr) {\r\n    let str = timeStr.toLowerCase();\r\n    str = str.replace(/-/g, \":\").replace(/\\./g, \":\");\r\n\r\n    // HH:MM(:SS) AM/PM\r\n    let m = str.match(/^(\\d{1,2}):(\\d{2})(?:\\:(\\d{2}))?\\s?(am|pm)$/);\r\n    if (m) {\r\n        let h = +m[1];\r\n        const min = +m[2];\r\n        const sec = m[3] ? +m[3] : 0;\r\n\r\n        if (m[4] === \"pm\" && h !== 12) h += 12;\r\n        if (m[4] === \"am\" && h === 12) h = 0;\r\n\r\n        return { hour: h, minute: min, second: sec };\r\n    }\r\n\r\n    // 24-hour HH:MM(:SS)\r\n    m = str.match(/^(\\d{1,2}):(\\d{2})(?:\\:(\\d{2}))?$/);\r\n    if (m) {\r\n        return {\r\n            hour: +m[1],\r\n            minute: +m[2],\r\n            second: m[3] ? +m[3] : 0,\r\n        };\r\n    }\r\n\r\n    return null;\r\n}\r\n\r\n/** -------------------------------\r\n * Check past 15 minutes only\r\n ----------------------------------*/\r\nfunction isWithinLast15Minutes(time) {\r\n    const now = new Date();\r\n\r\n    const nowSeconds =\r\n        now.getHours() * 3600 +\r\n        now.getMinutes() * 60 +\r\n        now.getSeconds();\r\n\r\n    const givenSeconds =\r\n        time.hour * 3600 +\r\n        time.minute * 60 +\r\n        (time.second || 0);\r\n\r\n    const secondsInDay = 24 * 3600;\r\n\r\n    let diff = nowSeconds - givenSeconds;\r\n\r\n    // midnight crossing\r\n    if (diff < 0) diff += secondsInDay;\r\n\r\n    return diff >= 0 && diff <= 15 * 60;\r\n}\r\n"],"names":[],"mappings":"AAAA;;;CAGC;;;;AACM,SAAS,0BAA0B,OAAO,EAAE,OAAO;IACtD,IAAI,CAAC,WAAW,CAAC,SAAS;QACtB,OAAO;YAAE,OAAO;YAAO,QAAQ;QAAuB;IAC1D;IAEA,kBAAkB;IAClB,UAAU,QAAQ,IAAI,GAAG,OAAO,CAAC,MAAM;IACvC,UAAU,QAAQ,IAAI,GAAG,OAAO,CAAC,OAAO,KAAK,OAAO,CAAC,MAAM;IAE3D,MAAM,aAAa,aAAa;IAChC,IAAI,CAAC,YAAY;QACb,OAAO;YAAE,OAAO;YAAO,QAAQ;QAAsB;IACzD;IAEA,MAAM,MAAM,IAAI;IAEhB,wCAAwC;IACxC,MAAM,iBAAiB,UAAU,IAAI,KAAK;IAC1C,MAAM,QAAQ,UAAU;IAExB,IAAI,iBAAiB,OAAO;QACxB,OAAO;YAAE,OAAO;YAAO,QAAQ;QAAsB;IACzD;IAEA,IAAI,iBAAiB,OAAO;QACxB,OAAO;YAAE,OAAO;YAAO,QAAQ;QAAyB;IAC5D;IAEA,+CAA+C;IAC/C,IAAI,CAAC,sBAAsB,aAAa;QACpC,OAAO;YAAE,OAAO;YAAO,QAAQ;QAAiB;IACpD;IAEA,gCAAgC;IAChC,MAAM,gBAAgB,IAAI,KACtB,MAAM,WAAW,IACjB,MAAM,QAAQ,IACd,MAAM,OAAO,IACb,WAAW,IAAI,EACf,WAAW,MAAM,EACjB,WAAW,MAAM,IAAI,GACrB;IAGJ,OAAO;QACH,OAAO;QACP,UAAU;IACd;AACJ;AAEA;;mCAEmC,GACnC,SAAS,UAAU,CAAC;IAChB,OAAO,IAAI,KAAK,EAAE,WAAW,IAAI,EAAE,QAAQ,IAAI,EAAE,OAAO;AAC5D;AAEA;;mCAEmC,GACnC,SAAS,aAAa,OAAO;IACzB,IAAI,MAAM,QAAQ,WAAW;IAC7B,MAAM,IAAI,OAAO,CAAC,MAAM,KAAK,OAAO,CAAC,OAAO;IAE5C,mBAAmB;IACnB,IAAI,IAAI,IAAI,KAAK,CAAC;IAClB,IAAI,GAAG;QACH,IAAI,IAAI,CAAC,CAAC,CAAC,EAAE;QACb,MAAM,MAAM,CAAC,CAAC,CAAC,EAAE;QACjB,MAAM,MAAM,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC,CAAC,EAAE,GAAG;QAE3B,IAAI,CAAC,CAAC,EAAE,KAAK,QAAQ,MAAM,IAAI,KAAK;QACpC,IAAI,CAAC,CAAC,EAAE,KAAK,QAAQ,MAAM,IAAI,IAAI;QAEnC,OAAO;YAAE,MAAM;YAAG,QAAQ;YAAK,QAAQ;QAAI;IAC/C;IAEA,qBAAqB;IACrB,IAAI,IAAI,KAAK,CAAC;IACd,IAAI,GAAG;QACH,OAAO;YACH,MAAM,CAAC,CAAC,CAAC,EAAE;YACX,QAAQ,CAAC,CAAC,CAAC,EAAE;YACb,QAAQ,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC,CAAC,EAAE,GAAG;QAC3B;IACJ;IAEA,OAAO;AACX;AAEA;;mCAEmC,GACnC,SAAS,sBAAsB,IAAI;IAC/B,MAAM,MAAM,IAAI;IAEhB,MAAM,aACF,IAAI,QAAQ,KAAK,OACjB,IAAI,UAAU,KAAK,KACnB,IAAI,UAAU;IAElB,MAAM,eACF,KAAK,IAAI,GAAG,OACZ,KAAK,MAAM,GAAG,KACd,CAAC,KAAK,MAAM,IAAI,CAAC;IAErB,MAAM,eAAe,KAAK;IAE1B,IAAI,OAAO,aAAa;IAExB,oBAAoB;IACpB,IAAI,OAAO,GAAG,QAAQ;IAEtB,OAAO,QAAQ,KAAK,QAAQ,KAAK;AACrC"}},
    {"offset": {"line": 558, "column": 0}, "map": {"version":3,"sources":["file:///E:/Project%20Files/Earning-model/stamp-card-project/stamp-loyalty-platform/app/api/screenshot/verify/route.js"],"sourcesContent":["export const runtime = \"nodejs\";\r\n\r\nimport { NextResponse } from \"next/server\";\r\nimport crypto from \"crypto\";\r\nimport { parsePaymentScreenshot } from \"@/lib/aiParser\";\r\nimport { validateScreenshotBeforeAI } from \"@/lib/tools\";\r\nimport { detectPaymentDirection, ISTMidnightToUTC } from \"@/lib/tools\";\r\nimport { validateUPIScreenshotTime } from \"@/lib/upiTime\";\r\nimport { nanoid } from \"nanoid\"\r\n\r\n\r\n/** SHA256 hash generator */\r\nfunction sha256(buffer) {\r\n    return crypto.createHash(\"sha256\").update(buffer).digest(\"hex\");\r\n}\r\n\r\nexport async function POST(req) {\r\n    try {\r\n        // ‚úÖ Lazy import Prisma (build-safe)\r\n        const { default: prisma } = await import(\"@/lib/prisma\");\r\n\r\n        const formData = await req.formData();\r\n\r\n        const file = formData.get(\"file\");\r\n        const shopId = formData.get(\"shopId\");\r\n        const phone = formData.get(\"phone\");\r\n        const ocrJson = formData.get(\"ocrResult\");\r\n\r\n        let rejectReason = null;\r\n\r\n\r\n\r\n        if (!file || !shopId || !ocrJson || !phone) {\r\n            return NextResponse.json(\r\n                { error: \"Missing required fields\" },\r\n                { status: 400 }\r\n            );\r\n        }\r\n\r\n        // FETCH CUSTOMER \r\n        let customer = await prisma.customer.findFirst({\r\n            where: { shopId, phone },\r\n        });\r\n\r\n        const clientOCR = JSON.parse(ocrJson);\r\n        const { text: rawText } = clientOCR;\r\n\r\n\r\n        // --------------------------------------\r\n        // 1Ô∏è‚É£ HASH ORIGINAL IMAGE (True Duplicate Prevention) and checksum\r\n        // --------------------------------------\r\n        const bytes = await file.arrayBuffer();\r\n        const buffer = Buffer.from(bytes);\r\n        const screenshotHash = sha256(buffer);\r\n        // base 64 image \r\n        const imageBase64 = buffer.toString(\"base64\");\r\n\r\n        // checksum \r\n        const checksum = crypto\r\n            .createHash(\"sha256\")\r\n            .update(\r\n                rawText\r\n                    ?.toLowerCase()\r\n                    .replace(/\\s+/g, \" \")\r\n                    .replace(/[^\\x20-\\x7E]/g, \"\")\r\n                    .trim()\r\n            )\r\n            .digest(\"hex\");\r\n\r\n\r\n\r\n\r\n\r\n        // --------------------------------------\r\n        // 2Ô∏è‚É£ FETCH SHOP and subscription details \r\n        // --------------------------------------\r\n        const shop = await prisma.shop.findUnique({ where: { id: shopId } });\r\n        if (!shop) {\r\n            return NextResponse.json(\r\n                { error: \"Invalid shopId.\" },\r\n                { status: 404 }\r\n            );\r\n        }\r\n\r\n        // Shop active check\r\n        if (!shop.isActive) {\r\n            return NextResponse.json(\r\n                { success: false, error: \"Shop is inactive.\" },\r\n                { status: 403 }\r\n            );\r\n        }\r\n\r\n        // get shop subscription details \r\n        const subscription = await prisma.subscription.findFirst({\r\n            where: { shopId }\r\n        });\r\n        if (!subscription) {\r\n            return NextResponse.json(\r\n                { success: false, error: \"Shop is not subscribed.\" },\r\n                { status: 403 }\r\n            );\r\n        }\r\n\r\n        const now = new Date();\r\n        const validStatuses = [\"active\", \"trailing\"];\r\n        // STATUS VALIDATION\r\n        const isStatusValid = validStatuses.includes(subscription.status);\r\n\r\n        // DATE VALIDATION (UTC-safe)\r\n        const isExpired = new Date(subscription.nextBillingAt) < now;\r\n\r\n        // subscription status \r\n        if (!isStatusValid || isExpired) {\r\n            return NextResponse.json(\r\n                { success: false, error: \"Subscription expired.\" },\r\n                { status: 403 }\r\n            );\r\n        }\r\n\r\n\r\n        // --------------------------------------\r\n        // 4Ô∏è‚É£ daily upload limit\r\n        // --------------------------------------\r\n        const utcStart = ISTMidnightToUTC();\r\n        const dailyUploads = await prisma.scanVerification.count({\r\n            where: {\r\n                shopId,\r\n                phone,\r\n                createdAt: { gte: utcStart },\r\n                status: \"success\"\r\n            },\r\n        });\r\n\r\n\r\n        if (dailyUploads >= shop.maxStampsPerCustomerPerDay) {\r\n            return NextResponse.json(\r\n                {\r\n                    success: false,\r\n                    error: \"daily_upload_limit_reached\",\r\n                },\r\n                { status: 429 }\r\n            );\r\n        }\r\n\r\n\r\n        // 3Ô∏è‚É£ Detect payment direction (paid / received / unknown)\r\n        if (!rejectReason) {\r\n            const paymentDirection = detectPaymentDirection(rawText);\r\n\r\n            if (paymentDirection == 'RECEIVED') {\r\n                rejectReason = 'received_payment_direction.'\r\n            }\r\n        }\r\n\r\n\r\n\r\n        // --------------------------------------\r\n        // 4Ô∏è‚É£ PRE-VALIDATION BEFORE AI (cost saving)\r\n        // --------------------------------------\r\n        if (!rejectReason) {\r\n            const preFail = await validateScreenshotBeforeAI(buffer, clientOCR);\r\n\r\n            if (preFail) {\r\n                rejectReason = preFail;\r\n            }\r\n        }\r\n\r\n\r\n        // --------------------------------------\r\n        // 5Ô∏è‚É£ CHECK DUPLICATE SCREENSHOT\r\n        // --------------------------------------\r\n        if (!rejectReason) {\r\n            const duplicateHash = await prisma.scanVerification.findFirst({\r\n                where: {\r\n                    shopId,\r\n                    screenshotHash,\r\n                    status: \"success\"\r\n                },\r\n            });\r\n\r\n            if (duplicateHash) {\r\n                rejectReason = 'duplicate_image_hash'\r\n            }\r\n        }\r\n\r\n\r\n        //  Check duplicate OCR checksum\r\n        if (!rejectReason) {\r\n            const duplicateChecksum = await prisma.scanVerification.findFirst({\r\n                where: {\r\n                    shopId,\r\n                    checksum,\r\n                    status: \"success\"\r\n                }\r\n            });\r\n\r\n            if (duplicateChecksum) {\r\n                rejectReason = 'duplicate_image_ocr'\r\n            }\r\n        }\r\n\r\n\r\n        // pre ai verification scan save\r\n        if (rejectReason) {\r\n            const scan = await prisma.scanVerification.create({\r\n                data: {\r\n                    shopId,\r\n                    phone: phone,\r\n                    customerId: customer ? customer.id : null,\r\n                    amount: null,\r\n                    currency: \"INR\",\r\n                    upiId: clientOCR.upiId ?? null,\r\n                    utr: clientOCR.utr ?? null,\r\n                    paidAt: new Date(),\r\n                    status: \"rejected\",\r\n                    rejectReason,\r\n                    screenshotHash,\r\n                    appDetected: 'UNKNOWN',\r\n                    ocrText: rawText,\r\n                    checksum,\r\n                    verifiedAt: new Date()\r\n                },\r\n            });\r\n\r\n            return NextResponse.json(\r\n                { success: false, rejectReason },\r\n                { status: 400 }\r\n            );\r\n        }\r\n\r\n\r\n        // --------------------------------------\r\n        // 6Ô∏è‚É£ AI OCR FIX PROCESSING\r\n        // --------------------------------------\r\n        const ai = await parsePaymentScreenshot(imageBase64);\r\n\r\n        if (ai.aiError) {\r\n            console.log(\"‚ö† AI unavailable ‚Äî continuing with client OCR only\");\r\n\r\n            return NextResponse.json(\r\n                { success: false, error: 'Server error' },\r\n                { status: 400 }\r\n            );\r\n\r\n        }\r\n\r\n        console.log(\"AI FIXED OCR ‚Üí\", ai);\r\n\r\n        // AI corrected values (fallback to client OCR)\r\n        const amount = ai.amount ?? null;\r\n        let upiId = ai.upiId ?? clientOCR.upiId ?? null;\r\n        const utr = ai.utr ?? clientOCR.utr ?? null;\r\n        const date = ai.date ?? clientOCR.date ?? null;\r\n        const time = ai.time ?? clientOCR.time ?? null;\r\n        const appDetected = ai.appDetected ?? \"UNKNOWN\";\r\n        const isLikelyFake = ai.isLikelyFake ?? false;\r\n        const confidence = ai.confidence ?? null;\r\n        const status = ai.status ?? false\r\n\r\n\r\n\r\n        // if payment status not success \r\n        if (!rejectReason) {\r\n            if (status !== \"success\") {\r\n                rejectReason = 'status_not_success'\r\n            }\r\n        }\r\n\r\n        // check utr \r\n        if (!rejectReason) {\r\n            if (utr) {\r\n                const utrRegex = /^[0-9A-Za-z]{12,18}$/;\r\n\r\n                const utrExists = await prisma.scanVerification.findFirst({\r\n                    where: { shopId, utr, status: 'success' },\r\n                });\r\n\r\n                if (!utrRegex.test(utr)) {\r\n                    rejectReason = 'invalid_utr'\r\n                }\r\n\r\n                // duplicate utr \r\n                if (utrExists) {\r\n                    rejectReason = 'utr_already_exist'\r\n                }\r\n            }\r\n        }\r\n\r\n\r\n        // Validate amount\r\n        if (!rejectReason) {\r\n            if (!amount) {\r\n                rejectReason = 'amount_not_existed'\r\n            }\r\n        }\r\n\r\n        // amount limit \r\n        if (!rejectReason) {\r\n            if (amount) {\r\n                if (amount < shop.minAmount) {\r\n                    rejectReason = 'amount_below_mimimum'\r\n                }\r\n            }\r\n        }\r\n\r\n\r\n        // time and date validation \r\n        if (!rejectReason) {\r\n            const timeCheck = validateUPIScreenshotTime(date, time);\r\n            if (!timeCheck.valid) {\r\n                rejectReason = timeCheck.reason\r\n            }\r\n        }\r\n\r\n\r\n        // AI flagged fake\r\n        if (!rejectReason) {\r\n            if (isLikelyFake) {\r\n                rejectReason = \"suspicious_screenshot\";\r\n            }\r\n        }\r\n\r\n        // check confidance \r\n        if (!rejectReason) {\r\n            if (confidence) {\r\n                if (confidence < 0.80) {\r\n                    rejectReason = 'low_confidence'\r\n                }\r\n            }\r\n        }\r\n\r\n        // normaize text \r\n        function normalizeText(text) {\r\n            return text\r\n                ?.toLowerCase()\r\n                .replace(/[^a-z0-9@]/g, \"\");\r\n        }\r\n\r\n        const normalizedRaw = normalizeText(rawText);\r\n\r\n\r\n        // upi mismatch \r\n        if (!rejectReason && !upiId) {\r\n            rejectReason = 'upi_not_exist'\r\n\r\n            if (normalizedRaw.includes(shop.upiId)) {\r\n                upiId = shop.upiId\r\n                rejectReason = null\r\n            }\r\n        }\r\n\r\n        if (!rejectReason && upiId) {\r\n            if (upiId !== shop.upiId) {\r\n                rejectReason = 'upi_mismatch'\r\n            }\r\n\r\n            if (normalizedRaw.includes(shop.upiId)) {\r\n                upiId = shop.upiId\r\n                rejectReason = null\r\n            }\r\n        }\r\n\r\n\r\n        // --------------------------------------\r\n        //  CREATE CUSTOMER\r\n        // --------------------------------------\r\n        if (!customer && !rejectReason) {\r\n            customer = await prisma.customer.create({\r\n                data: {\r\n                    id: `cust_${nanoid(10)}`,\r\n                    shopId,\r\n                    phone,\r\n                },\r\n            });\r\n        }\r\n\r\n\r\n\r\n        // --------------------------------------\r\n        // 7Ô∏è‚É£ SAVE THE VERIFICATION RECORD\r\n        // --------------------------------------\r\n        const scan = await prisma.scanVerification.create({\r\n            data: {\r\n                shopId,\r\n                phone: phone,\r\n                customerId: customer ? customer.id : null,\r\n                amount,\r\n                currency: \"INR\",\r\n                upiId,\r\n                utr,\r\n                paidAt: new Date(),\r\n                status: rejectReason ? rejectReason === 'upi_mismatch' || rejectReason === 'upi_not_exist' ? 'pending' : \"rejected\" : \"success\",\r\n                rejectReason,\r\n                screenshotHash,\r\n                appDetected,\r\n                ocrText: rawText,\r\n                checksum,\r\n                verifiedAt: rejectReason ? rejectReason === 'upi_mismatch' || rejectReason === 'upi_not_exist' ? null : new Date() : new Date()\r\n            },\r\n        });\r\n\r\n        // If failed fraud check ‚Üí return here\r\n        if (rejectReason) {\r\n            return NextResponse.json(\r\n                { success: false, rejectReason },\r\n                { status: 400 }\r\n            );\r\n        }\r\n\r\n\r\n\r\n        // --------------------------------------\r\n        // 8Ô∏è‚É£ AWARD STAMP\r\n        // --------------------------------------\r\n        await prisma.customer.update({\r\n            where: { id: customer.id },\r\n            data: {\r\n                stampCount: { increment: 1 },\r\n                totalVisits: { increment: 1 },\r\n                totalStampCount: { increment: 1 },\r\n                lastVisit: new Date(),\r\n            },\r\n        });\r\n\r\n\r\n        return NextResponse.json({\r\n            success: true,\r\n            message: \"Stamp added!\",\r\n            scanId: scan.id,\r\n        });\r\n\r\n\r\n    } catch (err) {\r\n        console.error(\"VERIFY ERROR ‚Üí\", err);\r\n        return NextResponse.json(\r\n            { error: \"Server Error\" },\r\n            { status: 500 }\r\n        );\r\n    }\r\n}\r\n"],"names":[],"mappings":"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"}}]
}