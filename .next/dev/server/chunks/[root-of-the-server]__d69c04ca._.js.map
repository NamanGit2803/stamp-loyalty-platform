{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 58, "column": 0}, "map": {"version":3,"sources":["file:///E:/Project%20Files/Earning-model/stamp-card-project/stamp-loyalty-platform/lib/aiParser.js"],"sourcesContent":["import OpenAI from \"openai\";\r\n\r\nconst client = new OpenAI({\r\n  apiKey: process.env.OPENAI_API_KEY,\r\n});\r\n\r\nfunction parseLLMJson(raw) {\r\n  if (!raw) throw new Error(\"Empty AI response\");\r\n\r\n  let text = raw\r\n    .trim()\r\n    .replace(/^```json/i, \"\")\r\n    .replace(/^```/, \"\")\r\n    .replace(/```$/, \"\")\r\n    .trim();\r\n\r\n  const start = text.indexOf(\"{\");\r\n  const end = text.lastIndexOf(\"}\");\r\n  if (start === -1 || end === -1) throw new Error(\"No JSON object found\");\r\n\r\n  return JSON.parse(\r\n    text\r\n      .slice(start, end + 1)\r\n      .replace(/,\\s*}/g, \"}\")\r\n      .replace(/,\\s*]/g, \"]\")\r\n      .replace(/\\n/g, \" \")\r\n      .replace(/\\t/g, \" \")\r\n  );\r\n}\r\n\r\nexport async function parsePaymentScreenshot(imageBase64) {\r\n  try {\r\n    const system = \"You are an OCR extraction system. Output ONLY valid JSON.\";\r\n    const user = `\r\nExtract payment info from screenshot.\r\n\r\nRules:\r\namount: number | null\r\nupiId: string | null  (must contain '@')\r\nutr: string | null (8‚Äì25 chars)\r\ndate: YYYY-MM-DD | null\r\ntime: HH:MM or HH:MM:SS | null\r\nstatus: success | failed | pending | unknown\r\napp: GPay | PhonePe | Paytm | AmazonPay | UNKNOWN\r\nfake: boolean\r\nconfidence: 0‚Äì1\r\n\r\nOutput JSON only.\r\n`;\r\n\r\n    const res = await client.chat.completions.create({\r\n      model: \"gpt-4.1-mini\",\r\n      messages: [\r\n        { role: \"system\", content: system },\r\n        {\r\n          role: \"user\",\r\n          content: [\r\n            { type: \"text\", text: user },\r\n            {\r\n              type: \"image\",\r\n              image_url: `data:image/jpeg;base64,${imageBase64}`,\r\n            },\r\n          ],\r\n        },\r\n      ],\r\n      temperature: 0,\r\n      max_tokens: 180, // a bit more because status added\r\n    });\r\n\r\n    const raw = res.choices[0].message.content;\r\n    const parsed = parseLLMJson(raw);\r\n\r\n    return {\r\n      amount: typeof parsed.amount === \"number\" ? parsed.amount : null,\r\n\r\n      upiId:\r\n        typeof parsed.upiId === \"string\" &&\r\n          parsed.upiId.includes(\"@\")\r\n          ? parsed.upiId\r\n          : null,\r\n\r\n      utr:\r\n        typeof parsed.utr === \"string\" &&\r\n          /^[a-zA-Z0-9]{8,25}$/.test(parsed.utr)\r\n          ? parsed.utr\r\n          : null,\r\n\r\n      date:\r\n        typeof parsed.date === \"string\" &&\r\n          /^\\d{4}-\\d{2}-\\d{2}$/.test(parsed.date)\r\n          ? parsed.date\r\n          : null,\r\n\r\n      time:\r\n        typeof parsed.time === \"string\" &&\r\n          /^(\\d{2}:\\d{2}|\\d{2}:\\d{2}:\\d{2})$/.test(parsed.time)\r\n          ? parsed.time\r\n          : null,\r\n\r\n      // ‚≠ê STATUS extraction added here\r\n      status:\r\n        typeof parsed.status === \"string\" &&\r\n          [\"success\", \"failed\", \"pending\", \"unknown\"].includes(\r\n            parsed.status.toLowerCase()\r\n          )\r\n          ? parsed.status.toLowerCase()\r\n          : \"unknown\",\r\n\r\n      appDetected: parsed.app || \"UNKNOWN\",\r\n      isLikelyFake: Boolean(parsed.fake),\r\n\r\n      confidence:\r\n        typeof parsed.confidence === \"number\"\r\n          ? Math.min(Math.max(parsed.confidence, 0), 1)\r\n          : 0.5,\r\n    };\r\n  } catch (err) {\r\n    console.error(\"AI OCR ERROR ‚Üí\", err);\r\n    return {\r\n      amount: null,\r\n      upiId: null,\r\n      utr: null,\r\n      date: null,\r\n      time: null,\r\n      status: \"unknown\",\r\n      appDetected: \"UNKNOWN\",\r\n      isLikelyFake: false,\r\n      confidence: 0,\r\n      aiError: true,\r\n    };\r\n  }\r\n}\r\n"],"names":[],"mappings":";;;;AAAA;AAAA;;AAEA,MAAM,SAAS,IAAI,mLAAM,CAAC;IACxB,QAAQ,QAAQ,GAAG,CAAC,cAAc;AACpC;AAEA,SAAS,aAAa,GAAG;IACvB,IAAI,CAAC,KAAK,MAAM,IAAI,MAAM;IAE1B,IAAI,OAAO,IACR,IAAI,GACJ,OAAO,CAAC,aAAa,IACrB,OAAO,CAAC,QAAQ,IAChB,OAAO,CAAC,QAAQ,IAChB,IAAI;IAEP,MAAM,QAAQ,KAAK,OAAO,CAAC;IAC3B,MAAM,MAAM,KAAK,WAAW,CAAC;IAC7B,IAAI,UAAU,CAAC,KAAK,QAAQ,CAAC,GAAG,MAAM,IAAI,MAAM;IAEhD,OAAO,KAAK,KAAK,CACf,KACG,KAAK,CAAC,OAAO,MAAM,GACnB,OAAO,CAAC,UAAU,KAClB,OAAO,CAAC,UAAU,KAClB,OAAO,CAAC,OAAO,KACf,OAAO,CAAC,OAAO;AAEtB;AAEO,eAAe,uBAAuB,WAAW;IACtD,IAAI;QACF,MAAM,SAAS;QACf,MAAM,OAAO,CAAC;;;;;;;;;;;;;;;AAelB,CAAC;QAEG,MAAM,MAAM,MAAM,OAAO,IAAI,CAAC,WAAW,CAAC,MAAM,CAAC;YAC/C,OAAO;YACP,UAAU;gBACR;oBAAE,MAAM;oBAAU,SAAS;gBAAO;gBAClC;oBACE,MAAM;oBACN,SAAS;wBACP;4BAAE,MAAM;4BAAQ,MAAM;wBAAK;wBAC3B;4BACE,MAAM;4BACN,WAAW,CAAC,uBAAuB,EAAE,aAAa;wBACpD;qBACD;gBACH;aACD;YACD,aAAa;YACb,YAAY;QACd;QAEA,MAAM,MAAM,IAAI,OAAO,CAAC,EAAE,CAAC,OAAO,CAAC,OAAO;QAC1C,MAAM,SAAS,aAAa;QAE5B,OAAO;YACL,QAAQ,OAAO,OAAO,MAAM,KAAK,WAAW,OAAO,MAAM,GAAG;YAE5D,OACE,OAAO,OAAO,KAAK,KAAK,YACtB,OAAO,KAAK,CAAC,QAAQ,CAAC,OACpB,OAAO,KAAK,GACZ;YAEN,KACE,OAAO,OAAO,GAAG,KAAK,YACpB,sBAAsB,IAAI,CAAC,OAAO,GAAG,IACnC,OAAO,GAAG,GACV;YAEN,MACE,OAAO,OAAO,IAAI,KAAK,YACrB,sBAAsB,IAAI,CAAC,OAAO,IAAI,IACpC,OAAO,IAAI,GACX;YAEN,MACE,OAAO,OAAO,IAAI,KAAK,YACrB,oCAAoC,IAAI,CAAC,OAAO,IAAI,IAClD,OAAO,IAAI,GACX;YAEN,iCAAiC;YACjC,QACE,OAAO,OAAO,MAAM,KAAK,YACvB;gBAAC;gBAAW;gBAAU;gBAAW;aAAU,CAAC,QAAQ,CAClD,OAAO,MAAM,CAAC,WAAW,MAEzB,OAAO,MAAM,CAAC,WAAW,KACzB;YAEN,aAAa,OAAO,GAAG,IAAI;YAC3B,cAAc,QAAQ,OAAO,IAAI;YAEjC,YACE,OAAO,OAAO,UAAU,KAAK,WACzB,KAAK,GAAG,CAAC,KAAK,GAAG,CAAC,OAAO,UAAU,EAAE,IAAI,KACzC;QACR;IACF,EAAE,OAAO,KAAK;QACZ,QAAQ,KAAK,CAAC,kBAAkB;QAChC,OAAO;YACL,QAAQ;YACR,OAAO;YACP,KAAK;YACL,MAAM;YACN,MAAM;YACN,QAAQ;YACR,aAAa;YACb,cAAc;YACd,YAAY;YACZ,SAAS;QACX;IACF;AACF"}},
    {"offset": {"line": 164, "column": 0}, "map": {"version":3,"sources":["file:///E:/Project%20Files/Earning-model/stamp-card-project/stamp-loyalty-platform/lib/tools.js"],"sourcesContent":["// image resize \r\nimport sharp from \"sharp\"; // for metadata + brightness\r\nimport exifr from \"exifr\"; // for screenshot EXIF check\r\n\r\n\r\n// Helper function ‚Äî simple variance check\r\nasync function computeNoiseVariance(buffer) {\r\n  const raw = await sharp(buffer).greyscale().raw().toBuffer();\r\n  const mean = raw.reduce((a, b) => a + b, 0) / raw.length;\r\n\r\n  let sumSq = 0;\r\n  for (let i = 0; i < raw.length; i++) {\r\n    sumSq += Math.pow(raw[i] - mean, 2);\r\n  }\r\n\r\n  return { variance: sumSq / raw.length };\r\n}\r\n\r\n\r\n// Simple edge detection using Sobel\r\nasync function computeEdgeScore(buffer) {\r\n  const img = await sharp(buffer)\r\n    .greyscale()\r\n    .raw()\r\n    .toBuffer({ resolveWithObject: true });\r\n\r\n  let edges = 0;\r\n  let transitions = 0;\r\n\r\n  for (let i = 1; i < img.data.length; i++) {\r\n    if (Math.abs(img.data[i] - img.data[i - 1]) > 30) {\r\n      edges++;\r\n    }\r\n    transitions++;\r\n  }\r\n\r\n  return edges / transitions; // 0‚Äì1 score\r\n}\r\n\r\n\r\n\r\n// ss validation \r\nexport async function validateScreenshotBeforeAI(buffer, clientOCR) {\r\n  const meta = await sharp(buffer).metadata();\r\n\r\n  // 1Ô∏è‚É£ Resolution\r\n  if (meta.width < 400 || meta.height < 600) {\r\n    return \"low_resolution\";\r\n  }\r\n\r\n  // 2Ô∏è‚É£ Aspect ratio (UPI screenshots are tall)\r\n  const ratio = meta.height / meta.width;\r\n  if (ratio < 1.6 || ratio > 2.7) {\r\n    return \"invalid_aspect_ratio\";\r\n  }\r\n\r\n  // 3Ô∏è‚É£ Brightness (SAFE for all formats)\r\n  const raw = await sharp(buffer).greyscale().raw().toBuffer();\r\n  let total = 0;\r\n  for (let i = 0; i < raw.length; i++) total += raw[i];\r\n  const brightness = total / raw.length;\r\n\r\n  if (brightness < 15) {\r\n    return \"bad_brightness\"; // too dark or too bright\r\n  }\r\n\r\n  // 4Ô∏è‚É£ Screenshot vs Photo detection (EXIF)\r\n  let exif = null;\r\n  try {\r\n    exif = await exifr.parse(buffer);\r\n  } catch (_) { }\r\n\r\n  if (exif && (exif.LensModel || exif.ExposureTime || exif.ISO || exif.FNumber)) {\r\n    return \"not_a_screenshot\"; // it's a camera photo\r\n  }\r\n\r\n  // 5Ô∏è‚É£ Client OCR strength\r\n  const clientText =\r\n    typeof clientOCR?.text === \"string\"\r\n      ? clientOCR.text.toLowerCase()\r\n      : \"\";\r\n\r\n  if (clientText.length < 10) {\r\n    return \"text_too_short\";\r\n  }\r\n\r\n  // 6Ô∏è‚É£ UPI Detection (Advanced)\r\n  const keywords = [\r\n    // Generic UPI terms\r\n    \"upi\", \"unified payments\", \"transaction\", \"ref no\", \"reference\",\r\n    \"paid to\", \"credited\", \"debited\", \"‚Çπ\", \"rs\", \"amount\", \"received\",\r\n    \"txn\", \"upi ref\", \"transaction id\",\r\n\r\n    // Google Pay\r\n    \"gpay\", \"google pay\",\r\n\r\n    // PhonePe\r\n    \"phonepe\", \"phone pe\",\r\n\r\n    // Paytm\r\n    \"paytm\",\r\n\r\n    // BHIM\r\n    \"bhim\", \"bharat interface for money\",\r\n\r\n    // WhatsApp Pay\r\n    \"whatsapp pay\", \"wa pay\",\r\n\r\n    // Amazon Pay\r\n    \"amazon pay\", \"amazon upi\",\r\n\r\n    // Bank UPI Apps\r\n    \"sbi upi\", \"icici upi\", \"hdfc upi\", \"axis upi\", \"kotak upi\",\r\n\r\n    // VPA keywords\r\n    \"upi id\", \"vpa\", \"@ok\", \"@upi\", \"@oksbi\", \"@okaxis\", \"@okhdfcbank\",\r\n    \"@ybl\", \"@ibl\", \"@axl\", \"@idfcbank\"\r\n  ];\r\n\r\n  // üîç Fuzzy search to handle OCR mistakes\r\n  function fuzzyIncludes(text, keyword) {\r\n    return text.replace(/\\s+/g, \"\").includes(keyword.replace(/\\s+/g, \"\"));\r\n  }\r\n\r\n  let found = keywords.some((k) => fuzzyIncludes(clientText, k));\r\n\r\n\r\n  // 6.1Ô∏è‚É£ Success phrases (GPay / PhonePe / Paytm)\r\n  const successPhrases = [\r\n    \"payment successful\",\r\n    \"money sent\",\r\n    \"you paid\",\r\n    \"transaction successful\",\r\n    \"paid successfully\",\r\n    \"credited to your account\",\r\n    \"debited from your account\",\r\n    \"sent to\",\r\n    \"received from\"\r\n  ];\r\n\r\n  if (!found) {\r\n    found = successPhrases.some((p) => fuzzyIncludes(clientText, p));\r\n  }\r\n\r\n\r\n  // 6.2Ô∏è‚É£ UPI handle detection (regex)\r\n  const upiHandleRegex = /[a-z0-9._%+-]+@([a-z]+|[a-z]+bank|okaxis|oksbi|ybl|ibl|axl)/i;\r\n  if (!found && upiHandleRegex.test(clientText)) {\r\n    found = true;\r\n  }\r\n\r\n\r\n  // 6.3Ô∏è‚É£ Amount pattern detection\r\n  const amountRegex = /(‚Çπ|rs\\.?)\\s?\\d+(\\.\\d{1,2})?/i;\r\n  if (!found && amountRegex.test(clientText)) {\r\n    found = true;\r\n  }\r\n\r\n\r\n  // 6.4Ô∏è‚É£ Transaction layout keywords\r\n  const layoutKeywords = [\"to\", \"from\", \"via upi\", \"scan & pay\", \"scan and pay\"];\r\n  if (!found) {\r\n    found = layoutKeywords.some((k) => fuzzyIncludes(clientText, k));\r\n  }\r\n\r\n  // 7.1 Noise Analysis ‚Äî detect overly smooth areas (edited or AI)\r\n  const { variance } = await computeNoiseVariance(buffer);\r\n  if (variance < 5) return \"suspiciously_smooth\"; // edited / AI look\r\n\r\n  // 7.2 Edge Detection ‚Äî high edge discontinuity means edits\r\n  const edgeScore = await computeEdgeScore(buffer);\r\n  if (edgeScore > 0.35) return \"edge_artifacts_detected\";\r\n\r\n  // 7.3 Compression Pattern Consistency\r\n  if (meta.format === \"jpeg\" && meta.density && meta.density < 50) {\r\n    return \"weird_compression_pattern\";\r\n  }\r\n\r\n  // 7.4 Metadata inconsistencies\r\n  if (exif && exif.Software && exif.Software.includes(\"Photoshop\")) {\r\n    return \"edited_metadata\";\r\n  }\r\n\r\n\r\n\r\n  // ‚ùå final fail if NOTHING matched\r\n  if (!found) return \"not_upi_keywords\";\r\n\r\n\r\n  return null; // VALID\r\n}\r\n\r\n\r\n\r\n// detect payment paid or else \r\nexport function detectPaymentDirection(text = \"\") {\r\n  const t = text.toLowerCase();\r\n\r\n  const paidWords = [\r\n    \"paid successfully\",\r\n    \"paid\",\r\n    \"payment successful\",\r\n    \"you paid\",\r\n    \"sent\",\r\n    \"debited\",\r\n    \"paid to\",\r\n  ];\r\n\r\n  const receivedWords = [\r\n    \"received\",\r\n    \"payment received\",\r\n    \"credited\",\r\n    \"you received\",\r\n    \"received from\",\r\n    \"money received\",\r\n  ];\r\n\r\n  const paid = paidWords.some((w) => t.includes(w));\r\n  const received = receivedWords.some((w) => t.includes(w));\r\n\r\n  if (paid && !received) return \"PAID\";\r\n  if (!paid && received) return \"RECEIVED\";\r\n\r\n  // If both appear ‚Üí pick strongest match\r\n  if (paid && received) {\r\n    // Usually amount is closer to paid area\r\n    return \"PAID\";\r\n  }\r\n\r\n  return \"UNKNOWN\";\r\n}\r\n\r\n\r\n// extract date for ocr \r\nexport function extractDate(text) {\r\n  if (!text) return null;\r\n\r\n  text = text.replace(/,/g, \"\").trim();\r\n\r\n  // Supported formats:\r\n  // 24/01/2025\r\n  // 24-01-2025\r\n  // 24.01.2025\r\n  // 2025/01/24\r\n  // 24 Jan 2025\r\n  // Jan 24 2025\r\n\r\n  const patterns = [\r\n    /\\b(\\d{2})\\/(\\d{2})\\/(\\d{4})\\b/,      // 24/01/2025\r\n    /\\b(\\d{2})-(\\d{2})-(\\d{4})\\b/,        // 24-01-2025\r\n    /\\b(\\d{2})\\.(\\d{2})\\.(\\d{4})\\b/,      // 24.01.2025\r\n    /\\b(\\d{4})\\/(\\d{2})\\/(\\d{2})\\b/,      // 2025/01/24\r\n    /\\b(\\d{2})\\s([A-Za-z]+)\\s(\\d{4})\\b/,  // 24 Jan 2025\r\n    /\\b([A-Za-z]+)\\s(\\d{2})\\s(\\d{4})\\b/   // Jan 24 2025\r\n  ];\r\n\r\n  for (let regex of patterns) {\r\n    const match = text.match(regex);\r\n    if (match) return match[0]; // Return exact date string found\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\n\r\n\r\n\r\n\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 407, "column": 0}, "map": {"version":3,"sources":["file:///E:/Project%20Files/Earning-model/stamp-card-project/stamp-loyalty-platform/lib/upiTime.js"],"sourcesContent":["/**\r\n * Validate screenshot date + time independently,\r\n * supporting all UPI app variations.\r\n *\r\n * @param {string|null} dateStr\r\n * @param {string|null} timeStr\r\n */\r\nexport function validateUPIScreenshotTime(dateStr, timeStr) {\r\n    if (!dateStr || !timeStr) {\r\n        return { valid: false, reason: \"Invalid date and time.\" };\r\n    }\r\n\r\n    // Normalize input first\r\n    dateStr = dateStr.trim().replace(/,/g, \"\");\r\n    timeStr = timeStr.trim().replace(/\\./g, \":\").replace(/-/g, \":\");\r\n\r\n    let parsedDate = parseUPIDate(dateStr);\r\n    let parsedTime = parseUPITime(timeStr);\r\n\r\n    if (!parsedDate) {\r\n        return { valid: false, reason: \"Invalid date and time\" };\r\n    }\r\n\r\n    if (!parsedTime) {\r\n        return { valid: false, reason: \"Invalid date and time\" };\r\n    }\r\n\r\n    // Merge date + time into a real Date object safely\r\n    const finalDateTime = new Date(\r\n        parsedDate.year,\r\n        parsedDate.month - 1,\r\n        parsedDate.day,\r\n        parsedTime.hour,\r\n        parsedTime.minute,\r\n        parsedTime.second\r\n    );\r\n\r\n    if (isNaN(finalDateTime.getTime())) {\r\n        return { valid: false, reason: \"failed_datetime_merge\" };\r\n    }\r\n\r\n    const now = new Date();\r\n\r\n    // Screenshot cannot be from the future\r\n    if (finalDateTime > now) {\r\n        return { valid: false, reason: \"future_screenshot_time\" };\r\n    }\r\n\r\n    // Check maximum allowed age: 15 minutes\r\n    const diffMinutes = (now - finalDateTime) / (1000 * 60);\r\n\r\n    if (diffMinutes > 15) {\r\n        return { valid: false, reason: \"screenshot_too_old\" };\r\n    }\r\n\r\n    return {\r\n        valid: true,\r\n        dateTime: finalDateTime,\r\n    };\r\n}\r\n\r\n\r\n/** -------------------------------\r\n * UPI DATE PARSER\r\n * Supports:\r\n *  - 24/01/2025\r\n *  - 24-01-2025\r\n *  - 24.01.2025\r\n *  - 2025/01/24\r\n *  - Jan 24, 2025\r\n *  - 24 Jan 2025\r\n ----------------------------------*/\r\nfunction parseUPIDate(dateStr) {\r\n    const formats = [\r\n        /^(\\d{2})\\/(\\d{2})\\/(\\d{4})$/,     // 24/01/2025\r\n        /^(\\d{2})-(\\d{2})-(\\d{4})$/,       // 24-01-2025\r\n        /^(\\d{2})\\.(\\d{2})\\.(\\d{4})$/,     // 24.01.2025\r\n        /^(\\d{4})\\/(\\d{2})\\/(\\d{2})$/,     // 2025/01/24\r\n        /^(\\d{2})\\s([A-Za-z]+)\\s(\\d{4})$/, // 24 Jan 2025\r\n        /^([A-Za-z]+)\\s(\\d{2}),\\s?(\\d{4})$/ // Jan 24, 2025\r\n    ];\r\n\r\n    for (let f of formats) {\r\n        const match = dateStr.match(f);\r\n        if (!match) continue;\r\n\r\n        // Format types\r\n        if (f === formats[0] || f === formats[1] || f === formats[2]) {\r\n            return { day: +match[1], month: +match[2], year: +match[3] };\r\n        }\r\n        if (f === formats[3]) {\r\n            return { year: +match[1], month: +match[2], day: +match[3] };\r\n        }\r\n        if (f === formats[4]) {\r\n            return { day: +match[1], month: monthToNumber(match[2]), year: +match[3] };\r\n        }\r\n        if (f === formats[5]) {\r\n            return { month: monthToNumber(match[1]), day: +match[2], year: +match[3] };\r\n        }\r\n    }\r\n\r\n    return null;\r\n}\r\n\r\n\r\n/** Convert \"Jan\", \"January\" ‚Üí 1 */\r\nfunction monthToNumber(m) {\r\n    const months = {\r\n        jan: 1, january: 1,\r\n        feb: 2, february: 2,\r\n        mar: 3, march: 3,\r\n        apr: 4, april: 4,\r\n        may: 5,\r\n        jun: 6, june: 6,\r\n        jul: 7, july: 7,\r\n        aug: 8, august: 8,\r\n        sep: 9, sept: 9, september: 9,\r\n        oct: 10, october: 10,\r\n        nov: 11, november: 11,\r\n        dec: 12, december: 12,\r\n    };\r\n    return months[m.toLowerCase()] || null;\r\n}\r\n\r\n\r\n/** -------------------------------\r\n * UPI TIME PARSER (ALL FORMATS)\r\n * Supports:\r\n *  - 10:42 AM\r\n *  - 10:42AM\r\n *  - 22:30\r\n *  - 10.42 PM\r\n *  - 10-42 am\r\n *  - 10:42:10\r\n ----------------------------------*/\r\nfunction parseUPITime(timeStr) {\r\n    let str = timeStr.toLowerCase();\r\n\r\n    // Replace separators\r\n    str = str.replace(/-/g, \":\").replace(/\\./g, \":\");\r\n\r\n    // Format 1: HH:MM AM/PM\r\n    let m = str.match(/^(\\d{1,2}):(\\d{2})(?:\\:(\\d{2}))?\\s?(am|pm)$/);\r\n    if (m) {\r\n        let h = +m[1];\r\n        let min = +m[2];\r\n        let sec = m[3] ? +m[3] : 0;\r\n\r\n        if (m[4] === \"pm\" && h !== 12) h += 12;\r\n        if (m[4] === \"am\" && h === 12) h = 0;\r\n\r\n        return { hour: h, minute: min, second: sec };\r\n    }\r\n\r\n    // Format 2: 24-hour HH:MM(:SS)\r\n    m = str.match(/^(\\d{1,2}):(\\d{2})(?:\\:(\\d{2}))?$/);\r\n    if (m) {\r\n        return { hour: +m[1], minute: +m[2], second: m[3] ? +m[3] : 0 };\r\n    }\r\n\r\n    return null;\r\n}\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 600, "column": 0}, "map": {"version":3,"sources":["file:///E:/Project%20Files/Earning-model/stamp-card-project/stamp-loyalty-platform/app/api/screenshot/verify/route.js"],"sourcesContent":["export const runtime = \"nodejs\";\r\n\r\nimport { NextResponse } from \"next/server\";\r\nimport crypto from \"crypto\";\r\nimport { PrismaClient } from \"@prisma/client\";\r\nimport { parsePaymentScreenshot } from \"@/lib/aiParser\";\r\nimport { validateScreenshotBeforeAI } from \"@/lib/tools\";\r\nimport { detectPaymentDirection } from \"@/lib/tools\";\r\nimport { validateUPIScreenshotTime } from \"@/lib/upiTime\";\r\nimport { error } from \"console\";\r\n\r\nconst prisma = new PrismaClient();\r\n\r\n/** SHA256 hash generator */\r\nfunction sha256(buffer) {\r\n    return crypto.createHash(\"sha256\").update(buffer).digest(\"hex\");\r\n}\r\n\r\nexport async function POST(req) {\r\n    try {\r\n        const formData = await req.formData();\r\n\r\n        const file = formData.get(\"file\");\r\n        const shopId = formData.get(\"shopId\");\r\n        const phone = formData.get(\"phone\");\r\n        const ocrJson = formData.get(\"ocrResult\");\r\n\r\n        let rejectReason = null;\r\n\r\n        if (!file || !shopId || !ocrJson || !phone) {\r\n            return NextResponse.json(\r\n                { error: \"Missing required fields\" },\r\n                { status: 400 }\r\n            );\r\n        }\r\n\r\n        const clientOCR = JSON.parse(ocrJson);\r\n        const { text: rawText } = clientOCR;\r\n\r\n        console.log('text', rawText)\r\n\r\n        // --------------------------------------\r\n        // 1Ô∏è‚É£ HASH ORIGINAL IMAGE (True Duplicate Prevention) and checksum\r\n        // --------------------------------------\r\n        const bytes = await file.arrayBuffer();\r\n        const buffer = Buffer.from(bytes);\r\n        const screenshotHash = sha256(buffer);\r\n        // base 64 image \r\n        const imageBase64 = buffer.toString(\"base64\");\r\n\r\n        // checksum \r\n        const checksum = crypto\r\n            .createHash(\"sha256\")\r\n            .update(\r\n                rawText\r\n                    ?.toLowerCase()\r\n                    .replace(/\\s+/g, \" \")\r\n                    .replace(/[^\\x20-\\x7E]/g, \"\")\r\n                    .trim()\r\n            )\r\n            .digest(\"hex\");\r\n\r\n\r\n\r\n\r\n\r\n        // --------------------------------------\r\n        // 2Ô∏è‚É£ FETCH SHOP and subscription details \r\n        // --------------------------------------\r\n        const shop = await prisma.shop.findUnique({ where: { id: shopId } });\r\n        if (!shop) {\r\n            return NextResponse.json(\r\n                { error: \"Invalid shopId.\" },\r\n                { status: 404 }\r\n            );\r\n        }\r\n\r\n        // Shop active check\r\n        if (!shop.isActive) {\r\n            return NextResponse.json(\r\n                { success: false, error: \"Shop is inactive.\" },\r\n                { status: 403 }\r\n            );\r\n        }\r\n\r\n        // get shop subscription details \r\n        const subscription = await prisma.subscription.findFirst({\r\n            where: { shopId }\r\n        });\r\n        if (!subscription) {\r\n            return NextResponse.json(\r\n                { success: false, error: \"Shop is not subscribed.\" },\r\n                { status: 403 }\r\n            );\r\n        }\r\n\r\n        // subscription status \r\n        if (subscription.status !== 'active' || subscription.nextBillingAt < new Date()) {\r\n            return NextResponse.json(\r\n                { success: false, error: \"Subscription expired.\" },\r\n                { status: 403 }\r\n            );\r\n        }\r\n\r\n\r\n        // 3Ô∏è‚É£ Detect payment direction (paid / received / unknown)\r\n        if (!rejectReason) {\r\n            const paymentDirection = detectPaymentDirection(rawText);\r\n\r\n            if (paymentDirection == 'RECEIVED') {\r\n                rejectReason = 'received_payment_direction.'\r\n            }\r\n        }\r\n\r\n\r\n        // --------------------------------------\r\n        // 4Ô∏è‚É£ PRE-VALIDATION BEFORE AI (cost saving)\r\n        // --------------------------------------\r\n        if (!rejectReason) {\r\n            const preFail = await validateScreenshotBeforeAI(buffer, clientOCR);\r\n\r\n            if (preFail) {\r\n                rejectReason = preFail;\r\n            }\r\n        }\r\n\r\n\r\n        // --------------------------------------\r\n        // 5Ô∏è‚É£ CHECK DUPLICATE SCREENSHOT\r\n        // --------------------------------------\r\n        if (!rejectReason) {\r\n            const duplicateHash = await prisma.scanVerification.findFirst({\r\n                where: {\r\n                    shopId,\r\n                    screenshotHash,\r\n                    status: \"success\"\r\n                },\r\n            });\r\n\r\n            if (duplicateHash) {\r\n                rejectReason = 'duplicate_image_hash'\r\n            }\r\n        }\r\n\r\n\r\n        //  Check duplicate OCR checksum\r\n        if (!rejectReason) {\r\n            const duplicateChecksum = await prisma.scanVerification.findFirst({\r\n                where: {\r\n                    shopId,\r\n                    checksum,\r\n                    status: \"success\"\r\n                }\r\n            });\r\n\r\n            if (duplicateChecksum) {\r\n                rejectReason = 'duplicate_image_ocr'\r\n            }\r\n        }\r\n\r\n\r\n        // pre ai verification scan save\r\n        if (rejectReason) {\r\n            const scan = await prisma.scanVerification.create({\r\n                data: {\r\n                    shopId,\r\n                    customerId: phone,\r\n                    amount: null,\r\n                    currency: \"INR\",\r\n                    upiId: clientOCR.upiId ?? null,\r\n                    utr: clientOCR.utr ?? null,\r\n                    paidAt: new Date(),\r\n                    status: \"rejected\",\r\n                    rejectReason,\r\n                    screenshotHash,\r\n                    appDetected: 'UNKNOWN',\r\n                    ocrText: rawText,\r\n                    checksum,\r\n                },\r\n            });\r\n\r\n            return NextResponse.json(\r\n                { success: false, rejectReason },\r\n                { status: 400 }\r\n            );\r\n        }\r\n\r\n\r\n        // --------------------------------------\r\n        // 6Ô∏è‚É£ AI OCR FIX PROCESSING\r\n        // --------------------------------------\r\n        const ai = await parsePaymentScreenshot(imageBase64);\r\n\r\n        if (ai.aiError) {\r\n            console.log(\"‚ö† AI unavailable ‚Äî continuing with client OCR only\");\r\n\r\n            return NextResponse.json(\r\n                { success: false, error: 'Server errors' },\r\n                { status: 400 }\r\n            );\r\n\r\n        }\r\n\r\n        console.log(\"AI FIXED OCR ‚Üí\", ai);\r\n\r\n        // AI corrected values (fallback to client OCR)\r\n        const amount = ai.amount ?? null;\r\n        const upiId = ai.upiId ?? clientOCR.upiId ?? null;\r\n        const utr = ai.utr ?? clientOCR.utr ?? null;\r\n        const date = ai.date ?? clientOCR.date ?? null;\r\n        const time = ai.time ?? clientOCR.time ?? null;\r\n        const appDetected = ai.appDetected ?? \"UNKNOWN\";\r\n        const isLikelyFake = ai.isLikelyFake ?? false;\r\n        const confidence = ai.confidence ?? null;\r\n        const status = ai.status ?? false\r\n\r\n\r\n\r\n        // if payment status not success \r\n        if (!rejectReason) {\r\n            if (status !== \"success\") {\r\n                return NextResponse.json(\r\n                    { success: false, rejectReason: \"payment_not_success.\" },\r\n                    { status: 400 }\r\n                )\r\n            }\r\n        }\r\n\r\n        // check utr \r\n        if (utr) {\r\n            const utrRegex = /^[0-9A-Za-z]{12,18}$/;\r\n\r\n            const utrExists = await prisma.scanVerification.findFirst({\r\n                where: { shopId, utr, status: 'success' },\r\n            });\r\n\r\n            if (!utrRegex.test(utr)) {\r\n                return NextResponse.json(\r\n                    { success: false, rejectReason: \"invalid_utr.\" },\r\n                    { status: 400 }\r\n                );\r\n            }\r\n\r\n            // duplicate utr \r\n            if (utrExists) {\r\n                return NextResponse.json(\r\n                    { success: false, rejectReason: \"utr_already_exist\" },\r\n                    { status: 400 }\r\n                )\r\n            }\r\n        }\r\n\r\n\r\n        // Validate amount\r\n        if (!amount) {\r\n            return NextResponse.json(\r\n                { success: false, rejectReason: \"amount_not_existed\" },\r\n                { status: 400 }\r\n            );\r\n        }\r\n\r\n        // amount limit \r\n        if (amount) {\r\n            if (amount < shop.minAmount) {\r\n                return NextResponse.json(\r\n                    { success: false, rejectReason: \"ammount_below_mimimum.\" },\r\n                    { status: 400 }\r\n                );\r\n            }\r\n        }\r\n\r\n\r\n        // time and date validation \r\n        const timeCheck = validateUPIScreenshotTime(date, time);\r\n        if (!timeCheck.valid) {\r\n            return NextResponse.json(\r\n                {\r\n                    success: false,\r\n                    rejectReason: timeCheck.reason,\r\n                },\r\n                { status: 400 }\r\n            );\r\n        }\r\n\r\n\r\n        // AI flagged fake\r\n        if (isLikelyFake) {\r\n            rejectReason = \"suspicious_screenshot\";\r\n        }\r\n\r\n        // check confidance \r\n        if (confidence) {\r\n            if (confidence < 0.80) {\r\n                return NextResponse.json(\r\n                    {\r\n                        success: false,\r\n                        rejectReason: 'confidance_low',\r\n                    },\r\n                    { status: 400 }\r\n                );\r\n            }\r\n        }\r\n\r\n\r\n        // upi mismatch \r\n        if (!upiId) {\r\n            rejectReason = 'upi_not_exist'\r\n        }\r\n\r\n        if (upiId) {\r\n            if (upiId !== shop.upiId) {\r\n                rejectReason = 'upi_mismatch'\r\n            }\r\n        }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n        // --------------------------------------\r\n        // 7Ô∏è‚É£ SAVE THE VERIFICATION RECORD\r\n        // --------------------------------------\r\n        const scan = await prisma.scanVerification.create({\r\n            data: {\r\n                shopId,\r\n                customerId: phone,\r\n                amount,\r\n                currency: \"INR\",\r\n                upiId,\r\n                utr,\r\n                paidAt: new Date(),\r\n                status: rejectReason ? \"rejected\" : \"success\",\r\n                rejectReason,\r\n                screenshotHash,\r\n                appDetected,\r\n                ocrText: rawText,\r\n            },\r\n        });\r\n\r\n        // If failed fraud check ‚Üí return here\r\n        if (rejectReason) {\r\n            return NextResponse.json(\r\n                { success: false, rejectReason },\r\n                { status: 400 }\r\n            );\r\n        }\r\n\r\n\r\n        // --------------------------------------\r\n        //  CREATE / FETCH CUSTOMER\r\n        // --------------------------------------\r\n        let customer = await prisma.customer.findFirst({\r\n            where: { shopId, phone },\r\n        });\r\n\r\n        if (!customer) {\r\n            customer = await prisma.customer.create({\r\n                data: {\r\n                    id: `cus_${crypto.randomUUID()}`,\r\n                    shopId,\r\n                    phone,\r\n                },\r\n            });\r\n        }\r\n\r\n        // --------------------------------------\r\n        // 8Ô∏è‚É£ AWARD STAMP\r\n        // --------------------------------------\r\n        await prisma.customer.update({\r\n            where: { id: customer.id },\r\n            data: {\r\n                stampCount: { increment: 1 },\r\n                totalVisits: { increment: 1 },\r\n                lastVisit: new Date(),\r\n            },\r\n        });\r\n\r\n        // --------------------------------------\r\n        // 9Ô∏è‚É£ TRANSACTION LOG\r\n        // --------------------------------------\r\n        await prisma.transaction.create({\r\n            data: {\r\n                id: `txn_${crypto.randomUUID()}`,\r\n                shopId,\r\n                customerId: customer.id,\r\n                amount,\r\n                status: \"success\",\r\n                upiId,\r\n                method: \"UPI_SCREENSHOT\",\r\n            },\r\n        });\r\n\r\n        return NextResponse.json({\r\n            success: true,\r\n            message: \"Stamp added!\",\r\n            scanId: scan.id,\r\n        });\r\n    } catch (err) {\r\n        console.error(\"VERIFY ERROR ‚Üí\", err);\r\n        return NextResponse.json(\r\n            { error: \"Server Error\" },\r\n            { status: 500 }\r\n        );\r\n    }\r\n}\r\n"],"names":[],"mappings":"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"}}]
}